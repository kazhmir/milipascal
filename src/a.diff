diff --git a/IR.md b/IR.md
index 46c8a84..fc3b3c6 100644
--- a/IR.md
+++ b/IR.md
@@ -316,17 +316,13 @@ Convert i16 -> i64:
 Convert i32 -> i64:
 	movsx rax, eax
 Convert t -> t
-	ignore
+	mov
 Convert bool -> numerical
-	just change the register name?
+	mov
 Call:
 	call a
 ```
 
-these are not allowed:
-convert Big -> small
-convert Numerical -> Bool
-
 ### Built-in procedures
 
 ```
diff --git a/backend/amd64/amd64.go b/backend/amd64/amd64.go
deleted file mode 100644
index 01e664f..0000000
--- a/backend/amd64/amd64.go
+++ /dev/null
@@ -1,811 +0,0 @@
-package amd64
-
-import (
-	mir "mpc/core/mir"
-	mirc "mpc/core/mir/class"
-	FT "mpc/core/mir/flowkind"
-	IT "mpc/core/mir/instrkind"
-	T "mpc/core/types"
-	"strconv"
-)
-
-func Generate(P *mir.Program) *fasmProgram {
-	output := &fasmProgram{
-		executable: []*fasmProc{genWrite(P), genRead(P), genError(P)},
-		data:       []*fasmData{},
-		entry:      genEntry(P),
-	}
-	for _, sy := range P.Symbols {
-		if !sy.Builtin {
-			if sy.Proc != nil {
-				proc := genProc(P, sy.Proc)
-				output.executable = append(output.executable, proc)
-			}
-			if sy.Mem != nil {
-				mem := genMem(sy.Mem)
-				output.data = append(output.data, mem)
-			}
-		}
-	}
-	return output
-}
-
-type fasmProgram struct {
-	entry      []*amd64Instr
-	executable []*fasmProc
-	data       []*fasmData
-}
-
-func (this *fasmProgram) String() string {
-	output := "format ELF64 executable 3\n"
-	output += "\nsegment readable writable\n"
-	for _, decData := range this.data {
-		output += decData.String()
-	}
-	output += "\nsegment readable executable\n"
-	output += "entry $\n"
-	for _, instr := range this.entry {
-		output += "\t" + instr.String() + "\n"
-	}
-	output += "; ---- end \n"
-	for _, fproc := range this.executable {
-		output += fproc.String()
-	}
-	return output
-}
-
-type fasmData struct {
-	label    string
-	content  string
-	declared bool
-}
-
-func (this *fasmData) String() string {
-	if this.declared {
-		return this.label + " db " + this.content + "\n"
-	}
-	return this.label + " rb " + this.content + "\n"
-}
-
-type fasmProc struct {
-	label  string
-	blocks []*fasmBlock // order matters
-}
-
-func (this *fasmProc) String() string {
-	output := ""
-	for _, b := range this.blocks {
-		output += b.String() + "\n"
-	}
-	return output
-}
-
-type fasmBlock struct {
-	label string
-	code  []*amd64Instr // order matters ofc
-}
-
-func (this *fasmBlock) String() string {
-	output := this.label + ":\n"
-	for _, instr := range this.code {
-		output += "\t" + instr.String() + "\n"
-	}
-	return output
-}
-
-type InstrType int
-
-type amd64Instr struct {
-	Instr string
-	Op1   string
-	Op2   string
-}
-
-func (this *amd64Instr) String() string {
-	if this.Instr == "" {
-		return "???"
-	}
-	if this.Op1 == "" {
-		return this.Instr
-	}
-	if this.Op2 == "" {
-		return this.Instr + "\t" + this.Op1
-	}
-	return this.Instr + "\t" + this.Op1 + ", " + this.Op2
-}
-
-const (
-	Add  = "add"
-	Sub  = "sub"
-	Neg  = "neg"
-	IMul = "imul"
-	IDiv = "idiv"
-	Xor  = "xor"
-
-	Mov   = "mov"
-	Movsx = "movsx"
-	Push  = "push"
-	Pop   = "pop"
-
-	And = "and"
-	Or  = "or"
-
-	Cmp = "cmp"
-
-	Sete  = "sete"
-	Setne = "setne"
-	Setg  = "setg"
-	Setge = "setge"
-	Setl  = "setl"
-	Setle = "setle"
-
-	Jmp = "jmp"
-	Je  = "je"
-	Jne = "jne"
-	Jg  = "jg"
-	Jge = "jge"
-	Jl  = "jl"
-	Jle = "jle"
-
-	Call    = "call"
-	Syscall = "syscall"
-	Ret     = "ret"
-)
-
-type register struct {
-	QWord string
-	DWord string
-	Word  string
-	Byte  string
-}
-
-// we use this three as scratch space, IDIV already needs rax and rdx,
-// and very rarely will a block need more than 3~5 registers
-var RAX = &register{QWord: "rax", DWord: "eax", Word: "ax", Byte: "al"}
-var RDX = &register{QWord: "rdx", DWord: "edx", Word: "dx", Byte: "dl"}
-var RBX = &register{QWord: "rbx", DWord: "ebx", Word: "bx", Byte: "bl"}
-
-var Registers = []*register{
-	{QWord: "r15", DWord: "r15d", Word: "r15w", Byte: "r15b"},
-	{QWord: "r14", DWord: "r14d", Word: "r14w", Byte: "r14b"},
-	{QWord: "r13", DWord: "r13d", Word: "r13w", Byte: "r13b"},
-	{QWord: "r12", DWord: "r12d", Word: "r12w", Byte: "r12b"},
-
-	{QWord: "r11", DWord: "r11d", Word: "r11w", Byte: "r11b"},
-	{QWord: "r10", DWord: "r10d", Word: "r10w", Byte: "r10b"},
-	{QWord: "r9", DWord: "r9d", Word: "r9w", Byte: "r9b"},
-	{QWord: "r8", DWord: "r8d", Word: "r8w", Byte: "r8b"},
-
-	{QWord: "rdi", DWord: "edi", Word: "di", Byte: "dil"},
-	{QWord: "rsi", DWord: "esi", Word: "si", Byte: "sil"},
-	{QWord: "rcx", DWord: "ecx", Word: "cx", Byte: "cl"},
-}
-
-// read[ptr, int] int
-func genRead(P *mir.Program) *fasmProc {
-	ptrArg := &mir.Operand{Class: mirc.CallerInterproc, Num: 0, Type: T.T_Ptr}
-	sizeArg := &mir.Operand{Class: mirc.CallerInterproc, Num: 1, Type: T.T_I64}
-	ptr := convertOperand(P, ptrArg, 0, 0, 0)
-	size := convertOperand(P, sizeArg, 0, 0, 0)
-	amountRead := ptr
-	return &fasmProc{
-		label: "_read",
-		blocks: []*fasmBlock{
-			{label: "_read", code: []*amd64Instr{
-				genUnaryInstr(Push, "rbp"),
-				genBinInstr(Mov, "rbp", "rsp"),
-
-				genBinInstr(Mov, "rdx", size),
-				genBinInstr(Mov, "rsi", ptr),
-				genBinInstr(Mov, "rdi", "0"), // STDERR
-				genBinInstr(Mov, "rax", "0"), // WRITE
-				{Instr: Syscall},
-
-				genBinInstr(Mov, amountRead, "rax"),
-
-				genBinInstr(Mov, "rsp", "rbp"),
-				genUnaryInstr(Pop, "rbp"),
-				{Instr: Ret},
-			}},
-		},
-	}
-}
-
-// write[ptr, int]
-func genWrite(P *mir.Program) *fasmProc {
-	ptrArg := &mir.Operand{Class: mirc.CallerInterproc, Num: 0, Type: T.T_Ptr}
-	sizeArg := &mir.Operand{Class: mirc.CallerInterproc, Num: 1, Type: T.T_I64}
-	ptr := convertOperand(P, ptrArg, 0, 0, 0)
-	size := convertOperand(P, sizeArg, 0, 0, 0)
-	return &fasmProc{
-		label: "_write",
-		blocks: []*fasmBlock{
-			{label: "_write", code: []*amd64Instr{
-				genUnaryInstr(Push, "rbp"),
-				genBinInstr(Mov, "rbp", "rsp"),
-
-				genBinInstr(Mov, "rdx", size),
-				genBinInstr(Mov, "rsi", ptr),
-				genBinInstr(Mov, "rdi", "1"), // STDOUT
-				genBinInstr(Mov, "rax", "1"), // WRITE
-				{Instr: Syscall},
-
-				genBinInstr(Mov, "rsp", "rbp"),
-				genUnaryInstr(Pop, "rbp"),
-				{Instr: Ret},
-			}},
-		},
-	}
-}
-
-// error[ptr, int]
-func genError(P *mir.Program) *fasmProc {
-	ptrArg := &mir.Operand{Class: mirc.CallerInterproc, Num: 0, Type: T.T_Ptr}
-	sizeArg := &mir.Operand{Class: mirc.CallerInterproc, Num: 1, Type: T.T_I64}
-	ptr := convertOperand(P, ptrArg, 0, 0, 0)
-	size := convertOperand(P, sizeArg, 0, 0, 0)
-	return &fasmProc{
-		label: "_error",
-		blocks: []*fasmBlock{
-			{label: "_error", code: []*amd64Instr{
-				genUnaryInstr(Push, "rbp"),
-				genBinInstr(Mov, "rbp", "rsp"),
-
-				genBinInstr(Mov, "rdx", size),
-				genBinInstr(Mov, "rsi", ptr),
-				genBinInstr(Mov, "rdi", "2"), // STDERR
-				genBinInstr(Mov, "rax", "1"), // WRITE
-				{Instr: Syscall},
-
-				genBinInstr(Mov, "rsp", "rbp"),
-				genUnaryInstr(Pop, "rbp"),
-				{Instr: Ret},
-			}},
-		},
-	}
-}
-
-func genMem(mem *mir.MemoryDecl) *fasmData {
-	if mem.Data == "" {
-		return &fasmData{
-			label:    mem.Label,
-			content:  strconv.FormatInt(mem.Size, 10),
-			declared: false,
-		}
-	}
-	return &fasmData{
-		label:    mem.Label,
-		content:  convertString(mem.Data),
-		declared: true,
-	}
-}
-
-func convertString(original string) string {
-	s := original[1 : len(original)-1] // removes quotes
-	output := "'"
-	for i := 0; i < len(s); i++ {
-		r := s[i]
-		if r == '\\' {
-			i++
-			r = s[i]
-			switch r {
-			case 'n':
-				output += "', 0xA, '"
-			case 't':
-				output += "', 0x9, '"
-			case 'r':
-				output += "', 0xD, '"
-			case '\'':
-				output += "', 0x27, '"
-			case '\\':
-				output += "', 0x5C, '"
-			default:
-				output += string(r)
-			}
-		} else {
-			output += string(r)
-		}
-	}
-	output += "'"
-	return output
-}
-
-func genEntry(P *mir.Program) []*amd64Instr {
-	entry := P.Symbols[P.Entry]
-	if entry == nil || entry.Proc == nil {
-		panic("nil entrypoint")
-	}
-	return []*amd64Instr{
-		genUnaryInstr(Call, entry.Proc.Label),
-		genBinInstr(Xor, "rdi", "rdi"), // EXIT CODE 0
-		genBinInstr(Mov, "rax", "60"),  // EXIT
-		{Instr: Syscall},
-	}
-}
-
-func genProc(P *mir.Program, proc *mir.Procedure) *fasmProc {
-	stackReserve := 8 * (proc.NumOfVars + proc.NumOfSpills + proc.NumOfMaxCalleeArguments)
-	init := &fasmBlock{
-		label: proc.Label,
-		code: []*amd64Instr{
-			genUnaryInstr(Push, "rbp"),
-			genBinInstr(Mov, "rbp", "rsp"),
-			genBinInstr(Sub, "rsp", strconv.FormatInt(int64(stackReserve), 10)),
-		},
-	}
-	fproc := &fasmProc{label: proc.Label, blocks: []*fasmBlock{init}}
-	proc.ResetBlocks()
-	fproc.blocks = append(fproc.blocks, genBlocks(P, proc, proc.FirstBlock())...)
-	return fproc
-}
-
-func genBlocks(P *mir.Program, proc *mir.Procedure, start *mir.BasicBlock) []*fasmBlock {
-	trueBranches := []*mir.BasicBlock{}
-	falseBlocks := genFalseBranches(P, proc, start, &trueBranches)
-	for _, tBlock := range trueBranches {
-		out := genBlocks(P, proc, tBlock)
-		falseBlocks = append(falseBlocks, out...)
-	}
-	return falseBlocks
-}
-
-func genFalseBranches(P *mir.Program, proc *mir.Procedure, block *mir.BasicBlock, trueBranches *[]*mir.BasicBlock) []*fasmBlock {
-	if block.Visited {
-		panic("no blocks should be already visited: " + block.Label)
-	}
-	block.Visited = true
-	fb := genCode(P, proc, block)
-
-	// should generate Jmp only for true branches and Jmps that point to
-	// already visited blocks
-	switch block.Out.T {
-	case FT.Jmp:
-		t := proc.GetBlock(block.Out.True)
-		if t.Visited {
-			jmp := genUnaryInstr(Jmp, t.Label)
-			fb.code = append(fb.code, jmp)
-			return []*fasmBlock{fb}
-		}
-		out := genFalseBranches(P, proc, t, trueBranches)
-		out = append([]*fasmBlock{fb}, out...)
-		return out
-	case FT.If:
-		t := proc.GetBlock(block.Out.True)
-		if !t.Visited {
-			*trueBranches = append(*trueBranches, t)
-		}
-		jmp := genCondJmp(P, proc, t, block.Out.V[0])
-		fb.code = append(fb.code, jmp...)
-		f := proc.GetBlock(block.Out.False)
-		out := genFalseBranches(P, proc, f, trueBranches)
-		out = append([]*fasmBlock{fb}, out...)
-		return out
-	case FT.Exit:
-		exit := genExit(P, proc, block.Out.V[0])
-		fb.code = append(fb.code, exit...)
-		return []*fasmBlock{fb}
-	case FT.Return:
-		ret := genRet()
-		fb.code = append(fb.code, ret...)
-		return []*fasmBlock{fb}
-	}
-	panic("Invalid flow: " + block.Out.String())
-}
-
-func genCondJmp(P *mir.Program, proc *mir.Procedure, block *mir.BasicBlock, op *mir.Operand) []*amd64Instr {
-	newOp := convertOperandProc(P, proc, op)
-	if op.Class == mirc.Lit || op.Class == mirc.Static {
-		rbx := genReg(RBX, op.Type)
-		return []*amd64Instr{
-			genBinInstr(Mov, rbx, newOp),
-			genBinInstr(Cmp, rbx, "1"),
-			genUnaryInstr(Je, block.Label),
-		}
-	}
-	return []*amd64Instr{
-		genBinInstr(Cmp, newOp, "1"),
-		genUnaryInstr(Je, block.Label),
-	}
-}
-
-func genRet() []*amd64Instr {
-	return []*amd64Instr{
-		genBinInstr(Mov, "rsp", "rbp"),
-		genUnaryInstr(Pop, "rbp"),
-		{Instr: Ret},
-	}
-}
-
-func genExit(P *mir.Program, proc *mir.Procedure, op *mir.Operand) []*amd64Instr {
-	exitCode := convertOperandProc(P, proc, op)
-	return []*amd64Instr{
-		genBinInstr(Xor, "rdi", "rdi"),
-		genBinInstr(Mov, "dil", exitCode), // EXIT CODE
-		genBinInstr(Mov, "rax", "60"),     // EXIT
-		{Instr: Syscall},
-	}
-}
-
-func genCode(P *mir.Program, proc *mir.Procedure, block *mir.BasicBlock) *fasmBlock {
-	output := make([]*amd64Instr, len(block.Code))[:0]
-	for _, instr := range block.Code {
-		output = append(output, genInstr(P, proc, instr)...)
-	}
-	return &fasmBlock{label: block.Label, code: output}
-}
-
-func genInstr(P *mir.Program, proc *mir.Procedure, instr *mir.Instr) []*amd64Instr {
-	switch instr.T {
-	case IT.Add, IT.Mult, IT.Or, IT.And:
-		return genBin(P, proc, instr)
-	case IT.Sub:
-		return genSub(P, proc, instr)
-	case IT.Eq, IT.Diff, IT.Less, IT.More, IT.LessEq, IT.MoreEq:
-		return genComp(P, proc, instr)
-	case IT.Load, IT.Store, IT.Copy:
-		return genLoadStore(P, proc, instr)
-	case IT.LoadPtr:
-		return genLoadPtr(P, proc, instr)
-	case IT.StorePtr:
-		return genStorePtr(P, proc, instr)
-	case IT.Neg:
-		return genUnaryMinus(P, proc, instr)
-	case IT.Div:
-		return genDiv(P, proc, instr)
-	case IT.Rem:
-		return genRem(P, proc, instr)
-	case IT.Not:
-		return genNot(P, proc, instr)
-	case IT.Convert:
-		return genConvert(P, proc, instr)
-	case IT.Call:
-		return genCall(P, proc, instr)
-	default:
-		panic("unimplemented: " + instr.String())
-	}
-}
-
-func genConvert(P *mir.Program, proc *mir.Procedure, instr *mir.Instr) []*amd64Instr {
-	if instr.Dest.Type.Size() > instr.A.Type.Size() {
-		newA := convertOperandProc(P, proc, instr.A)
-		newDest := convertOperandProc(P, proc, instr.Dest)
-		return []*amd64Instr{
-			genBinInstr(Movsx, newDest, newA),
-		}
-	}
-	if instr.A.Class == mirc.Lit {
-		newA := convertOperandProc(P, proc, instr.A)
-		newDest := convertOperandProc(P, proc, instr.Dest)
-		return []*amd64Instr{
-			genBinInstr(Mov, newDest, newA),
-		}
-	}
-	if instr.A.Class == mirc.Static {
-		newA := convertOperandProc(P, proc, instr.A)
-		newDest := convertOperandProc(P, proc, instr.Dest)
-		res := genReg(RAX, instr.Dest.Type)
-		return []*amd64Instr{
-			genBinInstr(Mov, "rax", newA),
-			genBinInstr(Mov, newDest, res),
-		}
-	}
-	if !areOpEqual(instr.A, instr.Dest) {
-		newA := getReg(instr.A.Num, instr.Dest.Type)
-		newDest := convertOperandProc(P, proc, instr.Dest)
-		return []*amd64Instr{
-			genBinInstr(Mov, newDest, newA),
-		}
-	}
-	return []*amd64Instr{}
-}
-
-func genCall(P *mir.Program, proc *mir.Procedure, instr *mir.Instr) []*amd64Instr {
-	newA := convertOperandProc(P, proc, instr.A)
-	return []*amd64Instr{
-		genUnaryInstr(Call, newA),
-	}
-}
-
-func genLoadStore(P *mir.Program, proc *mir.Procedure, instr *mir.Instr) []*amd64Instr {
-	newA := convertOperandProc(P, proc, instr.A)
-	newDest := convertOperandProc(P, proc, instr.Dest)
-	return []*amd64Instr{
-		genMov(newDest, newA),
-	}
-}
-
-func genLoadPtr(P *mir.Program, proc *mir.Procedure, instr *mir.Instr) []*amd64Instr {
-	newA := convertOperandProc(P, proc, instr.A)
-	newDest := convertOperandProc(P, proc, instr.Dest)
-	return []*amd64Instr{
-		genMov(newDest, genType(instr.Type)+"["+newA+"]"), // xD
-	}
-}
-
-func genStorePtr(P *mir.Program, proc *mir.Procedure, instr *mir.Instr) []*amd64Instr {
-	newA := convertOperandProc(P, proc, instr.A)
-	newDest := convertOperandProc(P, proc, instr.B)
-	return []*amd64Instr{
-		genMov(genType(instr.Type)+"["+newDest+"]", newA),
-	}
-}
-
-func genNot(P *mir.Program, proc *mir.Procedure, instr *mir.Instr) []*amd64Instr {
-	newA := convertOperandProc(P, proc, instr.A)
-	newDest := convertOperandProc(P, proc, instr.Dest)
-	return []*amd64Instr{
-		genBinInstr(Cmp, newA, "0"),
-		genUnaryInstr(Sete, newDest),
-	}
-}
-
-func genUnaryMinus(P *mir.Program, proc *mir.Procedure, instr *mir.Instr) []*amd64Instr {
-	newA := convertOperandProc(P, proc, instr.A)
-	newDest := convertOperandProc(P, proc, instr.Dest)
-	return []*amd64Instr{
-		genMov(newDest, newA),
-		genUnaryInstr(Neg, newDest),
-	}
-}
-
-var compInstrMap = map[IT.InstrKind]string{
-	IT.Eq:     Sete,
-	IT.Diff:   Setne,
-	IT.Less:   Setl,
-	IT.More:   Setg,
-	IT.MoreEq: Setge,
-	IT.LessEq: Setle,
-}
-
-func genComp(P *mir.Program, proc *mir.Procedure, instr *mir.Instr) []*amd64Instr {
-	newOp1 := convertOperandProc(P, proc, instr.A)
-	newOp2 := convertOperandProc(P, proc, instr.B)
-	newDest := convertOperandProc(P, proc, instr.Dest)
-	newInstr := compInstrMap[instr.T]
-	if instr.A.Class == mirc.Lit || instr.A.Class == mirc.Static {
-		rbx := genReg(RBX, instr.A.Type)
-		return []*amd64Instr{
-			genBinInstr(Mov, rbx, newOp1),
-			genBinInstr(Cmp, rbx, newOp2),
-			genUnaryInstr(newInstr, newDest),
-		}
-	}
-	return []*amd64Instr{
-		genBinInstr(Cmp, newOp1, newOp2),
-		genUnaryInstr(newInstr, newDest),
-	}
-}
-
-func genDiv(P *mir.Program, proc *mir.Procedure, instr *mir.Instr) []*amd64Instr {
-	newOp1 := convertOperandProc(P, proc, instr.A)
-	newOp2 := convertOperandProc(P, proc, instr.B)
-	newDest := convertOperandProc(P, proc, instr.Dest)
-	if instr.B.Class == mirc.Lit || instr.B.Class == mirc.Static {
-		rbx := genReg(RBX, instr.Type)
-		return []*amd64Instr{
-			genBinInstr(Xor, RDX.QWord, RDX.QWord),
-			genMov(genReg(RAX, instr.Type), newOp1),
-			genMov(rbx, newOp2),
-			genUnaryInstr(IDiv, rbx),
-			genMov(newDest, genReg(RAX, instr.Type)),
-		}
-	}
-	return []*amd64Instr{
-		genBinInstr(Xor, RDX.QWord, RDX.QWord),
-		genMov(genReg(RAX, instr.Type), newOp1),
-		genUnaryInstr(IDiv, newOp2),
-		genMov(newDest, genReg(RAX, instr.Type)),
-	}
-}
-
-func genRem(P *mir.Program, proc *mir.Procedure, instr *mir.Instr) []*amd64Instr {
-	newOp1 := convertOperandProc(P, proc, instr.A)
-	newOp2 := convertOperandProc(P, proc, instr.B)
-	newDest := convertOperandProc(P, proc, instr.Dest)
-	if mirc.IsImmediate(instr.B.Class) {
-		rbx := genReg(RBX, instr.Type)
-		return []*amd64Instr{
-			genBinInstr(Xor, RDX.QWord, RDX.QWord),
-			genMov(genReg(RAX, instr.Type), newOp1),
-			genMov(rbx, newOp2),
-			genUnaryInstr(IDiv, rbx),
-			genMov(newDest, genReg(RDX, instr.Type)),
-		}
-	}
-	return []*amd64Instr{
-		genBinInstr(Xor, RDX.QWord, RDX.QWord),
-		genMov(genReg(RAX, instr.Type), newOp1),
-		genUnaryInstr(IDiv, newOp2),
-		genMov(newDest, genReg(RDX, instr.Type)),
-	}
-}
-
-var BinInstrMap = map[IT.InstrKind]string{
-	IT.Add:  Add,
-	IT.Sub:  Sub,
-	IT.Mult: IMul,
-	IT.And:  And,
-	IT.Or:   Or,
-}
-
-func genSub(P *mir.Program, proc *mir.Procedure, instr *mir.Instr) []*amd64Instr {
-	sub := BinInstrMap[instr.T]
-
-	if areOpEqual(instr.A, instr.Dest) {
-		newOp1 := convertOperandProc(P, proc, instr.B)
-		newDest := convertOperandProc(P, proc, instr.Dest)
-		return []*amd64Instr{
-			genBinInstr(sub, newDest, newOp1),
-		}
-	}
-
-	if areOpEqual(instr.B, instr.Dest) {
-		rbx := genReg(RBX, instr.Type)
-		newOp1 := convertOperandProc(P, proc, instr.A)
-		newOp2 := convertOperandProc(P, proc, instr.B)
-		newDest := convertOperandProc(P, proc, instr.Dest)
-		return []*amd64Instr{
-			genBinInstr(Xor, RBX.QWord, RBX.QWord),
-			genMov(rbx, newOp1),
-			genBinInstr(sub, rbx, newOp2),
-			genMov(newDest, rbx),
-		}
-	}
-
-	newOp1 := convertOperandProc(P, proc, instr.A)
-	newOp2 := convertOperandProc(P, proc, instr.B)
-	newDest := convertOperandProc(P, proc, instr.Dest)
-	return []*amd64Instr{
-		genMov(newDest, newOp1),
-		genBinInstr(sub, newDest, newOp2),
-	}
-}
-
-func genBin(P *mir.Program, proc *mir.Procedure, instr *mir.Instr) []*amd64Instr {
-	dest, op := convertToTwoAddr(instr)
-	newInstr := BinInstrMap[instr.T]
-	if dest == nil || op == nil {
-		newOp1 := convertOperandProc(P, proc, instr.A)
-		newOp2 := convertOperandProc(P, proc, instr.B)
-		newDest := convertOperandProc(P, proc, instr.Dest)
-		return []*amd64Instr{
-			genMov(newDest, newOp1),
-			genBinInstr(newInstr, newDest, newOp2),
-		}
-	}
-	newOp1 := convertOperandProc(P, proc, op)
-	newDest := convertOperandProc(P, proc, dest)
-	return []*amd64Instr{
-		genBinInstr(newInstr, newDest, newOp1),
-	}
-}
-
-func genUnaryInstr(instr string, op string) *amd64Instr {
-	return &amd64Instr{
-		Instr: instr,
-		Op1:   op,
-	}
-}
-
-func genBinInstr(instr string, dest, source string) *amd64Instr {
-	return &amd64Instr{
-		Instr: instr,
-		Op1:   dest,
-		Op2:   source,
-	}
-}
-
-func genMov(dest, source string) *amd64Instr {
-	return &amd64Instr{
-		Instr: Mov,
-		Op1:   dest,
-		Op2:   source,
-	}
-}
-
-func convertToTwoAddr(instr *mir.Instr) (dest *mir.Operand, op *mir.Operand) {
-	if instr.Dest == nil {
-		return nil, nil
-	}
-	if instr.T == IT.Sub {
-		panic("subtraction is not associative")
-	}
-
-	if areOpEqual(instr.A, instr.Dest) {
-		return instr.Dest, instr.B
-	}
-	if areOpEqual(instr.B, instr.Dest) {
-		return instr.Dest, instr.A
-	}
-
-	return nil, nil
-}
-
-func areOpEqual(a, b *mir.Operand) bool {
-	return a.Class == b.Class &&
-		a.Num == b.Num
-}
-
-func convertOperandProc(P *mir.Program, proc *mir.Procedure, op *mir.Operand) string {
-	return convertOperand(P, op, int64(proc.NumOfVars), int64(proc.NumOfSpills), int64(proc.NumOfMaxCalleeArguments))
-}
-
-func convertOperand(P *mir.Program, op *mir.Operand, NumOfVars, NumOfSpills, NumOfMaxCalleeArguments int64) string {
-	switch op.Class {
-	case mirc.Register:
-		return getReg(op.Num, op.Type)
-	case mirc.CallerInterproc:
-		//        v must jump last rbp + return address
-		offset := 16 + op.Num*8
-		return genType(op.Type) + "[rbp + " + strconv.FormatInt(offset, 10) + "]"
-	case mirc.Local:
-		//        v begins at 8 because rbp points to the last rbp
-		offset := 8 + op.Num*8
-		return genType(op.Type) + "[rbp - " + strconv.FormatInt(offset, 10) + "]"
-	case mirc.Spill:
-		offset := 8 + NumOfVars*8 + op.Num*8
-		return genType(op.Type) + "[rbp - " + strconv.FormatInt(offset, 10) + "]"
-	case mirc.CalleeInterproc:
-		offset := 8 + NumOfVars*8 +
-			NumOfSpills*8 +
-			// v count                   v index
-			(NumOfMaxCalleeArguments-1-op.Num)*8
-		return genType(op.Type) + "[rbp - " + strconv.FormatInt(offset, 10) + "]"
-	case mirc.Lit:
-		return strconv.FormatInt(op.Num, 10)
-	case mirc.Static:
-		sy := P.Symbols[op.Num]
-		if sy.Proc != nil {
-			return sy.Proc.Label
-		}
-		return sy.Mem.Label
-	}
-	panic("unimplemented: " + op.String())
-}
-
-func getReg(num int64, t *T.Type) string {
-	if num > int64(len(Registers)) || num < 0 {
-		panic("oh no")
-	}
-	r := Registers[num]
-	return genReg(r, t)
-}
-
-func genReg(r *register, t *T.Type) string {
-	if T.IsBasic(t) {
-		switch t.Basic {
-		case T.Ptr:
-			return r.QWord
-		case T.I64:
-			return r.QWord
-		case T.I32:
-			return r.DWord
-		case T.I16:
-			return r.Word
-		case T.I8:
-			return r.Byte
-		case T.Bool:
-			return r.Byte
-		}
-	} else {
-		if !T.IsProc(t) {
-			panic(t.String())
-		}
-		return r.QWord
-	}
-	panic(t.String())
-}
-
-func genType(t *T.Type) string {
-	switch t.Size() {
-	case 1:
-		return "byte"
-	case 2:
-		return "word"
-	case 4:
-		return "dword"
-	case 8:
-		return "qword"
-	}
-	panic(t.String())
-}
diff --git a/backend/backend.go b/backend/backend.go
deleted file mode 100644
index de968b9..0000000
--- a/backend/backend.go
+++ /dev/null
@@ -1,33 +0,0 @@
-package backend
-
-import (
-	"fmt"
-	"mpc/backend/amd64"
-	"mpc/backend/resalloc"
-	. "mpc/core"
-	"mpc/core/hir"
-	"mpc/core/mir"
-	mirchecker "mpc/core/mir/checker"
-)
-
-var NumRegisters = len(amd64.Registers)
-
-func Generate(P *hir.Program) (string, *Error) {
-	mirP := resalloc.Allocate(P, NumRegisters)
-	err := mirchecker.Check(mirP)
-	if err != nil {
-		return "", err
-	}
-	out := amd64.Generate(mirP)
-	return out.String(), nil
-}
-
-func Mir(M *hir.Program) (*mir.Program, *Error) {
-	mirP := resalloc.Allocate(M, NumRegisters)
-	fmt.Println(mirP)
-	err := mirchecker.Check(mirP)
-	if err != nil {
-		return nil, err
-	}
-	return mirP, nil
-}
diff --git a/backend/resalloc/resalloc.go b/backend/resalloc/resalloc.go
deleted file mode 100644
index 3e7bf59..0000000
--- a/backend/resalloc/resalloc.go
+++ /dev/null
@@ -1,1152 +0,0 @@
-package resalloc
-
-import (
-	hir "mpc/core/hir"
-	hc "mpc/core/hir/class"
-	hfk "mpc/core/hir/flowkind"
-	hik "mpc/core/hir/instrkind"
-
-	mir "mpc/core/mir"
-	mc "mpc/core/mir/class"
-	mfk "mpc/core/mir/flowkind"
-	mik "mpc/core/mir/instrkind"
-
-	T "mpc/core/types"
-
-	IRU "mpc/core/mir/util"
-
-	"strconv"
-	"strings"
-)
-
-type reg int64
-type spill int64
-type calleeInterproc int64
-type callerInterproc int64
-
-type value struct {
-	Class hc.Class
-	Num   int64
-}
-
-func (v value) String() string {
-	return v.Class.String() + " " + strconv.FormatInt(v.Num, 10)
-}
-
-type stack struct {
-	items []int
-	top   int
-}
-
-func (s *stack) String() string {
-	output := []string{}
-	for _, item := range s.items[:s.top+1] {
-		output = append(output, strconv.Itoa(item))
-	}
-	return "[" + strings.Join(output, ", ") + "]"
-}
-
-func newStack(size int) *stack {
-	items := make([]int, size)
-	for i := range items {
-		items[i] = size - i - 1
-	}
-	return &stack{
-		items: items,
-		top:   size - 1,
-	}
-}
-
-func (s *stack) HasItems() bool {
-	return s.top >= 0
-}
-
-func (s *stack) Push(i int) {
-	s.top++
-	if s.top >= len(s.items) {
-		s.items = append(s.items, make([]int, 2)...)
-	}
-	s.items[s.top] = i
-}
-
-func (s *stack) Pop() int {
-	if s.top < 0 {
-		return s.items[0]
-	}
-	item := s.items[s.top]
-	s.top--
-	return item
-}
-
-func (s *stack) Size() int {
-	return s.top
-}
-
-type StorageClass int
-
-func (s StorageClass) String() string {
-	switch s {
-	case Register:
-		return "register"
-	case Local:
-		return "local"
-	case CalleeInterProc:
-		return "callee_interproc"
-	case CallerInterProc:
-		return "caller_interproc"
-	case Spill:
-		return "spill"
-	}
-	return "?"
-}
-
-func (s StorageClass) IsAddressable() bool {
-	return s == Local || s == Spill || s == CalleeInterProc || s == CallerInterProc
-}
-
-func (s StorageClass) ToMirc() mc.Class {
-	switch s {
-	case Register:
-		return mc.Register
-	case Local:
-		return mc.Local
-	case CalleeInterProc:
-		return mc.CalleeInterproc
-	case Spill:
-		return mc.Spill
-	}
-	return mc.InvalidMIRClass
-}
-
-const (
-	InvalidStorageClass StorageClass = iota
-
-	Register
-	Local
-	CalleeInterProc
-	CallerInterProc
-	Spill
-)
-
-type useInfo struct {
-	Place   StorageClass
-	Num     int64
-	T       *T.Type
-	Mutated bool
-}
-
-func (u useInfo) String() string {
-	return u.Place.String() + " " + strconv.FormatInt(u.Num, 10) + " " + u.T.String()
-}
-
-func (u useInfo) IsValid() bool {
-	if u.Place == InvalidStorageClass {
-		return false
-	}
-	if u.Num < 0 {
-		return false
-	}
-	if u.T == nil {
-		return false
-	}
-	return true
-}
-
-type deferredInstr struct {
-	index int
-	instr *mir.Instr
-}
-
-type state struct {
-	AvailableRegs *stack
-	// UsedRegs[ reg ] retuns the value stored in the register
-	UsedRegs map[reg]value
-
-	AvailableSpills *stack
-	// UsedSpills[ spill ] retuns the value stored in the spill address
-	UsedSpills map[spill]value
-
-	// LiveValues[ value ] retuns the register, interproc or spill storing this value
-	LiveValues map[value]useInfo
-
-	// stores the index of the furthest use of each value
-	valueUse map[value]int
-
-	MaxCalleeInterproc int
-
-	hirProgram *hir.Program
-	hirBlock   *hir.BasicBlock
-	hirProc    *hir.Procedure
-
-	outputBlock *mir.BasicBlock
-	outputProc  *mir.Procedure
-}
-
-func newState(program *hir.Program, numRegs int) *state {
-	return &state{
-		AvailableRegs: newStack(numRegs),
-		UsedRegs:      map[reg]value{},
-
-		AvailableSpills: newStack(16),
-		UsedSpills:      map[spill]value{},
-
-		LiveValues: map[value]useInfo{},
-		valueUse:   map[value]int{},
-
-		hirProgram: program,
-	}
-}
-
-func (s *state) ExpectValue(v value) useInfo {
-	info, ok := s.LiveValues[v]
-	if !ok {
-		//fmt.Println(s.String())
-		panic("value not found: " + v.String())
-	}
-	return info
-}
-
-func (s *state) Mark(v value) {
-	info, ok := s.LiveValues[v]
-	if !ok {
-		panic("marking dead value!")
-	}
-	if v.Class == hc.Local || v.Class == hc.Arg {
-		info.Mutated = true
-		s.LiveValues[v] = info
-	}
-}
-
-func (s *state) HasFreeRegs() bool {
-	return s.AvailableRegs.HasItems()
-}
-
-func (s *state) Free(v value) {
-	loc, ok := s.LiveValues[v]
-	if !ok {
-		panic("freeing unfound value")
-	}
-	delete(s.LiveValues, v)
-
-	switch loc.Place {
-	case Register:
-		r := reg(loc.Num)
-		s.FreeReg(r)
-	case Spill:
-		a := spill(loc.Num)
-		s.FreeSpill(a)
-	case CalleeInterProc:
-		// no need to keep track of this
-	case Local, CallerInterProc:
-		panic("freeing " + loc.Place.String())
-	}
-}
-
-func (s *state) FreeReg(r reg) {
-	_, ok := s.UsedRegs[r]
-	if ok {
-		delete(s.UsedRegs, r)
-		s.AvailableRegs.Push(int(r))
-		return
-	}
-	panic("freeing unused register: " + strconv.FormatInt(int64(r), 10))
-}
-
-func (s *state) FreeSpill(a spill) {
-	_, ok := s.UsedSpills[a]
-	if ok {
-		delete(s.UsedSpills, a)
-		s.AvailableSpills.Push(int(a))
-		return
-	}
-	panic("freeing unused spill")
-}
-
-func (s *state) AllocReg(v value, t *T.Type) reg {
-	info, ok := s.LiveValues[v]
-	if ok && info.Place == Register {
-		// this should be fine, live values shouldn't be corrupt
-		return reg(info.Num)
-	}
-	r := reg(s.AvailableRegs.Pop())
-	s.UsedRegs[r] = v
-	s.LiveValues[v] = useInfo{Place: Register, Num: int64(r), T: t}
-	return r
-}
-
-func (s *state) FurthestUse(index int) (useInfo, value) {
-	biggestIndex := index
-	var outputInfo useInfo
-	var outputValue value
-	for v, info := range s.LiveValues {
-		lastUse := s.valueUse[v]
-		if info.Place == Register && lastUse > biggestIndex {
-			biggestIndex = lastUse
-
-			outputInfo = info
-			outputValue = v
-		}
-	}
-
-	return outputInfo, outputValue
-}
-
-func (s *state) Spill(r reg, t *T.Type) spill {
-	v, ok := s.UsedRegs[r]
-	if !ok {
-		sreg := strconv.Itoa(int(r))
-		panic("spilling unused register: " + sreg)
-	}
-	useinfo := s.LiveValues[v]
-	s.FreeReg(r)
-	a := spill(s.AvailableSpills.Pop())
-	s.UpdateMaxSpill(int(a) + 1)
-	s.UsedSpills[a] = v
-	s.LiveValues[v] = useInfo{Place: Spill, Num: int64(a), T: t, Mutated: useinfo.Mutated}
-	return a
-}
-
-func (s *state) UpdateMaxCalleeInterproc(numargs int, numrets int) {
-	if numargs > s.MaxCalleeInterproc {
-		s.MaxCalleeInterproc = numargs
-	}
-	if numrets > s.MaxCalleeInterproc {
-		s.MaxCalleeInterproc = numrets
-	}
-}
-
-func (s *state) UpdateMaxSpill(spill int) {
-	if spill > s.outputProc.NumOfSpills {
-		s.outputProc.NumOfSpills = spill
-	}
-}
-
-// must preserve insertion order
-func (s *state) AddInstr(instr *mir.Instr) {
-	if instr == nil {
-		panic("NIL INSTRUCTION")
-	}
-	s.outputBlock.Code = append(s.outputBlock.Code, instr)
-}
-
-func (s *state) String() string {
-	livevalues := "Live Values ["
-	for value, useinfo := range s.LiveValues {
-		livevalues += "(" + value.String() + ", " + useinfo.String() + ") "
-	}
-	livevalues += "]"
-
-	registers := "Used Regs ["
-	for r, v := range s.UsedRegs {
-		rStr := strconv.FormatInt(int64(r), 10)
-		vStr := v.String()
-		registers += "(" + rStr + ", " + vStr + ")"
-	}
-	registers += "]"
-
-	return livevalues + "\n" + registers
-}
-
-func Allocate(P *hir.Program, numRegs int) *mir.Program {
-	output := &mir.Program{
-		Name:    P.Name,
-		Entry:   mir.SymbolID(P.Entry),
-		Symbols: make([]*mir.Symbol, len(P.Symbols)),
-	}
-	for i, sy := range P.Symbols {
-		if sy.Builtin {
-			output.Symbols[i] = allocBuiltin(sy)
-		} else {
-			if sy.Proc != nil {
-				proc := allocProc(P, sy.Proc, numRegs)
-				output.Symbols[i] = &mir.Symbol{Proc: proc}
-			}
-			if sy.Mem != nil {
-				mem := hirToMirMem(sy.Mem)
-				output.Symbols[i] = &mir.Symbol{Mem: mem}
-			}
-		}
-	}
-	return output
-}
-
-func allocBuiltin(sy *hir.Symbol) *mir.Symbol {
-	return &mir.Symbol{
-		Proc:    &mir.Procedure{Label: sy.Proc.Label},
-		Builtin: true,
-	}
-}
-
-func allocProc(Program *hir.Program, proc *hir.Procedure, numRegs int) *mir.Procedure {
-	outProc := hirToMirProc(proc)
-	outProc.AllBlocks = make([]*mir.BasicBlock, len(proc.AllBlocks))
-	outProc.NumOfSpills = 0
-	for i, curr := range proc.AllBlocks {
-		s := newState(Program, numRegs)
-		s.outputBlock = hirToMirBlock(curr)
-		s.outputProc = outProc
-		s.hirProc = proc
-		s.hirBlock = curr
-		findUses(s)
-		allocBlock(s)
-		calcRegions(s)
-		// preserve the BlockIDs
-		outProc.AllBlocks[i] = s.outputBlock
-	}
-	outProc.NumOfVars = len(proc.Vars)
-	return outProc
-}
-
-func calcRegions(s *state) {
-	if s.outputProc.NumOfMaxCalleeArguments < s.MaxCalleeInterproc {
-		s.outputProc.NumOfMaxCalleeArguments = s.MaxCalleeInterproc
-	}
-}
-
-func transformFlow(s *state) {
-	switch s.hirBlock.Out.T {
-	case hfk.Return:
-		transformReturn(s)
-	case hfk.Exit, hfk.If:
-		s.outputBlock.Out.T = hirToMirFlow(s.hirBlock.Out.T)
-		s.outputBlock.Out.V = []*mir.Operand{toMirc(s, s.hirBlock.Out.V[0])}
-	}
-}
-
-// TODO: OPT: transformReturn should look if the value is already where it needs to be (in the respective Caller Interproc)
-func transformReturn(s *state) {
-	type RetVal struct {
-		Index int64
-		Op    *hir.Operand
-	}
-
-	notAlive := []RetVal{}
-	// load the already immediate ones first
-	for i, ret := range s.hirBlock.Out.V {
-		rVal := toValue(ret)
-		info, ok := s.LiveValues[rVal]
-		if ok && info.Place == Register {
-			regOp := newRegOp(reg(info.Num), info.T)
-			callerInterproc := newOp(ret.Type, mc.CallerInterproc, int64(i))
-			loadRet := IRU.Store(regOp, callerInterproc)
-			s.AddInstr(loadRet)
-			s.Free(rVal)
-		} else {
-			rv := RetVal{Index: int64(i), Op: ret}
-			notAlive = append(notAlive, rv)
-		}
-	}
-
-	end := len(s.hirBlock.Code)
-	// then load the remaining
-	for _, ret := range notAlive {
-		immediateRet := ensureImmediate(s, end, toValue(ret.Op), ret.Op.Type)
-		callerInterproc := newOp(ret.Op.Type, mc.CallerInterproc, ret.Index)
-		loadRet := IRU.Store(immediateRet, callerInterproc)
-		s.AddInstr(loadRet)
-	}
-	s.outputBlock.Out.V = nil
-}
-
-func findUses(s *state) {
-	for index, instr := range s.hirBlock.Code {
-		vals := getUsedValues(instr)
-		for _, v := range vals {
-			s.valueUse[v] = index
-		}
-	}
-
-	// check if value is returned or used in branching
-	maxIndex := 1 << 31 // ensure it's after the s.atEnd instructions
-	for _, op := range s.hirBlock.Out.V {
-		if op.Class == hc.Temp || op.Class == hc.Local || op.Class == hc.Arg {
-			v := toValue(op)
-			s.valueUse[v] = maxIndex
-		}
-	}
-}
-
-func getUsedValues(instr *hir.Instr) []value {
-	output := []value{}
-	for _, op := range instr.Operands {
-		if op.Class == hc.Temp || op.Class == hc.Local || op.Class == hc.Arg {
-			output = append(output, toValue(op))
-		}
-	}
-	for _, dest := range instr.Destination {
-		if dest.Class == hc.Temp || dest.Class == hc.Local || dest.Class == hc.Arg {
-			output = append(output, toValue(dest))
-		}
-	}
-	return output
-}
-
-func allocBlock(s *state) *mir.BasicBlock {
-	for i, instr := range s.hirBlock.Code {
-		switch instr.T {
-		case hik.Add, hik.Sub, hik.Mult, hik.Div, hik.Rem,
-			hik.Eq, hik.Diff, hik.Less,
-			hik.More, hik.LessEq, hik.MoreEq,
-			hik.Or, hik.And:
-			allocBinary(s, instr, i)
-		case hik.Not, hik.Neg,
-			hik.Convert, hik.LoadPtr:
-			allocUnary(s, instr, i)
-		case hik.StorePtr:
-			allocStorePtr(s, instr, i)
-		case hik.Copy:
-			allocCopy(s, instr, i)
-		case hik.Call:
-			allocCall(s, instr, i)
-		}
-	}
-	if !s.hirBlock.IsTerminal() {
-		storeLiveLocals(s)
-	}
-	transformFlow(s)
-	return s.outputBlock
-}
-
-func allocBinary(s *state, instr *hir.Instr, index int) {
-	a := instr.Operands[0]
-	b := instr.Operands[1]
-	c := instr.Destination[0]
-
-	outInstr := hirToMirInstr(instr)
-	outInstr.A = ensureImmediate(s, index, toValue(a), a.Type)
-	outInstr.B = ensureImmediate(s, index, toValue(b), b.Type)
-
-	freeIfNotNeededAndNotMutated(s, index, toValue(a))
-	freeIfNotNeededAndNotMutated(s, index, toValue(b))
-
-	cv := toValue(c)
-	outInstr.Dest = ensureImmediate(s, index, cv, c.Type)
-	s.Mark(cv)
-
-	s.AddInstr(outInstr)
-}
-
-func allocUnary(s *state, instr *hir.Instr, index int) {
-	a := instr.Operands[0]
-	c := instr.Destination[0]
-
-	outInstr := hirToMirInstr(instr)
-	outInstr.A = ensureImmediate(s, index, toValue(a), a.Type)
-	freeIfNotNeededAndNotMutated(s, index, toValue(a))
-
-	cv := toValue(c)
-	outInstr.Dest = ensureImmediate(s, index, cv, c.Type)
-	s.Mark(cv)
-
-	s.AddInstr(outInstr)
-}
-
-func allocStorePtr(s *state, instr *hir.Instr, index int) {
-	a := instr.Operands[0]
-	b := instr.Operands[1]
-	outInstr := hirToMirInstr(instr)
-	outInstr.A = ensureImmediate(s, index, toValue(a), a.Type)
-	outInstr.B = ensureImmediate(s, index, toValue(b), b.Type)
-	freeIfNotNeededAndNotMutated(s, index, toValue(a))
-	freeIfNotNeededAndNotMutated(s, index, toValue(b))
-
-	s.AddInstr(outInstr)
-}
-
-// Combination of possible Copy instructions
-// Notation is: hirc (mirc) -> hirc (mirc)
-// 	temp (spill|reg|calleeInter) -> temp (reg)
-// 	temp (spill|reg|calleeInter) -> local (reg|local)
-// 	temp (spill|reg|calleeInter) -> arg (reg|callerInter)
-// 	local (reg|local) -> temp (reg)
-// 	local (reg|local) -> local (reg|local)
-// 	local (reg|local) -> arg (reg|callerInter)
-// 	arg (reg|callerInter) -> temp (reg)
-// 	arg (reg|callerInter) -> local (reg|local)
-// 	arg (reg|callerInter) -> arg (reg|callerInter)
-// 	global (static) -> temp (reg)
-// 	global (static) -> local
-// 	global (static) -> arg (reg|callerInter)
-// 	lit (lit) -> temp (reg)
-// 	lit (lit) -> local (reg|local)
-// 	lit (lit) -> arg (reg|callerInter)
-// c.HirC can only be Temp, Local or Arg
-func allocCopy(s *state, instr *hir.Instr, index int) {
-	source := instr.Operands[0]
-	sourceIsAddr := isAddressable(s, source)
-
-	dest := instr.Destination[0]
-	destIsAddr := isAddressable(s, dest)
-
-	outInstr := hirToMirInstr(instr)
-
-	if sourceIsAddr {
-		if destIsAddr {
-			// TODO: OPT: see if value is already in register
-			// LOAD  source -> reg
-			// STORE reg    -> dest
-			outInstr.T = mik.Load
-			outInstr.A = toMirc(s, source)
-			reg := allocReg(s, toValue(source), source.Type, index)
-			outInstr.Dest = reg
-			s.AddInstr(outInstr)
-
-			destMirc := toMirc(s, dest)
-			corruptOldVersion(s, dest)
-			s.AddInstr(IRU.Store(reg, destMirc))
-		} else {
-			// LOAD source -> dest
-			outInstr.T = mik.Load
-			outInstr.A = toMirc(s, source)
-			outInstr.Dest = toMirc(s, dest)
-			s.Mark(toValue(dest))
-
-			s.AddInstr(outInstr)
-		}
-	} else {
-		if destIsAddr {
-			// STORE source -> dest
-			outInstr.T = mik.Store
-			outInstr.A = toMirc(s, source)
-			outInstr.Dest = toMirc(s, dest)
-			corruptOldVersion(s, dest)
-
-			s.AddInstr(outInstr)
-		} else {
-			//fmt.Println(source, dest)
-			// COPY source -> dest
-			outInstr.A = toMirc(s, source)
-			outInstr.Dest = toMirc(s, dest)
-			s.Mark(toValue(dest))
-
-			s.AddInstr(outInstr)
-		}
-	}
-	res := freeIfNotNeeded(s, index, toValue(source))
-	if res != nil {
-		s.AddInstr(res)
-	}
-}
-
-func corruptOldVersion(s *state, op *hir.Operand) {
-	v := toValue(op)
-	info, ok := s.LiveValues[v]
-	if ok && info.Place == Register {
-		s.Free(v)
-	}
-}
-
-// transforms call instructions from:
-// 	call <proc>, <arg1>, ..., <argN> -> <ret1>, ..., <retN>
-// to:
-// 	store arg1 -> interproc1
-// 	...
-// 	store argN -> interprocN
-// 	call <proc>
-//
-// ret1 is assumed to be in interproc1
-// retN is assumed to be in interprocN
-func allocCall(s *state, instr *hir.Instr, index int) {
-	// TODO: OPT: spillAllLiveInterproc should only spill the ones being corrupted
-	spillAllLiveInterproc(s, index)
-	loadArguments(s, instr, index)
-	spillAllLiveRegisters(s, index)
-	// TODO: OPT: clearVolatiles should only clear the ones being corrupted
-	clearVolatiles(s)
-
-	outInstr := hirToMirInstr(instr)
-	outInstr.A = ensureImmediate(s, index, toValue(instr.Operands[0]), instr.Operands[0].Type)
-	s.AddInstr(outInstr)
-
-	for i, dest := range instr.Destination {
-		v := toValue(dest)
-		callee := calleeInterproc(i)
-		switch dest.Class {
-		case hc.Temp:
-			s.LiveValues[v] = useInfo{Place: CalleeInterProc, Num: int64(i), T: dest.Type}
-		case hc.Arg:
-			load, op := loadCalleeInterproc(s, callee, v, dest.Type, index)
-			s.AddInstr(load)
-			r := reg(op.Num)
-			arg := callerInterproc(v.Num)
-			store := storeArg(r, arg, dest.Type)
-			s.AddInstr(store)
-		case hc.Local:
-			load, op := loadCalleeInterproc(s, callee, v, dest.Type, index)
-			s.AddInstr(load)
-			r := reg(op.Num)
-			store := storeLocal(r, v.Num, dest.Type)
-			s.AddInstr(store)
-		}
-	}
-	for _, op := range instr.Operands {
-		freeIfNotNeeded(s, index, toValue(op))
-	}
-
-	s.UpdateMaxCalleeInterproc(len(instr.Operands)-1, len(instr.Destination))
-}
-
-func clearVolatiles(s *state) {
-	toFree := []value{}
-	for val, info := range s.LiveValues {
-		if info.Place != Local && info.Place != Spill {
-			toFree = append(toFree, val)
-		}
-	}
-	for _, v := range toFree {
-		s.Free(v)
-	}
-}
-
-func loadArguments(s *state, instr *hir.Instr, index int) {
-	// ensure immediate, then store
-	for i, op := range instr.Operands[1:] {
-		v := toValue(op)
-		info, ok := s.LiveValues[v]
-		if ok && info.Place == CalleeInterProc && info.Num == int64(i) {
-			// if it's already where it needs to be
-			continue
-		}
-		immediate := ensureImmediate(s, index, v, op.Type)
-		arg := newOp(op.Type, mc.CalleeInterproc, int64(i))
-		storeArg := IRU.Store(immediate, arg)
-		s.AddInstr(storeArg)
-	}
-}
-
-func isAddressable(s *state, o *hir.Operand) bool {
-	switch o.Class {
-	case hc.Temp:
-		info, ok := s.LiveValues[toValue(o)]
-		if ok {
-			return info.Place.IsAddressable()
-		}
-		panic("isAddressable: temp is not alive")
-	case hc.Lit, hc.Global:
-		return false
-	case hc.Local, hc.Arg:
-		return true
-	}
-	panic("isAddressable: wtf")
-}
-
-func toMirc(s *state, o *hir.Operand) *mir.Operand {
-	switch o.Class {
-	case hc.Temp:
-		info, ok := s.LiveValues[toValue(o)]
-		if ok {
-			return newOp(o.Type, info.Place.ToMirc(), info.Num)
-		}
-		panic("toMirc: temp is not alive")
-	case hc.Local:
-		return newOp(o.Type, mc.Local, o.Num)
-	case hc.Arg:
-		return newOp(o.Type, mc.CallerInterproc, o.Num)
-	case hc.Global:
-		return newOp(o.Type, mc.Static, o.Num)
-	case hc.Lit:
-		return newOp(o.Type, mc.Lit, o.Num)
-	}
-	panic("toMirc: wtf")
-}
-
-func storeLiveLocals(s *state) {
-	for val, info := range s.LiveValues {
-		if info.Place == Register && info.Mutated {
-			if val.Class == hc.Local {
-				r := reg(info.Num)
-				instr := storeLocal(r, val.Num, info.T)
-				s.AddInstr(instr)
-			}
-			if val.Class == hc.Arg {
-				r := reg(info.Num)
-				it := callerInterproc(val.Num)
-				instr := storeArg(r, it, info.T)
-				s.AddInstr(instr)
-			}
-		}
-	}
-}
-
-func spillAllLiveInterproc(s *state, index int) {
-	for val, info := range s.LiveValues {
-		lastUse := s.valueUse[val]
-		if info.Place == CalleeInterProc && lastUse > index {
-			callee := calleeInterproc(info.Num)
-			instr, op := loadCalleeInterproc(s, callee, val, info.T, index)
-			s.AddInstr(instr)
-			r := reg(op.Num)
-			spill := spillTemp(s, r, info.T)
-			s.AddInstr(spill)
-		}
-	}
-}
-
-func spillAllLiveRegisters(s *state, index int) {
-	for val, info := range s.LiveValues {
-		if info.Place == Register && info.Mutated {
-			switch val.Class {
-			case hc.Local:
-				r := reg(info.Num)
-				s.AddInstr(storeLocal(r, val.Num, info.T))
-			case hc.Arg:
-				r := reg(info.Num)
-				arg := callerInterproc(val.Num)
-				s.AddInstr(storeArg(r, arg, info.T))
-			case hc.Temp:
-				s.AddInstr(spillTemp(s, reg(info.Num), info.T))
-			}
-		}
-	}
-}
-
-func ensureImmediate(s *state, index int, v value, t *T.Type) *mir.Operand {
-	info, ok := s.LiveValues[v]
-	if ok {
-		switch info.Place {
-		case Register:
-			return newRegOp(reg(info.Num), t)
-		case Spill:
-			instr, op := loadSpill(s, v, info, index)
-			s.AddInstr(instr)
-			return op
-		case CalleeInterProc:
-			callee := calleeInterproc(info.Num)
-			instr, op := loadCalleeInterproc(s, callee, v, info.T, index)
-			s.AddInstr(instr)
-			return op
-		case CallerInterProc:
-			caller := callerInterproc(info.Num)
-			instr, op := loadCallerInterproc(s, v, caller, info.T, index)
-			s.AddInstr(instr)
-			return op
-		case Local:
-			instr, op := loadLocal(s, v, info.T, index)
-			s.AddInstr(instr)
-			return op
-		}
-		panic("ensureImmediate: Invalid StorageClass")
-	}
-	switch v.Class {
-	case hc.Temp:
-		return allocReg(s, v, t, index)
-	case hc.Local:
-		instr, op := loadLocal(s, v, t, index)
-		s.AddInstr(instr)
-		return op
-	case hc.Arg:
-		instr, op := loadArg(s, v, t, index)
-		s.AddInstr(instr)
-		return op
-	case hc.Global:
-		return newOp(t, mc.Static, v.Num)
-	case hc.Lit:
-		return newOp(t, mc.Lit, v.Num)
-	}
-	panic("ensureImmediate: Invalid HIRClass")
-}
-
-func newOp(t *T.Type, m mc.Class, num int64) *mir.Operand {
-	return &mir.Operand{
-		Class: m,
-		Type:  t,
-		Num:   num,
-	}
-}
-
-func loadCalleeInterproc(s *state, callee calleeInterproc, v value, t *T.Type, index int) (*mir.Instr, *mir.Operand) {
-	newOp := newCalleeInterprocOperand(callee, t)
-	rOp := allocReg(s, v, t, index)
-	load := IRU.Load(newOp, rOp)
-	return load, rOp
-}
-
-func loadCallerInterproc(s *state, v value, caller callerInterproc, t *T.Type, index int) (*mir.Instr, *mir.Operand) {
-	newOp := newCallerInterprocOperand(caller, t)
-	rOp := allocReg(s, v, t, index)
-	load := IRU.Load(newOp, rOp)
-	return load, rOp
-}
-
-func loadLocal(s *state, v value, t *T.Type, index int) (*mir.Instr, *mir.Operand) {
-	newOp := newLocalOperand(v.Num, t)
-	rOp := allocReg(s, v, t, index)
-	load := IRU.Load(newOp, rOp)
-	return load, rOp
-}
-
-func loadArg(s *state, v value, t *T.Type, index int) (*mir.Instr, *mir.Operand) {
-	newOp := newCallerInterprocOperand(callerInterproc(v.Num), t)
-	rOp := allocReg(s, v, t, index)
-	load := IRU.Load(newOp, rOp)
-	return load, rOp
-}
-
-func loadSpill(s *state, v value, info useInfo, index int) (*mir.Instr, *mir.Operand) {
-	sp := spill(info.Num)
-	newOp := newSpillOperand(sp, info.T)
-	s.FreeSpill(sp)
-	rOp := allocReg(s, v, info.T, index)
-	load := IRU.Load(newOp, rOp)
-	return load, rOp
-}
-
-func allocReg(s *state, v value, t *T.Type, index int) *mir.Operand {
-	if s.HasFreeRegs() {
-		r := s.AllocReg(v, t)
-		return newRegOp(r, t)
-	}
-	info, val := s.FurthestUse(index)
-	if !info.IsValid() {
-		// fmt.Print("\n------\n")
-		// fmt.Println(s.hirBlock)
-		// fmt.Print("\n------\n")
-		// fmt.Println(s)
-		// fmt.Printf("Value: %v, Type: %v, Index: %v\n", v, t, index)
-		panic("not enough registers")
-	}
-	switch val.Class {
-	case hc.Temp:
-		s.AddInstr(spillTemp(s, reg(info.Num), info.T))
-	case hc.Local:
-		if info.Mutated {
-			s.AddInstr(storeLocal(reg(info.Num), val.Num, info.T))
-		}
-		s.Free(val)
-	case hc.Arg:
-		if info.Mutated {
-			arg := callerInterproc(val.Num)
-			s.AddInstr(storeArg(reg(info.Num), arg, info.T))
-		}
-		s.Free(val)
-	case hc.Lit, hc.Global:
-		panic("what the fuck are we even doing")
-	}
-
-	r2 := s.AllocReg(v, t)
-	if reg(info.Num) != r2 {
-		panic("spillRegister: " + s.AvailableRegs.String() + "\n")
-	}
-	return newRegOp(reg(info.Num), t)
-}
-
-func spillTemp(s *state, r reg, t *T.Type) *mir.Instr {
-	sNum := s.Spill(r, t)
-	spillOp := newSpillOperand(sNum, t)
-	regOp := newRegOp(r, t)
-	return IRU.Store(regOp, spillOp)
-}
-
-func storeLocal(r reg, position int64, t *T.Type) *mir.Instr {
-	reg := newRegOp(r, t)
-	loc := newLocalOperand(position, t)
-	return IRU.Store(reg, loc)
-}
-
-func storeArg(r reg, num callerInterproc, t *T.Type) *mir.Instr {
-	reg := newRegOp(r, t)
-	loc := newCallerInterprocOperand(num, t)
-	return IRU.Store(reg, loc)
-}
-
-func newRegOp(r reg, t *T.Type) *mir.Operand {
-	return &mir.Operand{
-		Class: mc.Register,
-		Num:   int64(r),
-		Type:  t,
-	}
-}
-
-func newSpillOperand(sNum spill, t *T.Type) *mir.Operand {
-	return &mir.Operand{
-		Class: mc.Spill,
-		Num:   int64(sNum),
-		Type:  t,
-	}
-}
-
-func newLocalOperand(position int64, t *T.Type) *mir.Operand {
-	return &mir.Operand{
-		Class: mc.Local,
-		Type:  t,
-		Num:   position,
-	}
-}
-
-func newCalleeInterprocOperand(i calleeInterproc, t *T.Type) *mir.Operand {
-	return &mir.Operand{
-		Class: mc.CalleeInterproc,
-		Type:  t,
-		Num:   int64(i),
-	}
-}
-
-func newCallerInterprocOperand(i callerInterproc, t *T.Type) *mir.Operand {
-	return &mir.Operand{
-		Class: mc.CallerInterproc,
-		Type:  t,
-		Num:   int64(i),
-	}
-}
-
-// can only insert free after current instruction
-func freeIfNotNeededAndNotMutated(s *state, index int, v value) {
-	useInfo, ok := s.LiveValues[v]
-	if !ok {
-		return // already freed (i hope)
-	}
-	if isNeeded(s, index, v, useInfo) {
-		return
-	}
-	if useInfo.Mutated {
-		return
-	}
-	s.Free(v)
-}
-
-// can only insert free after current instruction
-func freeIfNotNeeded(s *state, index int, v value) *mir.Instr {
-	useInfo, ok := s.LiveValues[v]
-	if !ok {
-		return nil // already freed (i hope)
-	}
-	if isNeeded(s, index, v, useInfo) {
-		return nil
-	}
-	s.Free(v)
-	if !s.hirBlock.IsTerminal() { // no need to restore if is terminal
-		if v.Class == hc.Local && useInfo.Mutated {
-			r := reg(useInfo.Num)
-			instr := storeLocal(r, v.Num, useInfo.T)
-			return instr
-		}
-		if v.Class == hc.Arg && useInfo.Mutated {
-			r := reg(useInfo.Num)
-			arg := callerInterproc(v.Num)
-			instr := storeArg(r, arg, useInfo.T)
-			return instr
-		}
-	}
-	return nil
-}
-
-func isNeeded(s *state, index int, v value, useInfo useInfo) bool {
-	lastUse := s.valueUse[v]
-	if lastUse > index {
-		return true
-	}
-	return false
-}
-
-func toValue(op *hir.Operand) value {
-	return value{
-		Class: op.Class,
-		Num:   op.Num,
-	}
-}
-
-func hirToMirProc(proc *hir.Procedure) *mir.Procedure {
-	return &mir.Procedure{
-		Label:                   proc.Label,
-		Vars:                    proc.Vars,
-		Args:                    proc.Args,
-		Rets:                    proc.Rets,
-		Start:                   mir.BlockID(proc.Start),
-		NumOfVars:               0,
-		NumOfSpills:             0,
-		NumOfMaxCalleeArguments: 0,
-	}
-}
-
-func hirToMirInstrKind(hk hik.InstrKind) mik.InstrKind {
-	switch hk {
-	case hik.Add:
-		return mik.Add
-	case hik.Sub:
-		return mik.Sub
-	case hik.Neg:
-		return mik.Neg
-	case hik.Div:
-		return mik.Div
-	case hik.Mult:
-		return mik.Mult
-	case hik.Rem:
-		return mik.Rem
-	case hik.Eq:
-		return mik.Eq
-	case hik.Diff:
-		return mik.Diff
-	case hik.Less:
-		return mik.Less
-	case hik.More:
-		return mik.More
-	case hik.LessEq:
-		return mik.LessEq
-	case hik.MoreEq:
-		return mik.MoreEq
-	case hik.Or:
-		return mik.Or
-	case hik.And:
-		return mik.And
-	case hik.Not:
-		return mik.Not
-	case hik.Convert:
-		return mik.Convert
-	case hik.Load:
-		return mik.Load
-	case hik.Store:
-		return mik.Store
-	case hik.Copy:
-		return mik.Copy
-	case hik.LoadPtr:
-		return mik.LoadPtr
-	case hik.StorePtr:
-		return mik.StorePtr
-	case hik.Call:
-		return mik.Call
-	}
-	panic("unmapped hir instruction")
-}
-
-func hirToMirInstr(instr *hir.Instr) *mir.Instr {
-	return &mir.Instr{
-		T:    hirToMirInstrKind(instr.T),
-		Type: instr.Type,
-	}
-}
-
-func hirToMirFlow(f hfk.FlowKind) mfk.FlowKind {
-	switch f {
-	case hfk.Jmp:
-		return mfk.Jmp
-	case hfk.If:
-		return mfk.If
-	case hfk.Return:
-		return mfk.Return
-	case hfk.Exit:
-		return mfk.Exit
-	}
-	panic("invalid hirflow")
-}
-
-func hirToMirBlock(b *hir.BasicBlock) *mir.BasicBlock {
-	return &mir.BasicBlock{
-		Label: b.Label,
-		Code:  make([]*mir.Instr, len(b.Code))[:0],
-		Out: mir.Flow{
-			T:     hirToMirFlow(b.Out.T),
-			V:     []*mir.Operand{},
-			True:  mir.BlockID(b.Out.True),  // we can do this because we preserve ID numbers
-			False: mir.BlockID(b.Out.False), // between hir and mir
-		},
-		Visited: false,
-	}
-}
-
-func hirToMirMem(mem *hir.MemoryDecl) *mir.MemoryDecl {
-	return &mir.MemoryDecl{
-		Label: mem.Label,
-		Data:  mem.Data,
-		Size:  mem.Size,
-	}
-}
diff --git a/core/core.go b/core/core.go
deleted file mode 100644
index c641cea..0000000
--- a/core/core.go
+++ /dev/null
@@ -1,118 +0,0 @@
-package core
-
-import (
-	"fmt"
-	"io/ioutil"
-	et "mpc/core/errorkind"
-)
-
-type SourceLocation struct {
-	File      string
-	Input     *string
-	Line, Col int
-}
-
-func (sl *SourceLocation) String() string {
-	return fmt.Sprintf("%v:%v:%v", sl.File, sl.Line, sl.Col)
-}
-
-type Error struct {
-	Type  et.ErrorKind
-	Debug string
-
-	Info []Excerpt
-}
-
-// Example
-// text.mp:1:9 E0001
-//     a := ¬
-//          ^ Invalid character
-func (ce *Error) String() string {
-	if ce == nil {
-		return "<nil>"
-	}
-	first := ce.FirstInfo()
-	if first == nil {
-		return ce.Type.Debug() + "\t" + ce.Debug + "\n"
-	}
-	return first.Location.String() + " " +
-		ce.ErrCode() + "\n" +
-		ce.ExcerptsToStr()
-}
-
-func (ce *Error) ErrCode() string {
-	return ce.Type.String()
-}
-
-func (ce *Error) FirstInfo() *Excerpt {
-	if len(ce.Info) < 1 {
-		return nil
-	}
-	return &ce.Info[0]
-}
-
-func (ce *Error) ExcerptsToStr() string {
-	output := ""
-	for _, v := range ce.Info {
-		output += v.String() + "\n"
-	}
-	return output
-}
-
-type Excerpt struct {
-	Location *SourceLocation
-	Message  string
-}
-
-func (exc *Excerpt) String() string {
-	text := ""
-	if exc.Location == nil {
-		return exc.Message
-	}
-	if exc.Location.Input == nil {
-		f, err := ioutil.ReadFile(exc.Location.File)
-		if err != nil { // shoudn't happen
-			panic(err)
-		}
-		text = string(f)
-	} else {
-		text = *exc.Location.Input
-	}
-	line := getLine(text, exc.Location.Line)
-	return pointColumn(line+"  ", exc.Location.Col, exc.Message)
-}
-
-func getLine(s string, sLine int) string {
-	line := 0
-	col := 0
-	buff := []rune{}
-	for _, r := range s {
-		if r == '\n' {
-			line++
-			col = 0
-		} else {
-			col++
-		}
-
-		if line == sLine {
-			buff = append(buff, r)
-		}
-	}
-	return string(buff)
-}
-
-func pointColumn(s string, sCol int, message string) string {
-	newS := "\033[0;32m" + s + "\033[0m" + "\n"
-	for i, r := range s {
-		if i == sCol {
-			newS += "^ " + message
-			break
-		}
-		if r == '\t' {
-			newS += "\t"
-		} else {
-			newS += " "
-		}
-	}
-	return newS
-}
diff --git a/core/errorkind/errorkind.go b/core/errorkind/errorkind.go
deleted file mode 100644
index 17c8d1a..0000000
--- a/core/errorkind/errorkind.go
+++ /dev/null
@@ -1,220 +0,0 @@
-package errorkind
-
-import (
-	"fmt"
-)
-
-type ErrorKind int
-
-const (
-	/* internal (bad) errors */
-	InvalidErrType ErrorKind = iota
-	InternalCompilerError
-
-	/* lexer errors */
-	InvalidUTF8Rune
-	InvalidSymbol
-
-	/* parser errors */
-	ExpectedSymbol
-	ExpectedProd
-	ExpectedEOF
-
-	/* resolver error */
-	FileError
-	ImportError
-	InvalidFileName
-	ImportNameColision
-	FromImportingUnexportedName
-	InvalidDependencyCycle
-
-	/* semantic errors */
-	ExpectedName
-	NameAlreadyDefined
-	ExportingUndefName
-	DuplicatedExport
-	OperationBetweenUnequalTypes
-	InvalidInitForMemType
-	NameNotDefined
-	CanOnlyDerefPointers
-	CanOnlyAssignLocal
-	NotAssignable
-	InvalidType
-	InvalidMemResTerm
-	ExpectedConst
-	MismatchedTypeForArgument
-	InvalidNumberOfArgs
-	ExpectedProcedure
-	InvalidNumberOfReturns
-	MismatchedReturnType
-	ExpectedMem
-	InvalidUseOfString
-	MismatchedMultiRetAssignment
-	MismatchedTypeInMultiRetAssign
-	CopyTooBig
-	InvalidCopy
-	MismatchedTypeInAssign
-	BadConst
-	InvalidClassforExpr
-	CannotUseSyscallInExpr
-	CannotUseVoid
-	ExpectedBasicType
-	CanOnlyUseNormalAssignment
-	ExpectedNumber
-	ExitMustBeI8
-	PtrCantBeUsedAsMemSize
-	InvalidProp
-	NotAllCodePathsReturnAValue
-	InvalidMain
-	NoEntryPoint
-	AmbiguousModuleName
-	ModuleNotFound
-	NameNotExported
-)
-
-func (et ErrorKind) String() string {
-	v, ok := ErrorCodeMap[et]
-	if !ok {
-		panic(fmt.Sprintf("%d is not stringified", et))
-	}
-	return v
-}
-
-func (et ErrorKind) Debug() string {
-	if et == InvalidErrType {
-		panic("invalid ErrType")
-	}
-	v, ok := DebugMap[et]
-	if !ok {
-		panic("ErrType not mapped to string")
-	}
-	return v
-}
-
-var DebugMap = map[ErrorKind]string{
-	InvalidErrType:        "InvalidErrType",
-	InternalCompilerError: "InternalCompilerError",
-
-	/* resolver errors */
-	FileError:                   "FileError",
-	ImportError:                 "ImportError",
-	InvalidFileName:             "InvalidFileName",
-	ImportNameColision:          "ImportNameColision",
-	FromImportingUnexportedName: "FromImportingUnexportedName",
-
-	InvalidUTF8Rune: "InvalidUTF8Rune",
-	InvalidSymbol:   "InvalidSymbol",
-
-	ExpectedSymbol: "ExpectedSymbol",
-	ExpectedProd:   "ExpectedProd",
-	ExpectedEOF:    "ExpectedEOF",
-
-	ExpectedName: "ExpectedName",
-
-	NameAlreadyDefined:             "NameAlreadyDefined",
-	OperationBetweenUnequalTypes:   "OperationBetweenUnequalTypes",
-	DuplicatedExport:               "DuplicatedExport",
-	ExportingUndefName:             "ExportingUndefName",
-	InvalidDependencyCycle:         "InvalidDependencyCycle",
-	InvalidInitForMemType:          "InvalidInitForMemType",
-	NameNotDefined:                 "NameNotDefined",
-	CanOnlyDerefPointers:           "CanOnlyIndexMemory",
-	CanOnlyAssignLocal:             "CanOnlyAssignLocal",
-	NotAssignable:                  "NotAssignable",
-	InvalidType:                    "InvalidType",
-	InvalidMemResTerm:              "InvalidMemResTerm",
-	ExpectedConst:                  "ExpectedConst",
-	MismatchedTypeForArgument:      "MismatchedTypeForArgument",
-	InvalidNumberOfArgs:            "InvalidNumberOfArgs",
-	ExpectedProcedure:              "ExpectedProcedure",
-	InvalidNumberOfReturns:         "InvalidNumberOfReturns",
-	MismatchedReturnType:           "MismatchedReturnType",
-	ExpectedMem:                    "ExpectedMem",
-	InvalidUseOfString:             "InvalidUseOfString",
-	MismatchedMultiRetAssignment:   "MismatchedMultiRetAssignment",
-	MismatchedTypeInMultiRetAssign: "MismatchedTypeInMultiRetAssign",
-	CopyTooBig:                     "CopyTooBig",
-	InvalidCopy:                    "InvalidCopy",
-	MismatchedTypeInAssign:         "MismatchedTypeInAssign",
-	BadConst:                       "BadConst",
-	InvalidClassforExpr:            "InvalidClassforExpr",
-	CannotUseSyscallInExpr:         "CannotUseSyscallInExpr",
-	CannotUseVoid:                  "CannotUseVoid",
-	ExpectedBasicType:              "ExpectedBasicType",
-	CanOnlyUseNormalAssignment:     "CanOnlyUseNormalAssignment",
-	ExpectedNumber:                 "ExpectedNumber",
-	ExitMustBeI8:                   "ExitMustBeI8",
-	PtrCantBeUsedAsMemSize:         "PtrCantBeUsedAsMemSize",
-	InvalidProp:                    "InvalidProp",
-	NotAllCodePathsReturnAValue:    "NotAllCodePathsReturnAValue",
-	InvalidMain:                    "InvalidMain",
-	NoEntryPoint:                   "NoEntryPoint",
-	AmbiguousModuleName:            "AmbiguousModuleName",
-	ModuleNotFound:                 "ModuleNotFound",
-	NameNotExported:                "NameNotExported",
-}
-
-var ErrorCodeMap = map[ErrorKind]string{
-	/* internal (bad) errors */
-	InvalidErrType:        "E101",
-	InternalCompilerError: "E102",
-
-	/* resolver errors */
-	/* lexer errors */
-	InvalidUTF8Rune: "E103",
-	InvalidSymbol:   "E104",
-
-	/* parser errors */
-	ExpectedSymbol: "E105",
-	ExpectedProd:   "E106",
-	ExpectedEOF:    "E107",
-
-	/* semantic errors */
-	ExpectedName:                   "E001",
-	NameAlreadyDefined:             "E002",
-	OperationBetweenUnequalTypes:   "E003",
-	DuplicatedExport:               "E004",
-	ExportingUndefName:             "E005",
-	InvalidDependencyCycle:         "E006",
-	FileError:                      "E007",
-	ImportError:                    "E008",
-	InvalidFileName:                "E009",
-	ImportNameColision:             "E010",
-	FromImportingUnexportedName:    "E011",
-	InvalidInitForMemType:          "E012",
-	NameNotDefined:                 "E013",
-	CanOnlyDerefPointers:           "E014",
-	CanOnlyAssignLocal:             "E015",
-	NotAssignable:                  "E016",
-	InvalidType:                    "E017",
-	InvalidMemResTerm:              "E018",
-	ExpectedConst:                  "E019",
-	MismatchedTypeForArgument:      "E020",
-	InvalidNumberOfArgs:            "E021",
-	ExpectedProcedure:              "E022",
-	InvalidNumberOfReturns:         "E023",
-	MismatchedReturnType:           "E024",
-	ExpectedMem:                    "E025",
-	InvalidUseOfString:             "E026",
-	MismatchedMultiRetAssignment:   "E027",
-	MismatchedTypeInMultiRetAssign: "E028",
-	CopyTooBig:                     "E029",
-	InvalidCopy:                    "E030",
-	MismatchedTypeInAssign:         "E031",
-	BadConst:                       "E032",
-	InvalidClassforExpr:            "E033",
-	CannotUseSyscallInExpr:         "E034",
-	CannotUseVoid:                  "E035",
-	ExpectedBasicType:              "E036",
-	CanOnlyUseNormalAssignment:     "E037",
-	ExpectedNumber:                 "E038",
-	ExitMustBeI8:                   "E039",
-	PtrCantBeUsedAsMemSize:         "E040",
-	InvalidProp:                    "E041",
-	NotAllCodePathsReturnAValue:    "E042",
-	InvalidMain:                    "E043",
-	NoEntryPoint:                   "E044",
-	AmbiguousModuleName:            "E045",
-	ModuleNotFound:                 "E046",
-	NameNotExported:                "E047",
-}
diff --git a/core/hir/checker/checker.go b/core/hir/checker/checker.go
deleted file mode 100644
index 3127255..0000000
--- a/core/hir/checker/checker.go
+++ /dev/null
@@ -1,470 +0,0 @@
-package checker
-
-import (
-	. "mpc/core"
-	hir "mpc/core/hir"
-	hirc "mpc/core/hir/class"
-	FT "mpc/core/hir/flowkind"
-	IT "mpc/core/hir/instrkind"
-	T "mpc/core/types"
-	eu "mpc/core/util"
-
-	"strconv"
-	"strings"
-)
-
-func Check(P *hir.Program) *Error {
-	for _, sy := range P.Symbols {
-		if sy.Proc != nil && !sy.Builtin {
-			s := newState(P)
-			s.proc = sy.Proc
-			sy.Proc.ResetBlocks()
-			err := checkCode(s, sy.Proc.FirstBlock())
-			if err != nil {
-				return err
-			}
-			err = checkVisited(sy.Proc)
-			if err != nil {
-				return err
-			}
-		}
-	}
-	return nil
-}
-
-type state struct {
-	m    *hir.Program
-	proc *hir.Procedure
-	bb   *hir.BasicBlock
-}
-
-func newState(P *hir.Program) *state {
-	return &state{
-		m: P,
-	}
-}
-
-func checkVisited(proc *hir.Procedure) *Error {
-	notVisited := []string{}
-	for _, bb := range proc.AllBlocks {
-		if !bb.Visited {
-			notVisited = append(notVisited, bb.Label)
-		}
-	}
-	if len(notVisited) > 0 {
-		return eu.NewInternalSemanticError(proc.Label +
-			": not all blocks are reachable (" +
-			strings.Join(notVisited, ", ") + ")")
-	}
-	return nil
-}
-
-func checkCode(s *state, bb *hir.BasicBlock) *Error {
-	if bb.Visited {
-		return nil
-	}
-	s.bb = bb
-	for _, instr := range bb.Code {
-		err := checkInstr(s, instr)
-		if err != nil {
-			return err
-		}
-	}
-	bb.Visited = true
-	return checkJump(s)
-}
-
-func checkJump(s *state) *Error {
-	bb := s.bb
-	switch bb.Out.T {
-	case FT.Jmp:
-		t := s.proc.GetBlock(bb.Out.True)
-		return checkCode(s, t)
-	case FT.If:
-		t := s.proc.GetBlock(bb.Out.True)
-		err := checkCode(s, t)
-		if err != nil {
-			return err
-		}
-		f := s.proc.GetBlock(bb.Out.False)
-		return checkCode(s, f)
-	case FT.Return:
-		return checkRet(s, bb.Out.V)
-	case FT.Exit:
-		return checkExit(s, bb.Out)
-	}
-	return invalidFlow(bb.Out)
-}
-
-func checkRet(s *state, rets []*hir.Operand) *Error {
-	if len(s.proc.Rets) != len(rets) {
-		has := strconv.Itoa(len(rets))
-		wants := strconv.Itoa(len(s.proc.Rets))
-		return eu.NewInternalSemanticError("invalid number of returns: has " + has + " wanted " + wants)
-	}
-	for i, wanted_ret := range s.proc.Rets {
-		curr_ret := rets[i]
-		if !wanted_ret.Equals(curr_ret.Type) {
-			has := curr_ret.Type.String()
-			wants := wanted_ret.String()
-			return eu.NewInternalSemanticError("invalid return for procedure: has " + has + " wanted " + wants)
-		}
-	}
-	return nil
-}
-
-func checkExit(s *state, branch hir.Flow) *Error {
-	if branch.V == nil {
-		return eu.NewInternalSemanticError("invalid exit with zero operands")
-	}
-	if len(branch.V) != 1 {
-		return eu.NewInternalSemanticError("exit should have one operand")
-	}
-	if !branch.V[0].Type.Equals(T.T_I8) {
-		return eu.NewInternalSemanticError("exit operand must be I8")
-	}
-	return nil
-}
-
-type Checker struct {
-	Class func(hirc.Class) bool
-	Type  func(*T.Type) bool
-}
-
-func (c *Checker) Check(op *hir.Operand) bool {
-	return c.Type(op.Type) && c.Class(op.Class)
-}
-
-var basicOrProc_oper = Checker{
-	Class: hirc.IsOperable,
-	Type:  T.IsBasicOrProc,
-}
-
-var basicOrProc_res = Checker{
-	Class: hirc.IsResult,
-	Type:  T.IsBasicOrProc,
-}
-
-var basic_oper = Checker{
-	Class: hirc.IsOperable,
-	Type:  T.IsBasic,
-}
-
-var basic_res = Checker{
-	Class: hirc.IsResult,
-	Type:  T.IsBasic,
-}
-
-var num_oper = Checker{
-	Class: hirc.IsOperable,
-	Type:  T.IsNumber,
-}
-
-var num_res = Checker{
-	Class: hirc.IsResult,
-	Type:  T.IsNumber,
-}
-
-var bool_oper = Checker{
-	Class: hirc.IsOperable,
-	Type:  T.IsBool,
-}
-
-var bool_res = Checker{
-	Class: hirc.IsResult,
-	Type:  T.IsBool,
-}
-
-var ptr_oper = Checker{
-	Class: hirc.IsOperable,
-	Type:  T.IsPtr,
-}
-
-var ptr_res = Checker{
-	Class: hirc.IsResult,
-	Type:  T.IsPtr,
-}
-
-func checkInstr(s *state, instr *hir.Instr) *Error {
-	switch instr.T {
-	case IT.Add, IT.Sub, IT.Div, IT.Mult, IT.Rem:
-		return checkArith(instr)
-	case IT.Eq, IT.Diff, IT.Less, IT.More, IT.LessEq, IT.MoreEq:
-		return checkComp(instr)
-	case IT.Or, IT.And:
-		return checkLogical(instr)
-	case IT.Not:
-		return checkNot(instr)
-	case IT.Neg:
-		return checkUnaryArith(instr)
-	case IT.Convert:
-		return checkConvert(instr)
-	case IT.LoadPtr:
-		return checkLoadPtr(instr)
-	case IT.StorePtr:
-		return checkStorePtr(instr)
-	case IT.Store, IT.Load:
-		return invalidMirInstr(instr)
-	case IT.Copy:
-		return checkCopy(instr)
-	case IT.Call:
-		return checkCall(s, instr)
-	}
-	panic("sumthin' went wong")
-}
-
-func checkArith(instr *hir.Instr) *Error {
-	err := checkForm(instr, 2, true)
-	if err != nil {
-		return err
-	}
-	a := instr.Operands[0]
-	b := instr.Operands[1]
-	dest := instr.Destination[0]
-	err = checkEqual(instr, instr.Type, a.Type, b.Type, dest.Type)
-	if err != nil {
-		return err
-	}
-	return checkBinary(instr, num_oper, num_oper, num_res)
-}
-
-func checkComp(instr *hir.Instr) *Error {
-	err := checkForm(instr, 2, true)
-	if err != nil {
-		return err
-	}
-	a := instr.Operands[0]
-	b := instr.Operands[1]
-	err = checkEqual(instr, instr.Type, a.Type, b.Type)
-	if err != nil {
-		return err
-	}
-	return checkBinary(instr, basic_oper, basic_oper, bool_res)
-}
-
-func checkLogical(instr *hir.Instr) *Error {
-	err := checkForm(instr, 2, true)
-	if err != nil {
-		return err
-	}
-	a := instr.Operands[0]
-	b := instr.Operands[1]
-	dest := instr.Destination[0]
-	err = checkEqual(instr, instr.Type, a.Type, b.Type, dest.Type)
-	if err != nil {
-		return err
-	}
-	return checkBinary(instr, bool_oper, bool_oper, bool_res)
-}
-
-func checkUnaryArith(instr *hir.Instr) *Error {
-	err := checkForm(instr, 1, true)
-	if err != nil {
-		return err
-	}
-	a := instr.Operands[0]
-	dest := instr.Destination[0]
-	err = checkEqual(instr, instr.Type, a.Type, dest.Type)
-	if err != nil {
-		return err
-	}
-	return checkUnary(instr, num_oper, num_res)
-}
-
-func checkNot(instr *hir.Instr) *Error {
-	err := checkForm(instr, 1, true)
-	if err != nil {
-		return err
-	}
-	a := instr.Operands[0]
-	dest := instr.Destination[0]
-	err = checkEqual(instr, instr.Type, a.Type, dest.Type)
-	if err != nil {
-		return err
-	}
-	return checkUnary(instr, bool_oper, bool_res)
-}
-
-func checkConvert(instr *hir.Instr) *Error {
-	err := checkForm(instr, 1, true)
-	if err != nil {
-		return err
-	}
-	dest := instr.Destination[0]
-	err = checkEqual(instr, instr.Type, dest.Type)
-	if err != nil {
-		return err
-	}
-	return checkUnary(instr, basic_oper, basic_res)
-}
-
-func checkCopy(instr *hir.Instr) *Error {
-	err := checkForm(instr, 1, true)
-	if err != nil {
-		return err
-	}
-	a := instr.Operands[0]
-	dest := instr.Destination[0]
-	err = checkEqual(instr, instr.Type, a.Type, dest.Type)
-	if err != nil {
-		return err
-	}
-	err = checkUnary(instr, basicOrProc_oper, basicOrProc_res)
-	if err != nil {
-		return err
-	}
-
-	return nil
-}
-
-func checkLoadPtr(instr *hir.Instr) *Error {
-	err := checkForm(instr, 1, true)
-	if err != nil {
-		return err
-	}
-	dest := instr.Destination[0]
-	err = checkEqual(instr, instr.Type, dest.Type)
-	return checkUnary(instr, ptr_oper, basicOrProc_res)
-}
-
-func checkStorePtr(instr *hir.Instr) *Error {
-	err := checkForm(instr, 2, false)
-	if err != nil {
-		return err
-	}
-	a := instr.Operands[0]
-	dest := instr.Operands[1]
-	err = checkEqual(instr, instr.Type, a.Type)
-	if err != nil {
-		return err
-	}
-	if basicOrProc_oper.Check(a) && ptr_oper.Check(dest) {
-		return nil
-	}
-	return malformedTypeOrClass(instr)
-}
-
-func checkCall(s *state, instr *hir.Instr) *Error {
-	if len(instr.Operands) == 0 {
-		return malformedInstr(instr)
-	}
-	procOp := instr.Operands[0]
-	if !T.IsProc(procOp.Type) {
-		return expectedProc(instr, procOp)
-	}
-	proc := procOp.Type.Proc
-
-	if len(instr.Operands)-1 != len(proc.Args) {
-		return procInvalidNumOfArgs(instr, proc)
-	}
-	if len(instr.Destination) != len(proc.Rets) {
-		return procInvalidNumOfRets(instr, proc)
-	}
-
-	realArgs := instr.Operands[1:]
-
-	for i, formal_arg := range proc.Args {
-		real_arg := realArgs[i]
-		if !formal_arg.Equals(real_arg.Type) {
-			return procBadArg(instr, formal_arg, real_arg)
-		}
-	}
-
-	for i, formal_ret := range proc.Rets {
-		real_ret := instr.Destination[i]
-		if !formal_ret.Equals(real_ret.Type) {
-			return procBadRet(instr, formal_ret, real_ret)
-		}
-	}
-	return nil
-}
-
-func checkEqual(instr *hir.Instr, types ...*T.Type) *Error {
-	if len(types) == 0 {
-		return nil
-	}
-	first := types[0]
-	for _, t := range types[1:] {
-		if !first.Equals(t) {
-			return malformedEqualTypes(instr)
-		}
-	}
-	return nil
-}
-
-func checkBinary(instr *hir.Instr, checkA, checkB, checkC Checker) *Error {
-	a := instr.Operands[0]
-	b := instr.Operands[1]
-	dest := instr.Destination[0]
-
-	if checkA.Check(a) &&
-		checkB.Check(b) &&
-		checkC.Check(dest) {
-		return nil
-	}
-	return malformedTypeOrClass(instr)
-}
-
-func checkUnary(instr *hir.Instr, checkA, checkC Checker) *Error {
-	a := instr.Operands[0]
-	dest := instr.Destination[0]
-
-	if checkA.Check(a) &&
-		checkC.Check(dest) {
-		return nil
-	}
-	return malformedTypeOrClass(instr)
-}
-
-func checkForm(instr *hir.Instr, numOperands int, hasDest bool) *Error {
-	if len(instr.Operands) != numOperands {
-		return malformedInstr(instr)
-	}
-	for _, op := range instr.Operands {
-		if op == nil {
-			return malformedInstr(instr)
-		}
-	}
-	if hasDest && instr.Destination == nil {
-		return malformedInstr(instr)
-	}
-	return nil
-}
-
-func malformedInstr(instr *hir.Instr) *Error {
-	return eu.NewInternalSemanticError("malformed instruction: " + instr.String())
-}
-func malformedEqualTypes(instr *hir.Instr) *Error {
-	return eu.NewInternalSemanticError("unequal types: " + instr.String())
-}
-func malformedTypeOrClass(instr *hir.Instr) *Error {
-	return eu.NewInternalSemanticError("malformed type or class: " + instr.String())
-}
-func procArgNotFound(instr *hir.Instr, p *hir.Procedure) *Error {
-	return eu.NewInternalSemanticError("argument " + p.Label + " not found in: " + instr.String())
-}
-func procInvalidNumOfArgs(instr *hir.Instr, p *T.ProcType) *Error {
-	n := strconv.Itoa(len(p.Args))
-	beepBop := strconv.Itoa(len(instr.Operands) - 1)
-	return eu.NewInternalSemanticError("expected " + n + " arguments, instead found: " + beepBop)
-}
-func procInvalidNumOfRets(instr *hir.Instr, p *T.ProcType) *Error {
-	n := strconv.Itoa(len(p.Rets))
-	beepBop := strconv.Itoa(len(instr.Destination))
-	return eu.NewInternalSemanticError("expected " + n + " returns, instead found: " + beepBop)
-}
-func procBadArg(instr *hir.Instr, d *T.Type, op *hir.Operand) *Error {
-	return eu.NewInternalSemanticError("argument " + op.String() + " doesn't match formal parameter (" + d.String() + ") in: " + instr.String())
-}
-func procBadRet(instr *hir.Instr, d *T.Type, op *hir.Operand) *Error {
-	return eu.NewInternalSemanticError("return " + op.String() + " doesn't match formal return " + d.String() + " in: " + instr.String())
-}
-func invalidMirInstr(i *hir.Instr) *Error {
-	return eu.NewInternalSemanticError("invalid MIR Instr: " + i.String())
-}
-func invalidFlow(f hir.Flow) *Error {
-	return eu.NewInternalSemanticError("invalid flow: " + f.String())
-}
-func expectedProc(instr *hir.Instr, o *hir.Operand) *Error {
-	return eu.NewInternalSemanticError("expected procedure in: " + instr.String() + ", instead found: " + o.String())
-}
diff --git a/core/hir/class/class.go b/core/hir/class/class.go
deleted file mode 100644
index 0d2b0c5..0000000
--- a/core/hir/class/class.go
+++ /dev/null
@@ -1,43 +0,0 @@
-package class
-
-type Class int
-
-func (c Class) String() string {
-	switch c {
-	case Temp:
-		return "temp"
-	case Lit:
-		return "lit"
-	case Local:
-		return "local"
-	case Arg:
-		return "arg"
-	case Global:
-		return "global"
-	}
-	return "?"
-}
-
-const (
-	InvalidOpType Class = iota
-
-	Temp
-	Lit
-	Local
-	Arg
-	Global
-)
-
-func IsOperable(c Class) bool {
-	return c == Temp ||
-		c == Lit ||
-		c == Local ||
-		c == Arg ||
-		c == Global
-}
-
-func IsResult(c Class) bool {
-	return c == Temp ||
-		c == Local ||
-		c == Arg
-}
diff --git a/core/hir/flowkind/flowkind.go b/core/hir/flowkind/flowkind.go
deleted file mode 100644
index 289c189..0000000
--- a/core/hir/flowkind/flowkind.go
+++ /dev/null
@@ -1,26 +0,0 @@
-package flowkind
-
-type FlowKind int
-
-func (f FlowKind) String() string {
-	switch f {
-	case Jmp:
-		return "jmp"
-	case If:
-		return "if"
-	case Return:
-		return "ret"
-	case Exit:
-		return "exit"
-	}
-	return "invalid FlowKind"
-}
-
-const (
-	InvalidFlow FlowKind = iota
-
-	Jmp
-	If
-	Return
-	Exit
-)
diff --git a/core/hir/hir.go b/core/hir/hir.go
deleted file mode 100644
index d08a884..0000000
--- a/core/hir/hir.go
+++ /dev/null
@@ -1,335 +0,0 @@
-package hir
-
-import (
-	"fmt"
-	hirc "mpc/core/hir/class"
-	FT "mpc/core/hir/flowkind"
-	IT "mpc/core/hir/instrkind"
-	T "mpc/core/types"
-	"strconv"
-	"strings"
-)
-
-// index into Program.Symbols array
-type SymbolID int
-
-type Program struct {
-	Name    string
-	Entry   SymbolID
-	Symbols []*Symbol
-}
-
-func (this *Program) AddBuiltin(p *Procedure) int {
-	index := len(this.Symbols)
-	this.Symbols = append(this.Symbols, &Symbol{Proc: p, Builtin: true})
-	return index
-}
-
-func (this *Program) AddProc(p *Procedure) int {
-	index := len(this.Symbols)
-	this.Symbols = append(this.Symbols, &Symbol{Proc: p})
-	return index
-}
-
-func (this *Program) AddMem(m *MemoryDecl) int {
-	index := len(this.Symbols)
-	this.Symbols = append(this.Symbols, &Symbol{Mem: m})
-	return index
-}
-
-func (this *Program) String() string {
-	if this == nil {
-		return "nil program"
-	}
-	output := "Program: " + this.Name + "\n\n"
-	for _, sy := range this.Symbols {
-		output += sy.String() + "\n"
-	}
-	return output
-}
-
-func NewProgram() *Program {
-	return &Program{Symbols: []*Symbol{}}
-}
-
-type Symbol struct {
-	Proc    *Procedure
-	Mem     *MemoryDecl
-	Builtin bool
-}
-
-func (this *Symbol) String() string {
-	if this.Builtin {
-		return this.Proc.Label + ": " + "builtin"
-	}
-	if this.Proc != nil {
-		return this.Proc.String()
-	}
-	return this.Mem.String()
-}
-
-type MemoryDecl struct {
-	Label string
-	Data  string
-	Size  int64
-}
-
-func (this *MemoryDecl) String() string {
-	if this.Data != "" {
-		return this.Label + ": " + this.Data
-	}
-	return this.Label + ": " + strconv.FormatInt(this.Size, 10)
-}
-
-type Procedure struct {
-	Label string
-	Vars  []*T.Type
-	Args  []*T.Type
-	Rets  []*T.Type
-
-	Start     BlockID
-	AllBlocks []*BasicBlock
-}
-
-func (this *Procedure) FirstBlock() *BasicBlock {
-	return this.AllBlocks[this.Start]
-}
-
-func (this *Procedure) GetBlock(id BlockID) *BasicBlock {
-	return this.AllBlocks[id]
-}
-
-func (this *Procedure) ResetBlocks() {
-	for _, b := range this.AllBlocks {
-		b.Visited = false
-	}
-}
-
-func (p *Procedure) StrRets() string {
-	return StrTypes(p.Rets)
-}
-func (p *Procedure) StrArgs() string {
-	return StrTypes(p.Args)
-}
-func (p *Procedure) StrLocals() string {
-	return StrTypes(p.Vars)
-}
-
-func (this *Procedure) String() string {
-	output := this.Label + "{\n"
-	output += this.StrArgs() + "\n"
-	output += this.StrRets() + "\n"
-	output += this.StrLocals() + "\n"
-	output += "}:\n"
-	for _, bb := range this.AllBlocks {
-		output += bb.String() + "\n"
-	}
-	return output + "\n"
-}
-
-func StrTypes(tps []*T.Type) string {
-	if len(tps) == 0 {
-		return ""
-	}
-	if len(tps) == 1 {
-		return tps[0].String()
-	}
-	output := tps[0].String()
-	for _, t := range tps {
-		output += ", " + t.String()
-	}
-	return output
-}
-
-type BasicBlock struct {
-	Label   string
-	Code    []*Instr
-	Out     Flow
-	Visited bool
-}
-
-func (this *BasicBlock) AddInstr(i *Instr) {
-	this.Code = append(this.Code, i)
-}
-
-func (this *BasicBlock) Jmp(id BlockID) {
-	this.Out = Flow{
-		T:    FT.Jmp,
-		V:    nil,
-		True: id,
-	}
-}
-
-func (b *BasicBlock) Branch(cond *Operand, True BlockID, False BlockID) {
-	b.Out = Flow{
-		T:     FT.If,
-		V:     []*Operand{cond},
-		True:  True,
-		False: False,
-	}
-}
-
-func (b *BasicBlock) Return(rets []*Operand) {
-	b.Out = Flow{
-		V: rets,
-		T: FT.Return,
-	}
-}
-
-func (b *BasicBlock) Exit(code *Operand) {
-	b.Out = Flow{
-		V: []*Operand{code},
-		T: FT.Exit,
-	}
-}
-
-func (b *BasicBlock) HasFlow() bool {
-	return b.Out.T != FT.InvalidFlow
-}
-
-func (b *BasicBlock) IsTerminal() bool {
-	return b.Out.T == FT.Return || b.Out.T == FT.Exit
-}
-
-func (b *BasicBlock) String() string {
-	output := b.Label + ":\n"
-	for _, v := range b.Code {
-		output += "\t" + v.String() + "\n"
-	}
-	output += "\t" + b.Out.String()
-	return output
-}
-
-func ProperlyTerminates(proc *Procedure) bool {
-	start := proc.FirstBlock()
-	proc.ResetBlocks()
-	return properlyTerminates(proc, start)
-}
-
-func properlyTerminates(proc *Procedure, b *BasicBlock) bool {
-	if b.Visited {
-		// we just say that this looping branch doesn't matter
-		return true
-	}
-	b.Visited = true
-	switch b.Out.T {
-	case FT.If:
-		t := proc.GetBlock(b.Out.True)
-		f := proc.GetBlock(b.Out.False)
-		return properlyTerminates(proc, t) && properlyTerminates(proc, f)
-	case FT.Jmp:
-		t := proc.GetBlock(b.Out.True)
-		return properlyTerminates(proc, t)
-	case FT.Return, FT.Exit:
-		return true
-	}
-	return false
-}
-
-type BlockID int
-
-type Flow struct {
-	T     FT.FlowKind
-	V     []*Operand
-	True  BlockID
-	False BlockID
-}
-
-func (this *Flow) String() string {
-	switch this.T {
-	case FT.Jmp:
-		t := strconv.FormatInt(int64(this.True), 10)
-		return "jmp .L" + t
-	case FT.If:
-		t := strconv.FormatInt(int64(this.True), 10)
-		f := strconv.FormatInt(int64(this.False), 10)
-		return "if " + this.StrRets() + "? .L" + t + " : .L" + f
-	case FT.Return:
-		return "ret " + this.StrRets()
-	case FT.Exit:
-		return "exit " + this.StrRets()
-	}
-	return "invalid FlowType"
-}
-
-func (this *Flow) StrRets() string {
-	output := []string{}
-	for _, op := range this.V {
-		output = append(output, op.String())
-	}
-	return strings.Join(output, ", ")
-}
-
-type Operand struct {
-	Class hirc.Class
-	Type  *T.Type
-	Num   int64
-}
-
-func (this *Operand) String() string {
-	if this == nil {
-		return "nil"
-	}
-	value := strconv.FormatInt(this.Num, 10)
-	switch this.Class {
-	case hirc.Temp:
-		return "'" + value + ":" + this.Type.String()
-	case hirc.Local:
-		return "local#" + value + ":" + this.Type.String()
-	case hirc.Arg:
-		return "arg#" + value + ":" + this.Type.String()
-	case hirc.Global:
-		return "global#" + value + ":" + this.Type.String()
-	case hirc.Lit:
-		return value
-	}
-	return "?"
-}
-
-type Instr struct {
-	T           IT.InstrKind
-	Type        *T.Type
-	Operands    []*Operand
-	Destination []*Operand
-}
-
-func (this *Instr) String() string {
-	if this == nil {
-		return "nil"
-	}
-	if this.Destination != nil {
-		if this.Type != nil {
-			return fmt.Sprintf("%v:%v %v -> %v", this.T.String(), this.Type.String(), this.StrOps(), this.StrDests())
-		} else {
-			return fmt.Sprintf("%v, %v -> %v", this.T.String(), this.StrOps(), this.StrDests())
-		}
-	} else {
-		if this.Type != nil {
-			return fmt.Sprintf("%v:%v %v", this.T.String(), this.Type.String(), this.StrOps())
-		} else {
-			return fmt.Sprintf("%v, %v", this.T.String(), this.StrOps())
-		}
-	}
-}
-
-func (this *Instr) StrOps() string {
-	if len(this.Operands) == 0 {
-		return ""
-	}
-	output := this.Operands[0].String()
-	for _, v := range this.Operands[1:] {
-		output += ", " + v.String()
-	}
-	return output
-}
-
-func (this *Instr) StrDests() string {
-	if len(this.Destination) == 0 {
-		return ""
-	}
-	output := this.Destination[0].String()
-	for _, v := range this.Destination[1:] {
-		output += ", " + v.String()
-	}
-	return output
-}
diff --git a/core/hir/instrkind/instrkind.go b/core/hir/instrkind/instrkind.go
deleted file mode 100644
index 85b826e..0000000
--- a/core/hir/instrkind/instrkind.go
+++ /dev/null
@@ -1,91 +0,0 @@
-package instrkind
-
-import "strconv"
-
-type InstrKind int
-
-func (i InstrKind) String() string {
-	switch i {
-	case Add:
-		return "add"
-	case Sub:
-		return "sub"
-	case Neg:
-		return "uminus"
-	case Div:
-		return "div"
-	case Mult:
-		return "mult"
-	case Rem:
-		return "rem"
-	case Eq:
-		return "eq"
-	case Diff:
-		return "diff"
-	case Less:
-		return "less"
-	case More:
-		return "more"
-	case LessEq:
-		return "lesseq"
-	case MoreEq:
-		return "moreeq"
-	case Or:
-		return "or"
-	case And:
-		return "and"
-	case Not:
-		return "not"
-	case Convert:
-		return "convert"
-	case Load:
-		return "load"
-	case Store:
-		return "store"
-	case Copy:
-		return "copy"
-	case LoadPtr:
-		return "loadptr"
-	case StorePtr:
-		return "storeptr"
-	case Call:
-		return "call"
-	}
-	panic("Unstringified InstrType: " + strconv.Itoa(int(i)))
-}
-
-const (
-	InvalidInstr InstrKind = iota
-
-	Add
-	Sub
-	Div
-	Mult
-	Rem
-
-	Eq
-	Diff
-	Less
-	More
-	LessEq
-	MoreEq
-
-	Or
-	And
-
-	Not
-
-	Neg
-
-	Convert
-
-	LoadPtr
-	StorePtr
-
-	Load
-	Store
-
-	Copy
-
-	Call
-)
diff --git a/core/hir/util/util.go b/core/hir/util/util.go
deleted file mode 100644
index 19ee9dd..0000000
--- a/core/hir/util/util.go
+++ /dev/null
@@ -1,59 +0,0 @@
-package util
-
-import (
-	"mpc/core/hir"
-	IT "mpc/core/hir/instrkind"
-)
-
-func Load(source, destination *hir.Operand) *hir.Instr {
-	return &hir.Instr{
-		T:           IT.Load,
-		Type:        source.Type,
-		Operands:    []*hir.Operand{source},
-		Destination: []*hir.Operand{destination},
-	}
-}
-
-func Store(source, destination *hir.Operand) *hir.Instr {
-	return &hir.Instr{
-		T:           IT.Store,
-		Type:        source.Type,
-		Operands:    []*hir.Operand{source},
-		Destination: []*hir.Operand{destination},
-	}
-}
-
-func StorePtr(source, ptr *hir.Operand) *hir.Instr {
-	return &hir.Instr{
-		T:        IT.StorePtr,
-		Type:     source.Type,
-		Operands: []*hir.Operand{source, ptr},
-	}
-}
-
-func LoadPtr(ptr, dest *hir.Operand) *hir.Instr {
-	return &hir.Instr{
-		T:           IT.LoadPtr,
-		Type:        dest.Type,
-		Operands:    []*hir.Operand{ptr},
-		Destination: []*hir.Operand{dest},
-	}
-}
-
-func Convert(a, dest *hir.Operand) *hir.Instr {
-	return &hir.Instr{
-		T:           IT.Convert,
-		Type:        dest.Type,
-		Operands:    []*hir.Operand{a},
-		Destination: []*hir.Operand{dest},
-	}
-}
-
-func Copy(source, destination *hir.Operand) *hir.Instr {
-	return &hir.Instr{
-		T:           IT.Copy,
-		Type:        source.Type,
-		Operands:    []*hir.Operand{source},
-		Destination: []*hir.Operand{destination},
-	}
-}
diff --git a/core/mir/checker/checker.go b/core/mir/checker/checker.go
deleted file mode 100644
index e38a282..0000000
--- a/core/mir/checker/checker.go
+++ /dev/null
@@ -1,740 +0,0 @@
-package checker
-
-import (
-	. "mpc/core"
-	"mpc/core/mir"
-	mirc "mpc/core/mir/class"
-	FT "mpc/core/mir/flowkind"
-	IT "mpc/core/mir/instrkind"
-	T "mpc/core/types"
-	eu "mpc/core/util"
-
-	"strconv"
-	"strings"
-)
-
-func Check(P *mir.Program) *Error {
-	for _, sy := range P.Symbols {
-		if sy.Proc != nil && !sy.Builtin {
-			s := newState(P)
-			s.proc = sy.Proc
-			s.proc.ResetBlocks()
-			s.Init()
-			err := checkCode(s, sy.Proc.FirstBlock())
-			if err != nil {
-				return err
-			}
-		}
-	}
-	return nil
-}
-
-type region []*mir.Operand
-
-func newRegion(size int64) region {
-	return make(region, size)
-}
-
-func (r *region) String() string {
-	output := []string{}
-	for _, op := range *r {
-		output = append(output, op.String())
-	}
-	return strings.Join(output, ", ")
-}
-
-func (r *region) Store(i int64, op *mir.Operand) {
-	if i >= int64(len(*r)) {
-		*r = append(*r, newRegion(i-int64(len(*r)+1))...)
-	}
-	(*r)[i] = op
-}
-
-func (r *region) Load(i int64) *mir.Operand {
-	if i >= int64(len(*r)) {
-		return nil
-	}
-	return (*r)[i]
-}
-
-func (r region) Clear(i int) {
-	if i >= len(r) {
-		return
-	}
-	r[i] = nil
-}
-
-type state struct {
-	Program *mir.Program
-	proc    *mir.Procedure
-	bb      *mir.BasicBlock
-
-	CalleeInterproc region
-	CallerInterproc region
-	Spill           region
-	Registers       region
-	Locals          region
-}
-
-func newState(M *mir.Program) *state {
-	return &state{
-		Program:         M,
-		CalleeInterproc: newRegion(8),
-		CallerInterproc: newRegion(8),
-		Spill:           newRegion(8),
-		Registers:       newRegion(8),
-		Locals:          newRegion(8),
-	}
-}
-
-func (s *state) Init() {
-	for i, arg := range s.proc.Args {
-		argOp := newCallerOperand(arg, int64(i))
-		s.CallerInterproc.Store(int64(i), argOp)
-	}
-	for i, loc := range s.proc.Vars {
-		locOp := newCallerOperand(loc, int64(i))
-		s.Locals.Store(int64(i), locOp)
-	}
-}
-
-func (s *state) String() string {
-	return s.proc.Label + s.bb.Label + "\n" +
-		"callee: " + s.CalleeInterproc.String() + "\n" +
-		"caller: " + s.CallerInterproc.String() + "\n" +
-		"spill: " + s.Spill.String() + "\n" +
-		"registers: " + s.Registers.String() + "\n" +
-		"locals: " + s.Locals.String() + "\n"
-}
-
-func (s *state) Copy() *state {
-	caller := make(region, len(s.CallerInterproc))
-	callee := make(region, len(s.CalleeInterproc))
-	spill := make(region, len(s.Spill))
-	registers := make(region, len(s.Registers))
-	locals := make(region, len(s.Locals))
-	copy(caller, s.CallerInterproc)
-	copy(callee, s.CalleeInterproc)
-	copy(spill, s.Spill)
-	copy(registers, s.Registers)
-	copy(locals, s.Locals)
-	return &state{
-		CallerInterproc: caller,
-		CalleeInterproc: callee,
-		Spill:           spill,
-		Registers:       registers,
-		Locals:          locals,
-		bb:              s.bb,
-		Program:         s.Program,
-		proc:            s.proc,
-	}
-}
-
-func (s *state) SetReg(op *mir.Operand) {
-	if op.Class != mirc.Register {
-		panic("is not setting a register: " + op.String())
-	}
-	s.Registers.Store(op.Num, op)
-}
-
-func newCallerOperand(t *T.Type, i int64) *mir.Operand {
-	return &mir.Operand{
-		Class: mirc.CallerInterproc,
-		Num:   i,
-		Type:  t,
-	}
-}
-
-func newLocalOperand(t *T.Type, i int64) *mir.Operand {
-	return &mir.Operand{
-		Class: mirc.Local,
-		Num:   i,
-		Type:  t,
-	}
-}
-
-func checkCode(s *state, bb *mir.BasicBlock) *Error {
-	if bb.Visited {
-		return nil
-	}
-	s.bb = bb
-	for _, instr := range bb.Code {
-		err := checkInstr(s, instr)
-		if err != nil {
-			return err
-		}
-	}
-	bb.Visited = true
-	return checkJump(s)
-}
-
-func checkJump(s *state) *Error {
-	bb := s.bb
-	switch bb.Out.T {
-	case FT.Jmp:
-		t := s.proc.GetBlock(bb.Out.True)
-		return checkCode(s, t)
-	case FT.If:
-		s2 := s.Copy()
-		t := s.proc.GetBlock(bb.Out.True)
-		err := checkCode(s, t)
-		if err != nil {
-			return err
-		}
-		f := s.proc.GetBlock(bb.Out.False)
-		return checkCode(s2, f)
-	case FT.Return:
-		return checkRet(s)
-	}
-	return nil
-}
-
-func checkRet(s *state) *Error {
-	for i, ret := range s.proc.Rets {
-		op := s.CallerInterproc.Load(int64(i))
-		if op == nil {
-			return eu.NewInternalSemanticError("return stack is empty, expected returns: " + s.proc.StrRets())
-		}
-		if !ret.Equals(op.Type) {
-			return eu.NewInternalSemanticError("return of type " + ret.String() + " doesn't match value in stack: " + s.CallerInterproc.String())
-		}
-		s.CallerInterproc.Clear(i)
-	}
-	return nil
-}
-
-type Checker struct {
-	Class func(mirc.Class) bool
-	Type  func(*T.Type) bool
-}
-
-func (c *Checker) Check(op *mir.Operand) bool {
-	if op == nil {
-		panic("nil operand")
-	}
-	return c.Type(op.Type) && c.Class(op.Class)
-}
-
-var proc_imme = Checker{
-	Class: mirc.IsImmediate,
-	Type:  T.IsProc,
-}
-
-var basicOrProc_imme = Checker{
-	Class: mirc.IsImmediate,
-	Type:  T.IsBasicOrProc,
-}
-
-var basicOrProc_reg = Checker{
-	Class: mirc.IsRegister,
-	Type:  T.IsBasicOrProc,
-}
-
-var basicOrProc_addr = Checker{
-	Class: mirc.IsAddressable,
-	Type:  T.IsBasicOrProc,
-}
-
-var basic_imme = Checker{
-	Class: mirc.IsImmediate,
-	Type:  T.IsBasic,
-}
-
-var basic_reg = Checker{
-	Class: mirc.IsRegister,
-	Type:  T.IsBasic,
-}
-
-var basic_addr = Checker{
-	Class: mirc.IsAddressable,
-	Type:  T.IsBasic,
-}
-
-var num_imme = Checker{
-	Class: mirc.IsImmediate,
-	Type:  T.IsNumber,
-}
-
-var num_reg = Checker{
-	Class: mirc.IsRegister,
-	Type:  T.IsNumber,
-}
-
-var bool_imme = Checker{
-	Class: mirc.IsImmediate,
-	Type:  T.IsBool,
-}
-
-var bool_reg = Checker{
-	Class: mirc.IsRegister,
-	Type:  T.IsBool,
-}
-
-var ptr_imme = Checker{
-	Class: mirc.IsImmediate,
-	Type:  T.IsPtr,
-}
-
-var ptr_reg = Checker{
-	Class: mirc.IsRegister,
-	Type:  T.IsPtr,
-}
-
-func checkInstr(s *state, instr *mir.Instr) *Error {
-	if instr == nil {
-		return nilInstr(s)
-	}
-	err := checkInvalidClass(instr)
-	if err != nil {
-		return err
-	}
-	switch instr.T {
-	case IT.Add, IT.Sub, IT.Div, IT.Mult, IT.Rem:
-		return checkArith(s, instr)
-	case IT.Eq, IT.Diff, IT.Less, IT.More, IT.LessEq, IT.MoreEq:
-		return checkComp(s, instr)
-	case IT.Or, IT.And:
-		return checkLogical(s, instr)
-	case IT.Not:
-		return checkNot(s, instr)
-	case IT.Neg:
-		return checkUnaryArith(s, instr)
-	case IT.Convert:
-		return checkConvert(s, instr)
-	case IT.LoadPtr:
-		return checkLoadPtr(s, instr)
-	case IT.StorePtr:
-		return checkStorePtr(s, instr)
-	case IT.Store:
-		return checkStore(s, instr)
-	case IT.Load:
-		return checkLoad(s, instr)
-	case IT.Copy:
-		return checkCopy(s, instr)
-	case IT.Call:
-		return checkCall(s, instr)
-	}
-	panic("sumthin' went wong")
-}
-
-func checkArith(s *state, instr *mir.Instr) *Error {
-	err := checkForm(instr, true, true, true)
-	if err != nil {
-		return err
-	}
-
-	err = checkRegs(s, instr)
-	if err != nil {
-		return err
-	}
-	s.SetReg(instr.Dest)
-
-	err = checkEqual(instr, instr.Type, instr.A.Type, instr.B.Type, instr.Dest.Type)
-	if err != nil {
-		return err
-	}
-	return checkBinary(instr, num_imme, num_imme, num_reg)
-}
-
-func checkComp(s *state, instr *mir.Instr) *Error {
-	err := checkForm(instr, true, true, true)
-	if err != nil {
-		return err
-	}
-
-	err = checkRegs(s, instr)
-	if err != nil {
-		return err
-	}
-	s.SetReg(instr.Dest)
-
-	err = checkEqual(instr, instr.Type, instr.A.Type, instr.B.Type)
-	if err != nil {
-		return err
-	}
-	return checkBinary(instr, basic_imme, basic_imme, bool_reg)
-}
-
-func checkLogical(s *state, instr *mir.Instr) *Error {
-	err := checkForm(instr, true, true, true)
-	if err != nil {
-		return err
-	}
-
-	err = checkRegs(s, instr)
-	if err != nil {
-		return err
-	}
-	s.SetReg(instr.Dest)
-
-	err = checkEqual(instr, instr.Type, instr.A.Type, instr.B.Type, instr.Dest.Type)
-	if err != nil {
-		return err
-	}
-	return checkBinary(instr, bool_imme, bool_imme, bool_reg)
-}
-
-func checkUnaryArith(s *state, instr *mir.Instr) *Error {
-	err := checkForm(instr, true, false, true)
-	if err != nil {
-		return err
-	}
-
-	err = checkRegs(s, instr)
-	if err != nil {
-		return err
-	}
-	s.SetReg(instr.Dest)
-
-	err = checkEqual(instr, instr.Type, instr.A.Type, instr.Dest.Type)
-	if err != nil {
-		return err
-	}
-	return checkUnary(instr, num_imme, num_reg)
-}
-
-func checkNot(s *state, instr *mir.Instr) *Error {
-	err := checkForm(instr, true, false, true)
-	if err != nil {
-		return err
-	}
-
-	err = checkRegs(s, instr)
-	if err != nil {
-		return err
-	}
-	s.SetReg(instr.Dest)
-
-	err = checkEqual(instr, instr.Type, instr.A.Type, instr.Dest.Type)
-	if err != nil {
-		return err
-	}
-	return checkUnary(instr, bool_imme, bool_reg)
-}
-
-func checkConvert(s *state, instr *mir.Instr) *Error {
-	err := checkForm(instr, true, false, true)
-	if err != nil {
-		return err
-	}
-
-	err = checkRegs(s, instr)
-	if err != nil {
-		return err
-	}
-	s.SetReg(instr.Dest)
-
-	err = checkEqual(instr, instr.Type, instr.Dest.Type)
-	if err != nil {
-		return err
-	}
-	return checkUnary(instr, basic_imme, basic_reg)
-}
-
-func checkLoadPtr(s *state, instr *mir.Instr) *Error {
-	err := checkForm(instr, true, false, true)
-	if err != nil {
-		return err
-	}
-
-	err = checkRegs(s, instr)
-	if err != nil {
-		return err
-	}
-	s.SetReg(instr.Dest)
-
-	err = checkEqual(instr, instr.Type, instr.Dest.Type)
-	if err != nil {
-		return err
-	}
-	return checkUnary(instr, ptr_imme, basicOrProc_reg)
-}
-
-func checkStorePtr(s *state, instr *mir.Instr) *Error {
-	err := checkForm(instr, true, true, false)
-	if err != nil {
-		return err
-	}
-
-	err = checkRegs(s, instr)
-	if err != nil {
-		return err
-	}
-
-	err = checkEqual(instr, instr.Type, instr.A.Type)
-	if err != nil {
-		return err
-	}
-	if basicOrProc_imme.Check(instr.A) &&
-		ptr_imme.Check(instr.B) {
-		return nil
-	}
-	return malformedTypeOrClass(instr)
-}
-
-func checkLoad(s *state, instr *mir.Instr) *Error {
-	err := checkForm(instr, true, false, true)
-	if err != nil {
-		return err
-	}
-
-	s.SetReg(instr.Dest)
-
-	err = checkEqual(instr, instr.Type, instr.A.Type, instr.Dest.Type)
-	if err != nil {
-		return err
-	}
-	err = checkUnary(instr, basicOrProc_addr, basicOrProc_reg)
-	if err != nil {
-		return err
-	}
-
-	return checkLoadState(s, instr)
-}
-
-func checkStore(s *state, instr *mir.Instr) *Error {
-	err := checkForm(instr, true, false, true)
-	if err != nil {
-		return err
-	}
-
-	err = checkRegs(s, instr)
-	if err != nil {
-		return err
-	}
-
-	err = checkEqual(instr, instr.Type, instr.A.Type, instr.Dest.Type)
-	if err != nil {
-		return err
-	}
-	err = checkUnary(instr, basicOrProc_imme, basicOrProc_addr)
-	if err != nil {
-		return err
-	}
-
-	return checkStoreState(s, instr)
-}
-
-func checkCopy(s *state, instr *mir.Instr) *Error {
-	err := checkForm(instr, true, false, true)
-	if err != nil {
-		return err
-	}
-
-	err = checkRegs(s, instr)
-	if err != nil {
-		return err
-	}
-	s.SetReg(instr.Dest)
-
-	err = checkEqual(instr, instr.Type, instr.A.Type, instr.Dest.Type)
-	if err != nil {
-		return err
-	}
-	err = checkUnary(instr, basicOrProc_imme, basicOrProc_reg)
-	if err != nil {
-		return err
-	}
-
-	return nil
-}
-
-func checkCall(s *state, instr *mir.Instr) *Error {
-	err := checkForm(instr, true, false, false)
-	if err != nil {
-		return err
-	}
-	if !proc_imme.Check(instr.A) {
-		return malformedTypeOrClass(instr)
-	}
-
-	t := instr.A.Type
-
-	for i, formal_arg := range t.Proc.Args {
-		real_arg := s.CalleeInterproc.Load(int64(i))
-		if real_arg == nil {
-			return errorCallLoadingGarbage(instr)
-		}
-		if !formal_arg.Equals(real_arg.Type) {
-			return procBadArg(instr, formal_arg, real_arg)
-		}
-		s.CalleeInterproc.Clear(i)
-	}
-
-	for i, formal_ret := range t.Proc.Rets {
-		op := &mir.Operand{Class: mirc.CalleeInterproc, Num: int64(i), Type: formal_ret}
-		s.CalleeInterproc.Store(int64(i), op)
-	}
-	return nil
-}
-
-func checkLoadState(s *state, instr *mir.Instr) *Error {
-	var source *mir.Operand
-	switch instr.A.Class {
-	case mirc.Spill:
-		source = s.Spill.Load(instr.A.Num)
-	case mirc.CalleeInterproc:
-		source = s.CalleeInterproc.Load(instr.A.Num)
-	case mirc.CallerInterproc:
-		source = s.CallerInterproc.Load(instr.A.Num)
-	case mirc.Local:
-		source = s.Locals.Load(instr.A.Num)
-	default:
-		panic("oh no")
-	}
-	if source == nil {
-		return errorLoadingGarbage(instr)
-	}
-	err := checkEqual(instr, instr.Dest.Type, source.Type)
-	if err != nil {
-		return err
-	}
-	return nil
-}
-
-func checkStoreState(s *state, instr *mir.Instr) *Error {
-	switch instr.Dest.Class {
-	case mirc.Spill:
-		s.Spill.Store(instr.Dest.Num, instr.A)
-	case mirc.CalleeInterproc:
-		s.CalleeInterproc.Store(instr.Dest.Num, instr.A)
-	case mirc.CallerInterproc:
-		s.CallerInterproc.Store(instr.Dest.Num, instr.A)
-	case mirc.Local:
-		s.Locals.Store(instr.Dest.Num, instr.A)
-	default:
-		panic("oh no")
-	}
-	return nil
-}
-
-func checkRegs(s *state, instr *mir.Instr) *Error {
-	err := checkRegOperand(s, instr, instr.A)
-	if err != nil {
-		return err
-	}
-	err = checkRegOperand(s, instr, instr.B)
-	if err != nil {
-		return err
-	}
-	return nil
-}
-
-func checkRegOperand(s *state, instr *mir.Instr, op *mir.Operand) *Error {
-	if op == nil {
-		return nil
-	}
-	if op.Class == mirc.Register {
-		loaded := s.Registers.Load(op.Num)
-		if loaded == nil {
-			return errorUsingRegisterGarbage(instr, op)
-		}
-		if loaded.Num != op.Num || loaded.Class != op.Class || loaded.Type != op.Type {
-			return errorIncorrectValueInRegister(instr, loaded, op)
-		}
-	}
-	return nil
-}
-
-func checkEqual(instr *mir.Instr, types ...*T.Type) *Error {
-	if len(types) == 0 {
-		return nil
-	}
-	first := types[0]
-	for _, t := range types[1:] {
-		if !first.Equals(t) {
-			return malformedEqualTypes(instr)
-		}
-	}
-	return nil
-}
-
-func checkBinary(instr *mir.Instr, checkA, checkB, checkC Checker) *Error {
-	if checkA.Check(instr.A) &&
-		checkB.Check(instr.B) &&
-		checkC.Check(instr.Dest) {
-		return nil
-	}
-	return malformedTypeOrClass(instr)
-}
-
-func checkUnary(instr *mir.Instr, checkA, checkC Checker) *Error {
-	if checkA.Check(instr.A) &&
-		checkC.Check(instr.Dest) {
-		return nil
-	}
-	return malformedTypeOrClass(instr)
-}
-
-func checkInvalidClass(instr *mir.Instr) *Error {
-	if instr.A != nil && instr.A.Class == mirc.InvalidMIRClass {
-		return invalidClass(instr)
-	}
-	if instr.B != nil && instr.B.Class == mirc.InvalidMIRClass {
-		return invalidClass(instr)
-	}
-	if instr.Dest != nil && instr.Dest.Class == mirc.InvalidMIRClass {
-		return invalidClass(instr)
-	}
-	return nil
-}
-
-func checkForm(instr *mir.Instr, hasA, hasB, hasDest bool) *Error {
-	if hasA && instr.A == nil {
-		return malformedInstr(instr)
-	}
-	if hasB && instr.B == nil {
-		return malformedInstr(instr)
-	}
-	if hasDest && instr.Dest == nil {
-		return malformedInstr(instr)
-	}
-	return nil
-}
-
-func malformedInstr(instr *mir.Instr) *Error {
-	return eu.NewInternalSemanticError("malformed instruction: " + instr.String())
-}
-func malformedEqualTypes(instr *mir.Instr) *Error {
-	return eu.NewInternalSemanticError("unequal types: " + instr.String())
-}
-func malformedTypeOrClass(instr *mir.Instr) *Error {
-	return eu.NewInternalSemanticError("malformed type or class: " + instr.String())
-}
-func invalidClass(instr *mir.Instr) *Error {
-	return eu.NewInternalSemanticError("invalid class: " + instr.String())
-}
-func errorLoadingGarbage(instr *mir.Instr) *Error {
-	return eu.NewInternalSemanticError("loading garbage: " + instr.String())
-}
-func errorCallLoadingGarbage(instr *mir.Instr) *Error {
-	return eu.NewInternalSemanticError("call loading garbage: " + instr.String())
-}
-func errorUsingRegisterGarbage(instr *mir.Instr, op *mir.Operand) *Error {
-	return eu.NewInternalSemanticError("using register garbage: " + op.String() + " of " + instr.String())
-}
-func errorIncorrectValueInRegister(instr *mir.Instr, o, op *mir.Operand) *Error {
-	return eu.NewInternalSemanticError("incorrect value in register (" + o.String() + "): " + op.String() + " of " + instr.String())
-}
-func errorLoadingIncorrectType(instr *mir.Instr) *Error {
-	return eu.NewInternalSemanticError("load of incorrect type: " + instr.String())
-}
-func procArgNotFound(instr *mir.Instr, p *mir.Procedure) *Error {
-	return eu.NewInternalSemanticError("argument " + p.Label + " not found in: " + instr.String())
-}
-func procBadArg(instr *mir.Instr, d *T.Type, op *mir.Operand) *Error {
-	return eu.NewInternalSemanticError("argument " + op.String() + " doesn't match formal parameter (" + d.String() + ") in: " + instr.String())
-}
-func procBadRet(instr *mir.Instr, d T.Type, op *mir.Operand) *Error {
-	return eu.NewInternalSemanticError("return " + op.String() + " doesn't match formal return " + d.String() + " in: " + instr.String())
-}
-
-func nilInstr(s *state) *Error {
-	return eu.NewInternalSemanticError("nil instruction in: " + s.proc.Label + " " + s.bb.Label)
-}
-func notAProc(instr *mir.Instr) *Error {
-	return eu.NewInternalSemanticError("not a procedure: " + instr.String())
-}
-func symbolNotFound(i int64) *Error {
-	return eu.NewInternalSemanticError("Symbol not found in program: " + strconv.FormatInt(i, 10))
-}
diff --git a/core/mir/class/class.go b/core/mir/class/class.go
deleted file mode 100644
index 17c0500..0000000
--- a/core/mir/class/class.go
+++ /dev/null
@@ -1,33 +0,0 @@
-package class
-
-type Class int
-
-const (
-	InvalidMIRClass Class = iota
-
-	Register
-	Spill
-	CallerInterproc
-	CalleeInterproc
-	Local
-
-	Lit
-	Static
-)
-
-func IsImmediate(ot Class) bool {
-	return ot == Register ||
-		ot == Lit ||
-		ot == Static
-}
-
-func IsAddressable(ot Class) bool {
-	return ot == Spill ||
-		ot == CallerInterproc ||
-		ot == CalleeInterproc ||
-		ot == Local
-}
-
-func IsRegister(ot Class) bool {
-	return ot == Register
-}
diff --git a/core/mir/flowkind/flowkind.go b/core/mir/flowkind/flowkind.go
deleted file mode 100644
index 289c189..0000000
--- a/core/mir/flowkind/flowkind.go
+++ /dev/null
@@ -1,26 +0,0 @@
-package flowkind
-
-type FlowKind int
-
-func (f FlowKind) String() string {
-	switch f {
-	case Jmp:
-		return "jmp"
-	case If:
-		return "if"
-	case Return:
-		return "ret"
-	case Exit:
-		return "exit"
-	}
-	return "invalid FlowKind"
-}
-
-const (
-	InvalidFlow FlowKind = iota
-
-	Jmp
-	If
-	Return
-	Exit
-)
diff --git a/core/mir/instrkind/instrkind.go b/core/mir/instrkind/instrkind.go
deleted file mode 100644
index ec5c240..0000000
--- a/core/mir/instrkind/instrkind.go
+++ /dev/null
@@ -1,90 +0,0 @@
-package instrkind
-
-import "strconv"
-
-type InstrKind int
-
-func (i InstrKind) String() string {
-	switch i {
-	case Add:
-		return "add"
-	case Sub:
-		return "sub"
-	case Neg:
-		return "neg"
-	case Div:
-		return "div"
-	case Mult:
-		return "mult"
-	case Rem:
-		return "rem"
-	case Eq:
-		return "eq"
-	case Diff:
-		return "diff"
-	case Less:
-		return "less"
-	case More:
-		return "more"
-	case LessEq:
-		return "lesseq"
-	case MoreEq:
-		return "moreeq"
-	case Or:
-		return "or"
-	case And:
-		return "and"
-	case Not:
-		return "not"
-	case Convert:
-		return "convert"
-	case Load:
-		return "load"
-	case Store:
-		return "store"
-	case Copy:
-		return "copy"
-	case LoadPtr:
-		return "loadptr"
-	case StorePtr:
-		return "storeptr"
-	case Call:
-		return "call"
-	}
-	panic("Unstringified InstrType: " + strconv.Itoa(int(i)))
-}
-
-const (
-	InvalidInstr InstrKind = iota
-
-	Add
-	Sub
-	Div
-	Mult
-	Rem
-
-	Eq
-	Diff
-	Less
-	More
-	LessEq
-	MoreEq
-
-	Or
-	And
-
-	Not
-	Neg
-
-	Convert
-
-	LoadPtr
-	StorePtr
-
-	Load
-	Store
-
-	Copy
-
-	Call
-)
diff --git a/core/mir/mir.go b/core/mir/mir.go
deleted file mode 100644
index 1d02b12..0000000
--- a/core/mir/mir.go
+++ /dev/null
@@ -1,298 +0,0 @@
-package mir
-
-import (
-	mirc "mpc/core/mir/class"
-	FT "mpc/core/mir/flowkind"
-	IT "mpc/core/mir/instrkind"
-	T "mpc/core/types"
-	"strconv"
-	"strings"
-)
-
-// index into Program.Symbols array
-type SymbolID int
-
-type Program struct {
-	Name    string
-	Entry   SymbolID
-	Symbols []*Symbol
-}
-
-func (this *Program) FindSymbol(i SymbolID) *Symbol {
-	if i < 0 || int64(i) >= int64(len(this.Symbols)) {
-		return nil
-	}
-	return this.Symbols[i]
-}
-
-func (this *Program) AddProc(p *Procedure) int {
-	index := len(this.Symbols)
-	this.Symbols = append(this.Symbols, &Symbol{Proc: p})
-	return index
-}
-
-func (this *Program) AddMem(m *MemoryDecl) int {
-	index := len(this.Symbols)
-	this.Symbols = append(this.Symbols, &Symbol{Mem: m})
-	return index
-}
-
-func (this *Program) String() string {
-	if this == nil {
-		return "nil"
-	}
-	output := "Program: " + this.Name + "\n\n"
-	for i, sy := range this.Symbols {
-		output += "[" + strconv.FormatInt(int64(i), 10) + "]" + sy.String() + "\n"
-	}
-	return output
-}
-
-type Symbol struct {
-	Proc    *Procedure
-	Mem     *MemoryDecl
-	Builtin bool
-}
-
-func (this *Symbol) String() string {
-	if this.Builtin {
-		return this.Proc.Label + ": " + "builtin"
-	}
-	if this.Proc != nil {
-		return this.Proc.String()
-	}
-	return this.Mem.String()
-}
-
-type MemoryDecl struct {
-	Label string
-	Data  string
-	Size  int64
-}
-
-func (this *MemoryDecl) String() string {
-	if this.Data != "" {
-		return this.Label + ": " + this.Data
-	}
-	return this.Label + ": " + strconv.FormatInt(this.Size, 10)
-}
-
-type Procedure struct {
-	Label string
-	Vars  []*T.Type
-	Args  []*T.Type
-	Rets  []*T.Type
-
-	Start     BlockID
-	AllBlocks []*BasicBlock
-
-	NumOfVars               int
-	NumOfSpills             int
-	NumOfMaxCalleeArguments int
-}
-
-func (this *Procedure) String() string {
-	output := this.Label + "{\n"
-	output += this.StrArgs() + "\n"
-	output += this.StrRets() + "\n"
-	output += this.StrLocals() + "\n"
-	output += "}:\n"
-	for _, bb := range this.AllBlocks {
-		output += bb.String() + "\n"
-	}
-	return output + "\n"
-}
-
-func (p *Procedure) StrRets() string {
-	return StrTypes(p.Rets)
-}
-func (p *Procedure) StrArgs() string {
-	return StrTypes(p.Args)
-}
-func (p *Procedure) StrLocals() string {
-	return StrTypes(p.Vars)
-}
-
-func (this *Procedure) FirstBlock() *BasicBlock {
-	return this.AllBlocks[this.Start]
-}
-
-func (this *Procedure) GetBlock(id BlockID) *BasicBlock {
-	return this.AllBlocks[id]
-}
-
-func (this *Procedure) ResetBlocks() {
-	for _, b := range this.AllBlocks {
-		b.Visited = false
-	}
-}
-
-func StrTypes(tps []*T.Type) string {
-	if len(tps) == 0 {
-		return ""
-	}
-	if len(tps) == 1 {
-		return tps[0].String()
-	}
-	output := tps[0].String()
-	for _, t := range tps {
-		output += ", " + t.String()
-	}
-	return output
-}
-
-type BasicBlock struct {
-	Label   string
-	Code    []*Instr
-	Out     Flow
-	Visited bool
-}
-
-func (b *BasicBlock) AddInstr(i *Instr) {
-	b.Code = append(b.Code, i)
-}
-
-func (b *BasicBlock) Jmp(o BlockID) {
-	b.Out = Flow{
-		T:    FT.Jmp,
-		V:    nil,
-		True: o,
-	}
-}
-
-func (b *BasicBlock) Branch(cond *Operand, True BlockID, False BlockID) {
-	b.Out = Flow{
-		T:     FT.If,
-		V:     []*Operand{cond},
-		True:  True,
-		False: False,
-	}
-}
-
-func (b *BasicBlock) Return(rets []*Operand) {
-	b.Out = Flow{
-		V: rets,
-		T: FT.Return,
-	}
-}
-
-func (b *BasicBlock) Exit(code *Operand) {
-	b.Out = Flow{
-		V: []*Operand{code},
-		T: FT.Exit,
-	}
-}
-
-func (b *BasicBlock) HasFlow() bool {
-	return b.Out.T != FT.InvalidFlow
-}
-
-func (b *BasicBlock) IsTerminal() bool {
-	return b.Out.T == FT.Return || b.Out.T == FT.Exit
-}
-
-func (b *BasicBlock) String() string {
-	output := b.Label + ":\n"
-	for _, v := range b.Code {
-		output += "\t" + v.String() + "\n"
-	}
-	output += "\t" + b.Out.String()
-	return output
-}
-
-// index into Procedure.Blocks
-type BlockID int
-
-type Flow struct {
-	T     FT.FlowKind
-	V     []*Operand
-	True  BlockID
-	False BlockID
-}
-
-func (this *Flow) String() string {
-	switch this.T {
-	case FT.Jmp:
-		t := strconv.FormatInt(int64(this.True), 10)
-		return "jmp .L" + t // :)
-	case FT.If:
-		t := strconv.FormatInt(int64(this.True), 10)
-		f := strconv.FormatInt(int64(this.False), 10)
-		return "if " + this.StrRets() + "? .L" + t + " : .L" + f
-	case FT.Return:
-		return "ret " + this.StrRets()
-	case FT.Exit:
-		return "exit " + this.StrRets()
-	}
-	return "invalid FlowType"
-}
-
-func (f *Flow) StrRets() string {
-	output := []string{}
-	for _, op := range f.V {
-		output = append(output, op.String())
-	}
-	return strings.Join(output, ", ")
-}
-
-type Operand struct {
-	Class mirc.Class
-	Type  *T.Type
-	Num   int64
-}
-
-func (o *Operand) String() string {
-	if o == nil {
-		return "nil"
-	}
-	value := strconv.FormatInt(o.Num, 10)
-	switch o.Class {
-	case mirc.Lit:
-		return value
-	case mirc.Local:
-		return "local#" + value + ":" + o.Type.String()
-	case mirc.Spill:
-		return "spill#" + value + ":" + o.Type.String()
-	case mirc.Register:
-		return "r" + value + ":" + o.Type.String()
-	case mirc.Static:
-		return "globall#" + value + ":" + o.Type.String()
-	case mirc.CallerInterproc:
-		return "caller#" + value + ":" + o.Type.String()
-	case mirc.CalleeInterproc:
-		return "callee#" + value + ":" + o.Type.String()
-	}
-	return "?"
-}
-
-type Instr struct {
-	T    IT.InstrKind
-	Type *T.Type
-	A    *Operand
-	B    *Operand
-	Dest *Operand
-}
-
-func (this *Instr) String() string {
-	if this == nil {
-		return "nil"
-	}
-	output := this.T.String()
-	if this.Type != nil {
-		output += ":" + this.Type.String()
-	}
-	if this.A != nil {
-		output += " " + this.A.String()
-		if this.B != nil {
-			output += " " + this.B.String()
-		}
-	} else {
-		if this.B != nil {
-			output += " ???, " + this.B.String()
-		}
-	}
-	if this.Dest != nil {
-		output += " -> " + this.Dest.String()
-	}
-	return output
-}
diff --git a/core/mir/util/util.go b/core/mir/util/util.go
deleted file mode 100644
index 2a8e30a..0000000
--- a/core/mir/util/util.go
+++ /dev/null
@@ -1,60 +0,0 @@
-package util
-
-import (
-	"mpc/core/mir"
-	mik "mpc/core/mir/instrkind"
-)
-
-func Load(source, destination *mir.Operand) *mir.Instr {
-	return &mir.Instr{
-		T:    mik.Load,
-		Type: source.Type,
-		A:    source,
-		Dest: destination,
-	}
-}
-
-func Store(source, destination *mir.Operand) *mir.Instr {
-	return &mir.Instr{
-		T:    mik.Store,
-		Type: source.Type,
-		A:    source,
-		Dest: destination,
-	}
-}
-
-func StorePtr(source, ptr *mir.Operand) *mir.Instr {
-	return &mir.Instr{
-		T:    mik.StorePtr,
-		Type: source.Type,
-		A:    source,
-		B:    ptr,
-	}
-}
-
-func LoadPtr(ptr, dest *mir.Operand) *mir.Instr {
-	return &mir.Instr{
-		T:    mik.LoadPtr,
-		Type: dest.Type,
-		A:    ptr,
-		Dest: dest,
-	}
-}
-
-func Convert(a, dest *mir.Operand) *mir.Instr {
-	return &mir.Instr{
-		T:    mik.Convert,
-		Type: dest.Type,
-		A:    a,
-		Dest: dest,
-	}
-}
-
-func Copy(source, destination *mir.Operand) *mir.Instr {
-	return &mir.Instr{
-		T:    mik.Copy,
-		Type: source.Type,
-		A:    source,
-		Dest: destination,
-	}
-}
diff --git a/core/module/lexkind/lexkind.go b/core/module/lexkind/lexkind.go
deleted file mode 100644
index f0c463a..0000000
--- a/core/module/lexkind/lexkind.go
+++ /dev/null
@@ -1,295 +0,0 @@
-package lexkind
-
-import "strconv"
-
-type LexKind int
-
-const (
-	UNDEFINED LexKind = iota
-
-	IDENTIFIER
-	I64_LIT
-	I32_LIT
-	I16_LIT
-	I8_LIT
-	PTR_LIT
-	STRING_LIT
-	CHAR_LIT
-
-	// symbols
-	PLUS
-	MINUS
-	NEG
-	DIVISION
-	MULTIPLICATION
-	REMAINDER
-	PLUS_ASSIGN
-	MINUS_ASSIGN
-	DIVISION_ASSIGN
-	MULTIPLICATION_ASSIGN
-	REMAINDER_ASSIGN
-	AT
-	LESS
-	LESSEQ
-	EQUALS
-	MOREEQ
-	MORE
-	DIFFERENT
-	LEFTPAREN
-	RIGHTPAREN
-	LEFTBRACE
-	RIGHTBRACE
-	LEFTBRACKET
-	RIGHTBRACKET
-	COLON
-	DOUBLECOLON
-	ASSIGNMENT
-	COMMA
-	SEMICOLON
-	DOT
-
-	// keywords
-	VAR
-	TRUE
-	FALSE
-	OR
-	AND
-	NOT
-	IF
-	ELSE
-	ELSEIF
-	WHILE
-	RETURN
-	PROC
-	MEMORY
-	BEGIN
-	END
-	SET
-	EXIT
-	IMPORT
-	FROM
-	EXPORT
-
-	I8
-	I16
-	I32
-	I64
-	BOOL
-	PTR
-
-	// special
-	BLOCK
-	SYMBOLS
-	COUPLINGS
-	PROCDECLS
-	TYPELIST
-	IDLIST
-	TERMLIST
-	ARRAYACCESS
-	CALL
-	EXPRLIST
-	ELSEIFCHAIN
-
-	EOF
-)
-
-var tktostr = map[LexKind]string{
-	UNDEFINED: "\033[0;31m?\033[0m",
-
-	IDENTIFIER: "IDENTIFIER",
-	I64_LIT:    "INT_LIT",
-	I32_LIT:    "I32_LIT",
-	I16_LIT:    "I16_LIT",
-	I8_LIT:     "I8_LIT",
-	PTR_LIT:    "PTR_LIT",
-	STRING_LIT: "STRING_LIT",
-	CHAR_LIT:   "CHAR_LIT",
-
-	// symbols:
-	PLUS:                  "PLUS",
-	MINUS:                 "MINUS",
-	NEG:                   "NEG",
-	AT:                    "AT",
-	DIVISION:              "DIVISION",
-	MULTIPLICATION:        "MULTIPLICATION",
-	REMAINDER:             "REMAINDER",
-	PLUS_ASSIGN:           "PLUS_ASSIGN",
-	MINUS_ASSIGN:          "MINUS_ASSIGN",
-	DIVISION_ASSIGN:       "DIVISION_ASSIGN",
-	MULTIPLICATION_ASSIGN: "MULTIPLICATION_ASSIGN",
-	REMAINDER_ASSIGN:      "REMAINDER_ASSIGN",
-	LESS:                  "LESS",
-	LESSEQ:                "LESSEQ",
-	EQUALS:                "EQUALS",
-	MOREEQ:                "MOREEQ",
-	MORE:                  "MORE",
-	DIFFERENT:             "DIFFERENT",
-	LEFTPAREN:             "LEFTPAREN",
-	RIGHTPAREN:            "RIGHTPAREN",
-	LEFTBRACE:             "LEFTBRACES",
-	RIGHTBRACE:            "RIGHTBRACES",
-	LEFTBRACKET:           "LEFTBRACKETS",
-	RIGHTBRACKET:          "RIGHTBRACKETS",
-	COLON:                 "COLON",
-	DOUBLECOLON:           "DOUBLECOLON",
-	ASSIGNMENT:            "ASSIGNMENT",
-	COMMA:                 "COMMA",
-	DOT:                   "DOT",
-
-	// keyword: "keyword"
-	VAR:    "VARS",
-	TRUE:   "TRUE",
-	FALSE:  "FALSE",
-	AND:    "AND",
-	OR:     "OR",
-	NOT:    "NOT",
-	IF:     "IF",
-	ELSE:   "ELSE",
-	WHILE:  "WHILE",
-	RETURN: "RETURN",
-	ELSEIF: "ELSEIF",
-	PROC:   "PROC",
-	MEMORY: "MEMORY",
-	BEGIN:  "BEGIN",
-	END:    "END",
-	SET:    "SET",
-	EXIT:   "EXIT",
-	IMPORT: "IMPORT",
-	FROM:   "FROM",
-	EXPORT: "EXPORT",
-
-	I8:   "I8",
-	I16:  "I16",
-	I32:  "I32",
-	I64:  "I64",
-	BOOL: "BOOL",
-	PTR:  "PTR",
-
-	// special
-	BLOCK:       "BLOCK",
-	SYMBOLS:     "SYMBOLS",
-	PROCDECLS:   "PARAMS",
-	TYPELIST:    "TYPELIST",
-	IDLIST:      "IDLIST",
-	ARRAYACCESS: "ARRAYACCESS",
-	COUPLINGS:   "COUPLINGS",
-	CALL:        "CALL",
-	EXPRLIST:    "EXPRLIST",
-	ELSEIFCHAIN: "ELSEIFCHAIN",
-
-	EOF: "EOF",
-}
-
-func FmtNodeType(t LexKind) string {
-	v, ok := tktostr[t]
-	if ok {
-		return v
-	}
-	panic("unspecified nodeType" + strconv.Itoa(int(t)))
-}
-
-func FmtTypes(t ...LexKind) string {
-	out := tktostr[t[0]]
-	for _, t := range t[1:] {
-		out += "," + tktostr[t]
-	}
-	return out
-}
-
-var tktosrc = map[LexKind]string{
-	UNDEFINED:  "\033[0;31m?\033[0m",
-	I64_LIT:    "i64 literal",
-	I32_LIT:    "i32 literal",
-	I16_LIT:    "i16 literal",
-	I8_LIT:     "i8 literal",
-	PTR_LIT:    "pointer literal",
-	STRING_LIT: "string literal",
-	CHAR_LIT:   "char literal",
-	IDENTIFIER: "identifier",
-
-	PLUS:                  "+",
-	MINUS:                 "-",
-	NEG:                   "~",
-	AT:                    "@",
-	DIVISION:              "/",
-	MULTIPLICATION:        "*",
-	REMAINDER:             "%",
-	PLUS_ASSIGN:           "+=",
-	MINUS_ASSIGN:          "-=",
-	DIVISION_ASSIGN:       "/=",
-	MULTIPLICATION_ASSIGN: "*=",
-	REMAINDER_ASSIGN:      "%=",
-	LEFTPAREN:             "(",
-	RIGHTPAREN:            ")",
-	LEFTBRACE:             "{",
-	RIGHTBRACE:            "}",
-	LEFTBRACKET:           "[",
-	RIGHTBRACKET:          "]",
-	COLON:                 ":",
-	DOUBLECOLON:           "::",
-	COMMA:                 ",",
-	LESS:                  "<",
-	LESSEQ:                "<=",
-	EQUALS:                "==",
-	MOREEQ:                ">=",
-	MORE:                  ">",
-	DIFFERENT:             "!=",
-	ASSIGNMENT:            "=",
-	DOT:                   ".",
-
-	VAR:    "vars",
-	TRUE:   "true",
-	FALSE:  "false",
-	AND:    "and",
-	OR:     "or",
-	NOT:    "not",
-	IF:     "if",
-	ELSE:   "else",
-	WHILE:  "while",
-	RETURN: "return",
-	ELSEIF: "elseif",
-	PROC:   "proc",
-	MEMORY: "memory",
-	BEGIN:  "begin",
-	END:    "end",
-	SET:    "set",
-	I8:     "i8",
-	I16:    "i16",
-	I32:    "i32",
-	I64:    "i64",
-	PTR:    "ptr",
-	BOOL:   "bool",
-	EXIT:   "exit",
-	IMPORT: "import",
-	FROM:   "from",
-	EXPORT: "export",
-
-	BLOCK:       "block",
-	SYMBOLS:     "symbols",
-	PROCDECLS:   "parameters",
-	IDLIST:      "id list",
-	TYPELIST:    "type list",
-	ARRAYACCESS: "array access",
-	COUPLINGS:   "module coupling",
-	CALL:        "procedure call",
-	EXPRLIST:    "expression list",
-	ELSEIFCHAIN: "else if chain",
-
-	EOF: "EOF",
-}
-
-func fmtToUser(t LexKind) string {
-	v, ok := tktosrc[t]
-	if ok {
-		return v
-	}
-	panic("unspecified nodeType")
-}
-
-func FmtToUser(t ...LexKind) string {
-	out := "'" + fmtToUser(t[0]) + "'"
-	for _, t := range t[1:] {
-		out += ", '" + fmtToUser(t) + "'"
-	}
-	return out
-}
diff --git a/core/module/module.go b/core/module/module.go
deleted file mode 100644
index a330986..0000000
--- a/core/module/module.go
+++ /dev/null
@@ -1,206 +0,0 @@
-package module
-
-import (
-	lex "mpc/core/module/lexkind"
-	ST "mpc/core/module/symbolkind"
-	T "mpc/core/types"
-
-	"fmt"
-	"strings"
-)
-
-type Node struct {
-	Text   string
-	Lex    lex.LexKind
-	Leaves []*Node
-
-	T *T.Type
-
-	Value int64 // for literals
-
-	Line, Col int
-	Length    int
-}
-
-func (n *Node) String() string {
-	if n.Lex == lex.EOF {
-		return "EOF"
-	}
-	return n.Text
-}
-
-func FmtNode(n *Node) string {
-	return ast(n, 0)
-}
-
-func ast(n *Node, i int) string {
-	output := fmt.Sprintf("{%s, '%s':%s",
-		lex.FmtNodeType(n.Lex),
-		n.Text,
-		n.T.String(),
-	)
-	output += "}"
-	for _, kid := range n.Leaves {
-		if kid == nil {
-			output += indent(i) + "nil"
-			continue
-		}
-		output += indent(i) + ast(kid, i+1)
-	}
-	return output
-}
-
-func indent(n int) string {
-	output := "\n"
-	for i := -1; i < n-1; i++ {
-		output += "    "
-	}
-	output += "└─>"
-	return output
-}
-
-type Dependency struct {
-	M      *Module
-	Source *Node
-}
-
-type Module struct {
-	BasePath string
-	Name     string
-	FullPath string
-	Root     *Node
-
-	Globals      map[string]*Symbol
-	Dependencies map[string]*Dependency
-	Exported     map[string]*Symbol
-
-	Visited bool
-}
-
-func (M *Module) String() string {
-	if M == nil {
-		return "nil"
-	}
-	return fmt.Sprintf("%v{\nRoot:\n\t%v,\nSymbols: %v\n}", M.Name, ast(M.Root, 1), M.StrGlobals())
-}
-
-func (M *Module) StrGlobals() string {
-	output := []string{}
-	for _, sy := range M.Globals {
-		output = append(output, sy.Name)
-	}
-
-	return strings.Join(output, ", ")
-}
-
-func (M *Module) ResetVisited() {
-	if !M.Visited {
-		return
-	}
-	M.Visited = false
-	for _, dep := range M.Dependencies {
-		dep.M.ResetVisited()
-	}
-}
-
-func (M *Module) GetSymbol(name string) *Symbol {
-	sy, ok := M.Globals[name]
-	if !ok {
-		return nil
-	}
-	if sy.External {
-		dep, ok := M.Dependencies[sy.ModuleName]
-		if !ok {
-			panic("use of unknown dependency")
-		}
-		sy, ok := dep.M.Exported[name]
-		if !ok {
-			panic("use of non-exported name")
-		}
-		return sy
-	}
-	return sy
-}
-
-type Symbol struct {
-	T        ST.SymbolKind
-	Name     string
-	N        *Node
-	External bool
-
-	Type       *T.Type
-	Proc       *Proc
-	Mem        *Mem
-	ModuleName string
-}
-
-func (v *Symbol) String() string {
-	switch v.T {
-	case ST.Proc:
-		return "proc " + v.Name
-	case ST.Var:
-		return "var " + v.Name + ":" + v.Type.String()
-	case ST.Arg:
-		return "arg " + v.Name + ":" + v.Type.String()
-	case ST.Mem:
-		return "mem " + v.Name
-	case ST.Module:
-		return "module " + v.Name
-	case ST.Builtin:
-		return "builtin " + v.Name
-	default:
-		return "invalid"
-	}
-}
-
-type PositionalSymbol struct {
-	Position int
-	Symbol   *Symbol
-}
-
-type Proc struct {
-	Name   string
-	ArgMap map[string]PositionalSymbol
-	Vars   map[string]PositionalSymbol
-	Args   []*Symbol
-	Rets   []*T.Type
-	T      *T.Type
-
-	N *Node
-}
-
-func (p *Proc) StrArgs() string {
-	output := []string{}
-	for _, decl := range p.ArgMap {
-		output = append(output, decl.Symbol.String())
-	}
-	return strings.Join(output, ", ")
-}
-
-func (p *Proc) StrVars() string {
-	output := []string{}
-	for _, decl := range p.Vars {
-		output = append(output, decl.Symbol.String())
-	}
-	return strings.Join(output, ", ")
-}
-
-func (p *Proc) StrRets() string {
-	output := []string{}
-	for _, ret := range p.Rets {
-		output = append(output, ret.String())
-	}
-	return strings.Join(output, ", ")
-}
-
-func (p *Proc) DoesReturnSomething() bool {
-	return len(p.Rets) > 0
-}
-
-type Mem struct {
-	Name     string
-	Size     int64
-	Contents string
-	Type     T.Type
-	Init     *Node
-}
diff --git a/core/module/symbolkind/symbolkind.go b/core/module/symbolkind/symbolkind.go
deleted file mode 100644
index cad2342..0000000
--- a/core/module/symbolkind/symbolkind.go
+++ /dev/null
@@ -1,30 +0,0 @@
-package symbolkind
-
-type SymbolKind int
-
-func (s SymbolKind) String() string {
-	switch s {
-	case Proc:
-		return "proc"
-	case Mem:
-		return "mem"
-	case Var:
-		return "Var"
-	case Arg:
-		return "Arg"
-	case Module:
-		return "Module"
-	}
-	return "??"
-}
-
-const (
-	Invalid SymbolKind = iota
-
-	Proc
-	Builtin
-	Mem
-	Var
-	Arg
-	Module
-)
diff --git a/core/module/util/util.go b/core/module/util/util.go
deleted file mode 100644
index 96615c7..0000000
--- a/core/module/util/util.go
+++ /dev/null
@@ -1,284 +0,0 @@
-package util
-
-import (
-	"fmt"
-	. "mpc/core"
-	et "mpc/core/errorkind"
-	mod "mpc/core/module"
-	T "mpc/core/module/lexkind"
-	. "mpc/frontend/lexer"
-)
-
-func Track(st *Lexer, s string) {
-	if IsTracking {
-		fmt.Printf("%v: %v\n", s, st.Word.String())
-	}
-}
-
-func NewCompilerError(st *Lexer, t et.ErrorKind, message string) *Error {
-	loc := GetSourceLocation(st)
-	return &Error{
-		Type: t,
-		Info: []Excerpt{
-			{
-				Location: &loc,
-				Message:  message,
-			},
-		},
-	}
-}
-
-func AllTokens(s *Lexer) []*mod.Node {
-	output := []*mod.Node{}
-	for s.Word.Lex != T.EOF {
-		output = append(output, s.Word)
-		Next(s)
-	}
-	return output
-}
-
-func Consume(st *Lexer) (*mod.Node, *Error) {
-	n := st.Word
-	err := Next(st)
-	return n, err
-}
-
-func AddLeaf(a *mod.Node, b *mod.Node) {
-	a.Leaves = append(a.Leaves, b)
-}
-
-func Check(st *Lexer, tpList ...T.LexKind) *Error {
-	for _, tp := range tpList {
-		if st.Word.Lex == tp {
-			return nil
-		}
-	}
-	message := fmt.Sprintf("Expected one of %v: instead found '%v'",
-		T.FmtToUser(tpList...),
-		st.Word.String())
-
-	err := NewCompilerError(st, et.ExpectedSymbol, message)
-
-	err.Debug = fmt.Sprintf("found: %v, wanted: %v",
-		T.FmtTypes(tpList...),
-		T.FmtTypes(st.Word.Lex))
-	return err
-}
-
-func Expect(st *Lexer, tpList ...T.LexKind) (*mod.Node, *Error) {
-	for _, tp := range tpList {
-		if st.Word.Lex == tp {
-			return Consume(st)
-		}
-	}
-	message := fmt.Sprintf("Expected one of %v: instead found '%v'",
-		T.FmtToUser(tpList...),
-		st.Word.String())
-
-	err := NewCompilerError(st, et.ExpectedSymbol, message)
-
-	err.Debug = fmt.Sprintf("found: %v, wanted: %v",
-		T.FmtTypes(tpList...),
-		T.FmtTypes(st.Word.Lex))
-	return nil, err
-}
-
-func ExpectProd(st *Lexer, prod Production, name string) (*mod.Node, *Error) {
-	n, err := prod(st)
-	if err != nil {
-		return nil, err
-	}
-	if n == nil {
-		message := fmt.Sprintf("expected %v instead found %v", name, st.Word.String())
-		err := NewCompilerError(st, et.ExpectedProd, message)
-		return nil, err
-	}
-	return n, err
-}
-
-type Production func(st *Lexer) (*mod.Node, *Error)
-type Validator func(*mod.Node) bool
-
-/* RepeatBinary implements the following pattern
-for a given Production and Terminal:
-
-	RepeatBinary := Production {Terminal Production}
-
-Validator checks for terminals.
-Left to Right precedence
-*/
-func RepeatBinary(st *Lexer, prod Production, name string, v Validator) (*mod.Node, *Error) {
-	last, err := prod(st)
-	if err != nil {
-		return nil, err
-	}
-	if last == nil {
-		return nil, nil
-	}
-	for v(st.Word) {
-		parent, err := Consume(st)
-		if err != nil {
-			return nil, err
-		}
-		AddLeaf(parent, last)
-
-		newLeaf, err := ExpectProd(st, prod, name)
-		if err != nil {
-			return nil, err
-		}
-		AddLeaf(parent, newLeaf)
-
-		last = parent
-	}
-	return last, nil
-}
-
-/* Repeat implements the following pattern
-for a given Production:
-
-	Repeat := {Production}.
-*/
-func Repeat(st *Lexer, prod Production) ([]*mod.Node, *Error) {
-	out := []*mod.Node{}
-	n, err := prod(st)
-	if err != nil {
-		return nil, err
-	}
-	if n == nil {
-		return nil, nil
-	}
-	for n != nil {
-		out = append(out, n)
-		n, err = prod(st)
-		if err != nil {
-			return nil, err
-		}
-	}
-	return out, nil
-}
-
-/*RepeatUnaryLeft implements the following pattern
-for a given Production:
-
-	RepeatUnaryLeft := {Production}.
-
-But returns the first and last item in the tree.
-
-It's Left associative: first<-second<-last
-*/
-func RepeatUnaryLeft(st *Lexer, prod Production) (*mod.Node, *mod.Node, *Error) {
-	first, err := prod(st)
-	if err != nil {
-		return nil, nil, err
-	}
-	if first == nil {
-		return nil, nil, nil
-	}
-	last := first
-	for first != nil {
-		n, err := prod(st)
-		if err != nil {
-			return nil, nil, err
-		}
-		if n == nil {
-			break
-		}
-		AddLeaf(last, n)
-		last = n
-	}
-	return first, last, nil
-}
-
-func RepeatUnaryRight(st *Lexer, prod Production) (*mod.Node, *mod.Node, *Error) {
-	first, err := prod(st)
-	if err != nil {
-		return nil, nil, err
-	}
-	if first == nil {
-		return nil, nil, nil
-	}
-	last := first
-	for first != nil {
-		n, err := prod(st)
-		if err != nil {
-			return nil, nil, err
-		}
-		if n == nil {
-			break
-		}
-		AddLeaf(n, last)
-		last = n
-	}
-	return first, last, nil
-}
-
-/* RepeatList implements the following pattern
-for a given Production and Terminal:
-
-	RepeatBinary := Production {Terminal Production}
-
-Validator checks for terminals.
-
-It differs from RepeatBinary in that it returns a slice
-instead of a Tree with precedence
-*/
-func RepeatList(st *Lexer, prod Production, val Validator) ([]*mod.Node, *Error) {
-	first, err := prod(st)
-	if err != nil {
-		return nil, err
-	}
-	if first == nil {
-		return nil, nil
-	}
-	out := []*mod.Node{first}
-	for val(st.Word) {
-		Next(st)
-		n, err := prod(st)
-		if err != nil {
-			return nil, err
-		}
-		out = append(out, n)
-	}
-	return out, nil
-}
-
-// Implements the pattern:
-//    RepeatBinary := Production {',' Production} [','].
-func RepeatCommaList(st *Lexer, prod Production) ([]*mod.Node, *Error) {
-	first, err := prod(st)
-	if err != nil {
-		return nil, err
-	}
-	if first == nil {
-		return nil, nil
-	}
-	out := []*mod.Node{first}
-	for st.Word.Lex == T.COMMA {
-		Next(st)
-		n, err := prod(st)
-		if err != nil {
-			return nil, err
-		}
-		if n != nil {
-			out = append(out, n)
-		}
-	}
-	if st.Word.Lex == T.COMMA {
-		err := Next(st)
-		if err != nil {
-			return nil, err
-		}
-	}
-	return out, nil
-}
-
-func CreateNode(nodes []*mod.Node, t T.LexKind) *mod.Node {
-	return &mod.Node{
-		Lex:    t,
-		Leaves: nodes,
-	}
-}
-
-func ExpectedEOF(s *Lexer) *Error {
-	return NewCompilerError(s, et.ExpectedEOF, "unexpected symbol")
-}
diff --git a/core/types/types.go b/core/types/types.go
deleted file mode 100644
index 37bf091..0000000
--- a/core/types/types.go
+++ /dev/null
@@ -1,197 +0,0 @@
-package Type
-
-import "strings"
-
-type Type struct {
-	Basic   BasicType
-	Special SpecialType
-	Proc    *ProcType
-}
-
-func (t *Type) String() string {
-	if t == nil {
-		return "nil"
-	}
-	switch t.Basic {
-	case I8:
-		return "i8"
-	case I16:
-		return "i16"
-	case I32:
-		return "i32"
-	case I64:
-		return "i64"
-	case Bool:
-		return "bool"
-	case Ptr:
-		return "ptr"
-	}
-	switch t.Special {
-	case MultiRet:
-		return "MultiRet"
-	case Void:
-		return "Void"
-	}
-	if t.Proc != nil {
-		return t.Proc.String()
-	}
-	return "invalid type"
-}
-
-func (this *Type) Equals(other *Type) bool {
-	if IsBasic(this) && IsBasic(other) {
-		return this.Basic == other.Basic
-	}
-	// one is basic and the other is not
-	if IsBasic(this) || IsBasic(other) {
-		return false
-	}
-	if this.Proc != nil && other.Proc != nil {
-		return this.Proc.Equals(other.Proc)
-	}
-	panic("cannot compare " + this.String() + " with " + other.String())
-}
-
-// returns the size of this type in bytes
-// panics if the type is special
-func (this *Type) Size() int {
-	if IsBasic(this) {
-		switch this.Basic {
-		case Bool:
-			return 1
-		case I8:
-			return 1
-		case I16:
-			return 2
-		case I32:
-			return 4
-		case I64:
-			return 8
-		case Ptr:
-			return 8
-		}
-	}
-	if IsProc(this) {
-		return 8
-	}
-	panic("unsizeable type")
-}
-
-type ProcType struct {
-	Args []*Type
-	Rets []*Type
-}
-
-func (this *ProcType) String() string {
-	output := "proc["
-	decls := []string{}
-	for _, t := range this.Args {
-		decls = append(decls, t.String())
-	}
-	output += strings.Join(decls, ", ") + "]["
-	decls = []string{}
-	for _, t := range this.Rets {
-		decls = append(decls, t.String())
-	}
-	output += strings.Join(decls, ", ") + "]"
-	return output
-}
-
-func (this *ProcType) Equals(other *ProcType) bool {
-	if len(this.Args) != len(other.Args) ||
-		len(this.Rets) != len(other.Rets) {
-		return false
-	}
-	for i := range this.Args {
-		if !this.Args[i].Equals(other.Args[i]) {
-			return false
-		}
-	}
-	for i := range this.Rets {
-		if !this.Rets[i].Equals(other.Rets[i]) {
-			return false
-		}
-	}
-	return true
-}
-
-var T_I64 = &Type{Basic: I64}
-var T_I32 = &Type{Basic: I32}
-var T_I16 = &Type{Basic: I16}
-var T_I8 = &Type{Basic: I8}
-var T_Bool = &Type{Basic: Bool}
-var T_Ptr = &Type{Basic: Ptr}
-var T_Void = &Type{Special: Void}
-var T_MultiRet = &Type{Special: MultiRet}
-var T_MainProc = &Type{Proc: &ProcType{Args: []*Type{}, Rets: []*Type{}}}
-
-type BasicType int
-
-const (
-	InvalidBasicType BasicType = iota
-
-	Bool
-	I8
-	I16
-	I32
-	I64
-	Ptr
-)
-
-type SpecialType int
-
-const (
-	InvalidSpecialType SpecialType = iota
-
-	MultiRet
-	Void
-)
-
-func IsInvalid(t *Type) bool {
-	if t == nil {
-		return false
-	}
-	return t.Special == InvalidSpecialType &&
-		t.Basic == InvalidBasicType &&
-		t.Proc == nil
-}
-
-func IsVoid(tt *Type) bool {
-	return tt.Special == Void
-}
-
-func IsMultiRet(tt *Type) bool {
-	return tt.Special == MultiRet
-}
-
-func IsBasic(tt *Type) bool {
-	return tt.Basic != InvalidBasicType
-}
-
-func IsProc(tt *Type) bool {
-	return tt.Proc != nil
-}
-
-func IsBasicOrProc(tt *Type) bool {
-	return IsBasic(tt) || IsProc(tt)
-}
-
-func IsBool(t *Type) bool {
-	return IsBasic(t) && t.Basic == Bool
-}
-
-func IsNumber(t *Type) bool {
-	if !IsBasic(t) {
-		return false
-	}
-	b := t.Basic
-	return b == I8 ||
-		b == I16 ||
-		b == I32 ||
-		b == I64 ||
-		b == Ptr
-}
-
-func IsPtr(t *Type) bool {
-	return IsBasic(t) && t.Basic == Ptr
-}
diff --git a/core/util/util.go b/core/util/util.go
deleted file mode 100644
index 0bde8eb..0000000
--- a/core/util/util.go
+++ /dev/null
@@ -1,54 +0,0 @@
-package util
-
-import (
-	. "mpc/core"
-	et "mpc/core/errorkind"
-	ir "mpc/core/module"
-)
-
-func Place(M *ir.Module, n *ir.Node) SourceLocation {
-	return SourceLocation{
-		File: M.FullPath,
-		Line: n.Line,
-		Col:  n.Col,
-	}
-}
-
-type NodeInfo struct {
-	N       *ir.Node
-	Message string
-}
-
-func NewNodeInfo(n *ir.Node, m string) *NodeInfo {
-	return &NodeInfo{
-		N:       n,
-		Message: m,
-	}
-}
-
-func NewInternalSemanticError(debug string) *Error {
-	return newInternalError(debug)
-}
-
-func newInternalError(debug string) *Error {
-	return &Error{
-		Type:  et.InternalCompilerError,
-		Debug: debug,
-		Info:  nil,
-	}
-}
-
-func NewSemanticError(M *ir.Module, t et.ErrorKind, n ...*NodeInfo) *Error {
-	excerpts := []Excerpt{}
-	for _, v := range n {
-		loc := Place(M, v.N)
-		excerpts = append(excerpts, Excerpt{
-			Location: &loc,
-			Message:  v.Message,
-		})
-	}
-	return &Error{
-		Type: t,
-		Info: excerpts,
-	}
-}
diff --git a/frontend/frontend.go b/frontend/frontend.go
deleted file mode 100644
index 33b3d89..0000000
--- a/frontend/frontend.go
+++ /dev/null
@@ -1,86 +0,0 @@
-package frontend
-
-import (
-	"io/ioutil"
-	. "mpc/core"
-	et "mpc/core/errorkind"
-	hir "mpc/core/hir"
-	hirchecker "mpc/core/hir/checker"
-	ir "mpc/core/module"
-	gen "mpc/frontend/gen"
-	lexer "mpc/frontend/lexer"
-	nameresolution "mpc/frontend/nameresolution"
-	parser "mpc/frontend/parser"
-	resolver "mpc/frontend/resolver"
-	typechecker "mpc/frontend/typechecker"
-)
-
-func Lex(file string) ([]*ir.Node, *Error) {
-	s, err := getFile(file)
-	if err != nil {
-		return nil, err
-	}
-	st := lexer.NewLexer(s)
-	return lexer.ReadAll(st)
-}
-
-func Parse(file string) (*ir.Node, *Error) {
-	s, err := getFile(file)
-	if err != nil {
-		return nil, err
-	}
-	return parser.Parse(s)
-}
-
-func All(file string) (*hir.Program, *Error) {
-	m, err := resolver.Resolve(file)
-	if err != nil {
-		return nil, err
-	}
-	p, err := module(m)
-	if err != nil {
-		return nil, err
-	}
-
-	err = hirchecker.Check(p)
-	if err != nil {
-		return nil, err
-	}
-	return p, nil
-}
-
-func getFile(file string) (string, *Error) {
-	text, e := ioutil.ReadFile(file)
-	if e != nil {
-		return "", processFileError(e)
-	}
-	return string(text), nil
-}
-
-func processFileError(e error) *Error {
-	return &Error{
-		Type:  et.FileError,
-		Debug: e.Error(),
-	}
-}
-
-func module(M *ir.Module) (*hir.Program, *Error) {
-	var err *Error
-
-	err = nameresolution.ResolveNames(M)
-	if err != nil {
-		return nil, err
-	}
-
-	err = typechecker.Check(M)
-	if err != nil {
-		return nil, err
-	}
-
-	p, err := gen.Generate(M)
-	if err != nil {
-		return nil, err
-	}
-
-	return p, nil
-}
diff --git a/frontend/gen/gen.go b/frontend/gen/gen.go
deleted file mode 100644
index 32b2e08..0000000
--- a/frontend/gen/gen.go
+++ /dev/null
@@ -1,712 +0,0 @@
-package gen
-
-import (
-	. "mpc/core"
-	hir "mpc/core/hir"
-	hirc "mpc/core/hir/class"
-	IT "mpc/core/hir/instrkind"
-	RIU "mpc/core/hir/util"
-	ir "mpc/core/module"
-	lex "mpc/core/module/lexkind"
-	ST "mpc/core/module/symbolkind"
-	T "mpc/core/types"
-	msg "mpc/frontend/messages"
-	"strconv"
-)
-
-type context struct {
-	Program   *hir.Program
-	symbolMap map[string]hir.SymbolID
-
-	HirProc *hir.Procedure
-	ModProc *ir.Proc
-
-	CurrBlock *hir.BasicBlock
-
-	TempCounter int64
-}
-
-func newContext(M *ir.Module) *context {
-	return &context{
-		Program:     hir.NewProgram(),
-		symbolMap:   map[string]hir.SymbolID{},
-		TempCounter: 0,
-	}
-}
-
-func (c *context) NewBlock() (hir.BlockID, *hir.BasicBlock) {
-	id := len(c.HirProc.AllBlocks)
-	v := strconv.FormatInt(int64(id), 10)
-	b := &hir.BasicBlock{
-		Label: ".L" + v,
-		Code:  []*hir.Instr{},
-	}
-	c.HirProc.AllBlocks = append(c.HirProc.AllBlocks, b)
-	return hir.BlockID(id), b
-}
-
-func (c *context) AllocTemp(t *T.Type) *hir.Operand {
-	op := &hir.Operand{
-		Class: hirc.Temp,
-		Type:  t,
-		Num:   c.TempCounter,
-	}
-	c.TempCounter++
-	return op
-}
-
-func (c *context) GetSymbolID(modName string, name string) hir.SymbolID {
-	return c.symbolMap[modName+"_"+name]
-}
-
-func (c *context) GetSymbol(modName string, name string) *hir.Symbol {
-	i := c.symbolMap[modName+"_"+name]
-	return c.Program.Symbols[i]
-}
-
-func Generate(M *ir.Module) (*hir.Program, *Error) {
-	c := newContext(M)
-
-	declAll(c, M)
-	M.ResetVisited()
-
-	err := genAll(c, M)
-	if err != nil {
-		return nil, err
-	}
-
-	M.ResetVisited()
-	sy, ok := M.Globals["main"]
-	if !ok {
-		panic("UERES MAIN")
-	}
-
-	c.Program.Entry = c.GetSymbolID(sy.ModuleName, sy.Name)
-	c.Program.Name = sy.ModuleName
-
-	return c.Program, nil
-}
-
-func declAll(c *context, M *ir.Module) {
-	if M.Visited {
-		return
-	}
-	M.Visited = true
-	for _, dep := range M.Dependencies {
-		declAll(c, dep.M)
-	}
-	for _, sy := range M.Globals {
-		if !sy.External {
-			if sy.T == ST.Proc {
-				p := newHirProc(M.Name, sy.Proc)
-				i := c.Program.AddProc(p)
-				c.symbolMap[p.Label] = hir.SymbolID(i)
-			} else if sy.T == ST.Mem {
-				m := newHirMem(M.Name, sy.Mem)
-				i := c.Program.AddMem(m)
-				c.symbolMap[m.Label] = hir.SymbolID(i)
-			} else if sy.T == ST.Builtin {
-				p := newBuiltin(sy)
-				i := c.Program.AddBuiltin(p)
-				c.symbolMap[p.Label] = hir.SymbolID(i)
-			}
-		}
-	}
-}
-
-func genAll(c *context, M *ir.Module) *Error {
-	if M.Visited {
-		return nil
-	}
-	M.Visited = true
-	for _, dep := range M.Dependencies {
-		err := genAll(c, dep.M)
-		if err != nil {
-			return err
-		}
-	}
-	for _, sy := range M.Globals {
-		if !sy.External {
-			if sy.T == ST.Proc {
-				err := genProc(c, M, sy.Proc)
-				if err != nil {
-					return err
-				}
-			}
-		}
-	}
-	return nil
-}
-
-func genProc(c *context, M *ir.Module, proc *ir.Proc) *Error {
-	c.ModProc = proc
-	c.HirProc = c.GetSymbol(M.Name, proc.Name).Proc
-
-	startID, start := c.NewBlock()
-	c.HirProc.Start = startID
-	c.CurrBlock = start
-
-	body := proc.N.Leaves[4]
-	genBlock(M, c, body)
-	if !hir.ProperlyTerminates(c.HirProc) {
-		if proc.DoesReturnSomething() {
-			return msg.NotAllCodePathsReturnAValue(M, proc)
-		}
-		for _, bb := range c.HirProc.AllBlocks {
-			if !bb.HasFlow() {
-				setReturn(bb)
-			}
-		}
-	}
-	return nil
-}
-
-func setReturn(b *hir.BasicBlock) {
-	b.Return([]*hir.Operand{})
-}
-
-func genBlock(M *ir.Module, c *context, body *ir.Node) {
-	for _, code := range body.Leaves {
-		switch code.Lex {
-		case lex.IF:
-			genIf(M, c, code)
-		case lex.WHILE:
-			genWhile(M, c, code)
-		case lex.SET:
-			genSet(M, c, code)
-		case lex.RETURN:
-			genReturn(M, c, code)
-		case lex.EXIT:
-			genExit(M, c, code)
-		default:
-			genExpr(M, c, code)
-		}
-	}
-}
-
-func genIf(M *ir.Module, c *context, if_ *ir.Node) {
-	exp := if_.Leaves[0]
-	block := if_.Leaves[1]
-	elseifchain := if_.Leaves[2]
-	else_ := if_.Leaves[3]
-
-	op := genExpr(M, c, exp)
-	trueblID, truebl := c.NewBlock()
-	falseblID, falsebl := c.NewBlock()
-	var outblID hir.BlockID
-	var outbl *hir.BasicBlock // we just generate an out block if it's reachable
-
-	c.CurrBlock.Branch(op, trueblID, falseblID)
-
-	c.CurrBlock = truebl
-	genBlock(M, c, block)
-	if c.CurrBlock != nil && !c.CurrBlock.HasFlow() {
-		outblID, outbl = c.NewBlock()
-		c.CurrBlock.Jmp(outblID)
-	}
-
-	c.CurrBlock = falsebl
-	if elseifchain != nil {
-		genElseIfChain(M, c, elseifchain, outblID)
-	}
-	if else_ != nil {
-		genBlock(M, c, else_.Leaves[0])
-	}
-	if c.CurrBlock != nil && !c.CurrBlock.HasFlow() {
-		if outbl == nil {
-			outblID, outbl = c.NewBlock()
-		}
-		c.CurrBlock.Jmp(outblID)
-	}
-	c.CurrBlock = outbl
-}
-
-func genElseIfChain(M *ir.Module, c *context, elseifchain *ir.Node, outblID hir.BlockID) {
-	for _, elseif := range elseifchain.Leaves {
-		exp := elseif.Leaves[0]
-		block := elseif.Leaves[1]
-
-		op := genExpr(M, c, exp)
-		trueblID, truebl := c.NewBlock()
-		falseblID, falsebl := c.NewBlock()
-		c.CurrBlock.Branch(op, trueblID, falseblID)
-
-		c.CurrBlock = truebl
-		genBlock(M, c, block)
-		if !c.CurrBlock.HasFlow() {
-			c.CurrBlock.Jmp(outblID)
-		}
-		c.CurrBlock = falsebl
-	}
-}
-
-func genWhile(M *ir.Module, c *context, while *ir.Node) {
-	loop_startID, loop_start := c.NewBlock()
-	loop_bodyID, loop_body := c.NewBlock()
-	loop_endID, loop_end := c.NewBlock()
-
-	c.CurrBlock.Jmp(loop_startID)
-	c.CurrBlock = loop_start
-
-	op := genExpr(M, c, while.Leaves[0])
-	c.CurrBlock.Branch(op, loop_bodyID, loop_endID)
-
-	c.CurrBlock = loop_body
-	genBlock(M, c, while.Leaves[1])
-	if !c.CurrBlock.HasFlow() {
-		c.CurrBlock.Jmp(loop_startID)
-	}
-
-	c.CurrBlock = loop_end
-}
-
-func genReturn(M *ir.Module, c *context, return_ *ir.Node) {
-	if c.CurrBlock.IsTerminal() {
-		return
-	}
-	operands := []*hir.Operand{}
-	for _, ret := range return_.Leaves {
-		op := genExpr(M, c, ret)
-		operands = append(operands, op)
-	}
-	c.CurrBlock.Return(operands)
-}
-
-func genExit(M *ir.Module, c *context, exit_ *ir.Node) {
-	if c.CurrBlock.IsTerminal() {
-		return
-	}
-	ret := exit_.Leaves[0]
-	op := genExpr(M, c, ret)
-	c.CurrBlock.Exit(op)
-}
-
-func genSet(M *ir.Module, c *context, set *ir.Node) {
-	assignees := set.Leaves[0]
-	op := set.Leaves[1]
-	expr := set.Leaves[2]
-
-	if len(assignees.Leaves) > 1 {
-		genMultiProcAssign(M, c, assignees, expr)
-		return
-	}
-
-	genSingleAssign(M, c, assignees.Leaves[0], expr, op.Lex)
-	return
-}
-
-func genMultiProcAssign(M *ir.Module, c *context, assignees, call *ir.Node) {
-	if call.Lex != lex.CALL {
-		panic("must be CALL:\n" + ir.FmtNode(call))
-	}
-	// TODO: OPT: pass assignees to genCall so that no copying needs to happen
-	rets := genCall(M, c, call)
-
-	genLoadAssignRets(M, c, assignees, rets)
-}
-
-func genIntOp(num int64) *hir.Operand {
-	return &hir.Operand{
-		Class: hirc.Lit,
-		Num:   num,
-	}
-}
-
-func genLoadAssignRets(M *ir.Module, c *context, assignees *ir.Node, ops []*hir.Operand) {
-	for i, ass := range assignees.Leaves {
-		op := ops[i]
-		if ass.Lex == lex.IDENTIFIER {
-			genCallAssign(M, c, ass, op)
-			continue
-		}
-		if ass.Lex == lex.AT {
-			genCallAssignMem(M, c, ass, op)
-			continue
-		}
-	}
-}
-
-func genCallInstr(c *context, proc *hir.Operand, args, rets []*hir.Operand) {
-	operands := []*hir.Operand{proc}
-	operands = append(operands, args...)
-	iCall := &hir.Instr{
-		T:           IT.Call,
-		Operands:    operands,
-		Destination: rets,
-	}
-	c.CurrBlock.AddInstr(iCall)
-}
-
-func genArgs(M *ir.Module, c *context, args *ir.Node) []*hir.Operand {
-	output := []*hir.Operand{}
-	for _, arg := range args.Leaves {
-		res := genExpr(M, c, arg)
-		output = append(output, res)
-	}
-	return output
-}
-
-func genRets(M *ir.Module, c *context, proc *hir.Operand) []*hir.Operand {
-	output := []*hir.Operand{}
-	for _, ret := range proc.Type.Proc.Rets {
-		op := c.AllocTemp(ret)
-		output = append(output, op)
-	}
-	return output
-}
-
-func genCallAssign(M *ir.Module, c *context, ass *ir.Node, op *hir.Operand) {
-	dest := genExprID(M, c, ass)
-	// TODO: OPT: try to avoid this COPY instruction
-	loadRet := RIU.Copy(op, dest)
-	c.CurrBlock.AddInstr(loadRet)
-}
-
-func genCallAssignMem(M *ir.Module, c *context, ass *ir.Node, op *hir.Operand) {
-	ptrOp := genExpr(M, c, ass.Leaves[1])
-	loadPtr := RIU.StorePtr(op, ptrOp)
-	c.CurrBlock.AddInstr(loadPtr)
-}
-
-func genSingleAssign(M *ir.Module, c *context, assignee, expr *ir.Node, op lex.LexKind) {
-	if assignee.Lex == lex.IDENTIFIER {
-		genNormalAssign(M, c, assignee, expr, op)
-		return
-	}
-	genDerefAssign(M, c, assignee, expr, op)
-	return
-}
-
-func genNormalAssign(M *ir.Module, c *context, assignee, expr *ir.Node, op lex.LexKind) {
-	dest := genExprID(M, c, assignee)
-	exp := genExpr(M, c, expr)
-	if op == lex.ASSIGNMENT {
-		// TODO: OPT: Try to avoid this COPY instruction
-		cp := RIU.Copy(exp, dest)
-		c.CurrBlock.AddInstr(cp)
-		return
-	}
-	instrT := mapOpToInstr(op)
-	instr := &hir.Instr{
-		T:           instrT,
-		Type:        dest.Type,
-		Operands:    []*hir.Operand{dest, exp},
-		Destination: []*hir.Operand{dest},
-	}
-	c.CurrBlock.AddInstr(instr)
-}
-
-func mapOpToInstr(l lex.LexKind) IT.InstrKind {
-	switch l {
-	case lex.PLUS_ASSIGN:
-		return IT.Add
-	case lex.MINUS_ASSIGN:
-		return IT.Sub
-	case lex.MULTIPLICATION_ASSIGN:
-		return IT.Mult
-	case lex.DIVISION_ASSIGN:
-		return IT.Div
-	case lex.REMAINDER_ASSIGN:
-		return IT.Rem
-	}
-	panic(l)
-}
-
-func genDerefAssign(M *ir.Module, c *context, left, right *ir.Node, op lex.LexKind) {
-	leftExpr := left.Leaves[1]
-	leftType := left.Leaves[0]
-	rightOp := genExpr(M, c, right)
-	leftOp := genExpr(M, c, leftExpr)
-	if op == lex.ASSIGNMENT {
-		store := RIU.StorePtr(rightOp, leftOp)
-		c.CurrBlock.AddInstr(store)
-		return
-	}
-
-	temp := c.AllocTemp(leftType.T)
-	load := RIU.LoadPtr(leftOp, temp)
-	c.CurrBlock.AddInstr(load) // load left -> temp
-
-	instrT := mapOpToInstr(op)
-	temp2 := c.AllocTemp(leftType.T)
-	instr := &hir.Instr{
-		T:           instrT,
-		Type:        temp.Type,
-		Operands:    []*hir.Operand{temp, rightOp},
-		Destination: []*hir.Operand{temp2},
-	}
-	c.CurrBlock.AddInstr(instr) // op temp, right -> temp2
-
-	store := RIU.StorePtr(temp2, leftOp)
-	c.CurrBlock.AddInstr(store) // store temp2 -> left
-}
-
-func genExpr(M *ir.Module, c *context, exp *ir.Node) *hir.Operand {
-	if T.IsInvalid(exp.T) {
-		panic("invalid type at: " + exp.String())
-	}
-	switch exp.Lex {
-	case lex.IDENTIFIER:
-		return genExprID(M, c, exp)
-	case lex.DOUBLECOLON:
-		return genExternalID(c, M, exp)
-	case lex.FALSE, lex.TRUE:
-		return genBoolLit(M, c, exp)
-	case lex.PTR_LIT, lex.I64_LIT, lex.I32_LIT, lex.I16_LIT, lex.I8_LIT, lex.CHAR_LIT:
-		return genNumLit(M, c, exp)
-	case lex.PLUS, lex.MINUS:
-		return genBinaryOp(M, c, exp)
-	case lex.MULTIPLICATION, lex.DIVISION, lex.REMAINDER,
-		lex.EQUALS, lex.DIFFERENT,
-		lex.MORE, lex.MOREEQ, lex.LESS, lex.LESSEQ,
-		lex.AND, lex.OR:
-		return genBinaryOp(M, c, exp)
-	case lex.COLON:
-		return genConversion(M, c, exp)
-	case lex.CALL:
-		out := genCall(M, c, exp)
-		if len(out) == 1 {
-			return out[0]
-		}
-		return nil
-	case lex.AT:
-		return genDeref(M, c, exp)
-	case lex.NOT, lex.NEG:
-		return genUnaryOp(M, c, exp)
-	case lex.DOT:
-		return genDot(M, c, exp)
-	}
-	panic("invalid or unimplemented expression type: " + exp.String())
-}
-
-// assume a single return
-func genCall(M *ir.Module, c *context, call *ir.Node) []*hir.Operand {
-	proc := call.Leaves[1]
-	args := call.Leaves[0]
-
-	procOp := genExpr(M, c, proc)
-
-	argOps := genArgs(M, c, args)
-	retOps := genRets(M, c, procOp)
-	genCallInstr(c, procOp, argOps, retOps)
-
-	return retOps
-}
-
-func genDeref(M *ir.Module, c *context, memAccess *ir.Node) *hir.Operand {
-	t := memAccess.Leaves[0].T
-	exp := memAccess.Leaves[1]
-
-	ptrOp := genExpr(M, c, exp)
-
-	dest := c.AllocTemp(t)
-	loadPtr := RIU.LoadPtr(ptrOp, dest)
-	c.CurrBlock.AddInstr(loadPtr)
-
-	return dest
-}
-
-func genExternalID(c *context, M *ir.Module, dcolon *ir.Node) *hir.Operand {
-	mod := dcolon.Leaves[0].Text
-	id := dcolon.Leaves[1].Text
-	otherM := M.Dependencies[mod].M
-	sy := otherM.Exported[id]
-	return globalToOperand(c, sy)
-}
-
-func genExprID(M *ir.Module, c *context, id *ir.Node) *hir.Operand {
-	decl, ok := c.ModProc.Vars[id.Text]
-	if ok {
-		return &hir.Operand{
-			Class: hirc.Local,
-			Type:  id.T,
-			Num:   int64(decl.Position),
-		}
-	}
-	posSy, ok := c.ModProc.ArgMap[id.Text]
-	if ok {
-		return &hir.Operand{
-			Class: hirc.Arg,
-			Type:  id.T,
-			Num:   int64(posSy.Position),
-		}
-	}
-	global, ok := M.Globals[id.Text]
-	if ok {
-		return globalToOperand(c, global)
-	}
-	panic("genExprID: global not found")
-}
-
-func globalToOperand(c *context, global *ir.Symbol) *hir.Operand {
-	i := int64(c.symbolMap[global.ModuleName+"_"+global.Name])
-	switch global.T {
-	case ST.Builtin:
-		return &hir.Operand{
-			Class: hirc.Global,
-			Type:  global.Type,
-			Num:   i,
-		}
-	case ST.Proc:
-		return &hir.Operand{
-			Class: hirc.Global,
-			Type:  global.N.T,
-			Num:   i,
-		}
-	case ST.Mem:
-		return &hir.Operand{
-			Class: hirc.Global,
-			Type:  T.T_Ptr,
-			Num:   i,
-		}
-	}
-	panic("wht jus heppn?")
-}
-
-func genConversion(M *ir.Module, c *context, colon *ir.Node) *hir.Operand {
-	a := genExpr(M, c, colon.Leaves[1])
-	dest := c.AllocTemp(colon.T)
-	instr := RIU.Convert(a, dest)
-	c.CurrBlock.AddInstr(instr)
-	return dest
-}
-
-func genNumLit(M *ir.Module, c *context, lit *ir.Node) *hir.Operand {
-	return &hir.Operand{
-		Class: hirc.Lit,
-		Type:  lit.T,
-		Num:   lit.Value,
-	}
-}
-
-func genBoolLit(M *ir.Module, c *context, lit *ir.Node) *hir.Operand {
-	value := 0
-	if lit.Lex == lex.TRUE {
-		value = 1
-	}
-	return &hir.Operand{
-		Class: hirc.Lit,
-		Type:  lit.T,
-		Num:   int64(value),
-	}
-}
-
-func genBinaryOp(M *ir.Module, c *context, op *ir.Node) *hir.Operand {
-	it := lexToBinaryOp(op.Lex)
-	a := genExpr(M, c, op.Leaves[0])
-	b := genExpr(M, c, op.Leaves[1])
-	dest := c.AllocTemp(op.T)
-	instr := &hir.Instr{
-		T:           it,
-		Type:        a.Type,
-		Operands:    []*hir.Operand{a, b},
-		Destination: []*hir.Operand{dest},
-	}
-	c.CurrBlock.AddInstr(instr)
-	return dest
-}
-
-func lexToBinaryOp(op lex.LexKind) IT.InstrKind {
-	switch op {
-	case lex.MINUS:
-		return IT.Sub
-	case lex.PLUS:
-		return IT.Add
-	case lex.MULTIPLICATION:
-		return IT.Mult
-	case lex.DIVISION:
-		return IT.Div
-	case lex.REMAINDER:
-		return IT.Rem
-	case lex.EQUALS:
-		return IT.Eq
-	case lex.DIFFERENT:
-		return IT.Diff
-	case lex.MORE:
-		return IT.More
-	case lex.MOREEQ:
-		return IT.MoreEq
-	case lex.LESS:
-		return IT.Less
-	case lex.LESSEQ:
-		return IT.LessEq
-	case lex.AND:
-		return IT.And
-	case lex.OR:
-		return IT.Or
-	}
-	panic("lexToBinaryOp: unexpected binOp: " + lex.FmtTypes(op))
-}
-
-func genUnaryOp(M *ir.Module, c *context, op *ir.Node) *hir.Operand {
-	it := lexToUnaryOp(op.Lex)
-	a := genExpr(M, c, op.Leaves[0])
-	dest := c.AllocTemp(op.T)
-	instr := &hir.Instr{
-		T:           it,
-		Type:        op.T,
-		Operands:    []*hir.Operand{a},
-		Destination: []*hir.Operand{dest},
-	}
-	c.CurrBlock.AddInstr(instr)
-	return dest
-}
-
-func lexToUnaryOp(op lex.LexKind) IT.InstrKind {
-	switch op {
-	case lex.NEG:
-		return IT.Neg
-	case lex.NOT:
-		return IT.Not
-	}
-	panic("lexToUnaryOp: unexpected unaryOp")
-}
-
-func genDot(M *ir.Module, c *context, dot *ir.Node) *hir.Operand {
-	mem := dot.Leaves[1]
-	s, ok := M.Globals[mem.Text]
-	if !ok {
-		panic("oh my god")
-	}
-	return &hir.Operand{
-		Class: hirc.Lit,
-		Type:  T.T_I64,
-		Num:   int64(s.Mem.Size),
-	}
-}
-
-func newBuiltin(sy *ir.Symbol) *hir.Procedure {
-	rets := sy.Type.Proc.Rets
-	args := sy.Type.Proc.Args
-	return &hir.Procedure{
-		Label: "_" + sy.Name,
-		Vars:  nil,
-		Rets:  rets,
-		Args:  args,
-	}
-}
-
-func newHirProc(modName string, P *ir.Proc) *hir.Procedure {
-	args := []*T.Type{}
-	for _, arg := range P.Args {
-		args = append(args, arg.Type)
-	}
-	vars := make([]*T.Type, len(P.Vars))
-	for _, ps := range P.Vars {
-		vars[ps.Position] = ps.Symbol.Type
-	}
-	return &hir.Procedure{
-		Label: modName + "_" + P.Name,
-		Vars:  vars,
-		Rets:  P.Rets,
-		Args:  args,
-	}
-}
-
-func newHirMem(modName string, M *ir.Mem) *hir.MemoryDecl {
-	return &hir.MemoryDecl{
-		Label: modName + "_" + M.Name,
-		Size:  M.Size,
-		Data:  M.Contents,
-	}
-}
diff --git a/frontend/lexer/lexer.go b/frontend/lexer/lexer.go
deleted file mode 100644
index b6c8e75..0000000
--- a/frontend/lexer/lexer.go
+++ /dev/null
@@ -1,691 +0,0 @@
-package lexer
-
-import (
-	ir "mpc/core/module"
-	T "mpc/core/module/lexkind"
-
-	. "mpc/core"
-	et "mpc/core/errorkind"
-
-	"fmt"
-	"strings"
-	"unicode/utf8"
-)
-
-const IsTracking bool = false
-
-func NewLexerError(st *Lexer, t et.ErrorKind, message string) *Error {
-	loc := GetSourceLocation(st)
-	return &Error{
-		Type: t,
-		Info: []Excerpt{
-			{
-				Location: &loc,
-				Message:  message,
-			},
-		},
-	}
-}
-
-type Lexer struct {
-	Word *ir.Node
-
-	File      string
-	Line, Col int
-
-	Start, End   int
-	LastRuneSize int
-	Input        string
-
-	Peeked *ir.Node
-}
-
-func NewLexer(s string) *Lexer {
-	st := &Lexer{
-		Input: s,
-	}
-	return st
-}
-
-func GetSourceLocation(s *Lexer) SourceLocation {
-	return SourceLocation{
-		File:  s.File,
-		Line:  s.Line,
-		Col:   s.Col,
-		Input: &s.Input,
-	}
-}
-
-func Next(l *Lexer) *Error {
-	if l.Peeked != nil {
-		p := l.Peeked
-		l.Peeked = nil
-		l.Word = p
-		return nil
-	}
-	symbol, err := any(l)
-	if err != nil {
-		return err
-	}
-	l.Start = l.End // this shouldn't be here
-	l.Word = symbol
-	return nil
-}
-
-func Peek(s *Lexer) (*ir.Node, *Error) {
-	symbol, err := any(s)
-	if err != nil {
-		return nil, err
-	}
-	s.Start = s.End
-	s.Peeked = symbol
-	return symbol, nil
-}
-
-func ReadAll(s *Lexer) ([]*ir.Node, *Error) {
-	e := Next(s)
-	if e != nil {
-		return nil, e
-	}
-	output := []*ir.Node{}
-	for s.Word.Lex != T.EOF {
-		output = append(output, s.Word)
-		e = Next(s)
-		if e != nil {
-			return nil, e
-		}
-	}
-	return output, nil
-}
-
-func GenNumNode(l *Lexer, tp T.LexKind, value int64) *ir.Node {
-	text := Selected(l)
-	n := &ir.Node{
-		Lex:    tp,
-		Text:   text,
-		Line:   l.Line,
-		Value:  value,
-		Col:    l.Col - len(text),
-		Length: len(text),
-	}
-	return n
-}
-
-func GenNode(l *Lexer, tp T.LexKind) *ir.Node {
-	text := Selected(l)
-	n := &ir.Node{
-		Lex:    tp,
-		Text:   text,
-		Line:   l.Line,
-		Col:    l.Col - len(text),
-		Length: len(text),
-	}
-	return n
-}
-
-func nextRune(l *Lexer) (rune, *Error) {
-	l.Col++
-	r, size := utf8.DecodeRuneInString(l.Input[l.End:])
-	if r == utf8.RuneError && size == 1 {
-		err := NewLexerError(l, et.InvalidUTF8Rune, "Invalid UTF8 rune in string")
-		return -1, err
-	}
-	l.End += size
-	l.LastRuneSize = size
-
-	return r, nil
-}
-
-/*ignore ignores the text previously read*/
-func ignore(l *Lexer) {
-	l.Start = l.End
-	l.LastRuneSize = 0
-}
-
-/*unread decrements the end index by the size of the last rune read,
-can only be used once after a Next()*/
-func unread(l *Lexer) {
-	if l.End > 0 {
-		l.End -= l.LastRuneSize
-		l.LastRuneSize = 0
-		l.Col--
-	}
-}
-
-func acceptRun(l *Lexer, s string) *Error {
-	r, err := nextRune(l)
-	if err != nil {
-		return err
-	}
-	for strings.ContainsRune(s, r) {
-		r, err = nextRune(l)
-		if err != nil {
-			return err
-		}
-	}
-	unread(l)
-	return nil
-}
-
-func acceptUntil(l *Lexer, s string) *Error {
-	r, err := nextRune(l)
-	if err != nil {
-		return err
-	}
-	for !strings.ContainsRune(s, r) {
-		r, err = nextRune(l)
-		if err != nil {
-			return err
-		}
-	}
-	unread(l)
-	return nil
-}
-
-const (
-	/*eof is equivalent to RuneError, but in this package it only shows up in EoFs
-	If the rune is invalid, it panics instead*/
-	eof rune = utf8.RuneError
-)
-
-func Selected(l *Lexer) string {
-	return l.Input[l.Start:l.End]
-}
-
-const (
-	insideStr  = `\"`
-	insideChar = `\'`
-	digits     = "0123456789"
-	hex_digits = "0123456789ABCDEFabcdef"
-	bin_digits = "01"
-	letters    = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_" // yes _ is a letter, fuck you
-)
-
-func isNumber(r rune) bool {
-	return strings.ContainsRune(digits, r)
-}
-
-func isLetter(r rune) bool {
-	return strings.ContainsRune(letters, r)
-}
-
-func ignoreWhitespace(st *Lexer) *Error {
-	r, err := nextRune(st)
-loop:
-	for {
-		switch r {
-		case ' ', '\t':
-		case '\n':
-			st.Line++
-			st.Col = 0
-		case '#':
-			comment(st)
-		default:
-			break loop
-		}
-		ignore(st)
-		r, err = nextRune(st)
-		if err != nil {
-			return err
-		}
-	}
-	unread(st)
-	return nil
-}
-
-// refactor this
-func any(st *Lexer) (*ir.Node, *Error) {
-	var err *Error
-	var r rune
-	var tp T.LexKind
-
-	err = ignoreWhitespace(st)
-
-	r, err = nextRune(st)
-	if err != nil {
-		return nil, err
-	}
-
-	if isNumber(r) {
-		unread(st)
-		return number(st)
-	}
-	if isLetter(r) {
-		return identifier(st)
-	}
-	if r == '\'' {
-		return charLit(st)
-	}
-	if r == '"' {
-		return strLit(st)
-	}
-
-	switch r {
-	case '+':
-		r, err := nextRune(st)
-		if err != nil {
-			return nil, err
-		}
-		switch r {
-		case '=':
-			tp = T.PLUS_ASSIGN
-		default:
-			unread(st)
-			tp = T.PLUS
-		}
-	case '-':
-		r, err := nextRune(st)
-		if err != nil {
-			return nil, err
-		}
-		switch r {
-		case '=':
-			tp = T.MINUS_ASSIGN
-		default:
-			unread(st)
-			tp = T.MINUS
-		}
-	case '/':
-		r, err := nextRune(st)
-		if err != nil {
-			return nil, err
-		}
-		switch r {
-		case '=':
-			tp = T.DIVISION_ASSIGN
-		default:
-			unread(st)
-			tp = T.DIVISION
-		}
-	case '*':
-		r, err := nextRune(st)
-		if err != nil {
-			return nil, err
-		}
-		switch r {
-		case '=':
-			tp = T.MULTIPLICATION_ASSIGN
-		default:
-			unread(st)
-			tp = T.MULTIPLICATION
-		}
-	case '%':
-		r, err := nextRune(st)
-		if err != nil {
-			return nil, err
-		}
-		switch r {
-		case '=':
-			tp = T.REMAINDER_ASSIGN
-		default:
-			unread(st)
-			tp = T.REMAINDER
-		}
-	case '@':
-		tp = T.AT
-	case '~':
-		tp = T.NEG
-	case '(':
-		tp = T.LEFTPAREN
-	case ')':
-		tp = T.RIGHTPAREN
-	case '{':
-		tp = T.LEFTBRACE
-	case '}':
-		tp = T.RIGHTBRACE
-	case '[':
-		tp = T.LEFTBRACKET
-	case ']':
-		tp = T.RIGHTBRACKET
-	case ',':
-		tp = T.COMMA
-	case ':':
-		r, err := nextRune(st)
-		if err != nil {
-			return nil, err
-		}
-		switch r {
-		case ':':
-			tp = T.DOUBLECOLON
-		default:
-			unread(st)
-			tp = T.COLON
-		}
-	case ';':
-		tp = T.SEMICOLON
-	case '.':
-		tp = T.DOT
-	case '>': // >  >=
-		r, err := nextRune(st)
-		if err != nil {
-			return nil, err
-		}
-		switch r {
-		case '=':
-			tp = T.MOREEQ
-		default:
-			unread(st)
-			tp = T.MORE
-		}
-	case '<': // <  <-  <=
-		r, err := nextRune(st)
-		if err != nil {
-			return nil, err
-		}
-		switch r {
-		case '=':
-			tp = T.LESSEQ
-		default:
-			unread(st)
-			tp = T.LESS
-		}
-	case '!':
-		r, err := nextRune(st)
-		if err != nil {
-			return nil, err
-		}
-		switch r {
-		case '=':
-			tp = T.DIFFERENT
-		default:
-			unread(st)
-			message := fmt.Sprintf("Invalid symbol: %v", string(r))
-			err := NewLexerError(st, et.InvalidSymbol, message)
-			return nil, err
-		}
-	case '=':
-		r, err := nextRune(st)
-		if err != nil {
-			return nil, err
-		}
-		if r == '=' {
-			tp = T.EQUALS
-		} else {
-			unread(st)
-			tp = T.ASSIGNMENT
-		}
-	case eof:
-		return &ir.Node{Lex: T.EOF}, nil
-	default:
-		message := fmt.Sprintf("Invalid symbol: %v", string(r))
-		err := NewLexerError(st, et.InvalidSymbol, message)
-		return nil, err
-	}
-	return GenNode(st, tp), nil
-}
-
-// sorry
-func number(st *Lexer) (*ir.Node, *Error) {
-	r, err := nextRune(st)
-	if err != nil {
-		return nil, err
-	}
-	var value int64
-	if r == '0' {
-		r, err = nextRune(st)
-		switch r {
-		case 'x': // he x
-			err = acceptRun(st, hex_digits)
-			if err != nil {
-				return nil, err
-			}
-			value = parseHex(Selected(st))
-		case 'b': // b inary
-			err = acceptRun(st, bin_digits)
-			if err != nil {
-				return nil, err
-			}
-			value = parseBin(Selected(st))
-		default:
-			unread(st)
-			err = acceptRun(st, digits)
-			if err != nil {
-				return nil, err
-			}
-			value = parseNormal(Selected(st))
-		}
-	} else {
-		unread(st)
-		err = acceptRun(st, digits)
-		if err != nil {
-			return nil, err
-		}
-		value = parseNormal(Selected(st))
-	}
-	r, err = nextRune(st)
-	if err != nil {
-		return nil, err
-	}
-	switch r {
-	case 'p': // p ointer
-		return GenNumNode(st, T.PTR_LIT, value), nil
-	case 'r': // cha r
-		return GenNumNode(st, T.I8_LIT, value), nil
-	case 't': // shor t
-		return GenNumNode(st, T.I16_LIT, value), nil
-	case 'g': // lon g
-		return GenNumNode(st, T.I32_LIT, value), nil
-	}
-	unread(st)
-	return GenNumNode(st, T.I64_LIT, value), nil
-}
-
-func identifier(st *Lexer) (*ir.Node, *Error) {
-	err := acceptRun(st, digits+letters)
-	if err != nil {
-		return nil, err
-	}
-	selected := Selected(st)
-	tp := T.IDENTIFIER
-	switch selected {
-	case "var":
-		tp = T.VAR
-	case "true":
-		tp = T.TRUE
-	case "false":
-		tp = T.FALSE
-	case "and":
-		tp = T.AND
-	case "or":
-		tp = T.OR
-	case "not":
-		tp = T.NOT
-	case "if":
-		tp = T.IF
-	case "else":
-		tp = T.ELSE
-	case "while":
-		tp = T.WHILE
-	case "return":
-		tp = T.RETURN
-	case "elseif":
-		tp = T.ELSEIF
-	case "proc":
-		tp = T.PROC
-	case "memory":
-		tp = T.MEMORY
-	case "begin":
-		tp = T.BEGIN
-	case "end":
-		tp = T.END
-	case "set":
-		tp = T.SET
-	case "exit":
-		tp = T.EXIT
-	case "import":
-		tp = T.IMPORT
-	case "from":
-		tp = T.FROM
-	case "export":
-		tp = T.EXPORT
-	case "i8":
-		tp = T.I8
-	case "i16":
-		tp = T.I16
-	case "i32":
-		tp = T.I32
-	case "i64":
-		tp = T.I64
-	case "bool":
-		tp = T.BOOL
-	case "ptr":
-		tp = T.PTR
-	}
-	return GenNode(st, tp), nil
-}
-
-func comment(st *Lexer) *Error {
-	r, err := nextRune(st)
-	if err != nil {
-		return err
-	}
-	for !strings.ContainsRune("\n"+string(eof), r) {
-		r, err = nextRune(st)
-		if err != nil {
-			return err
-		}
-	}
-	if r == '\n' {
-		unread(st)
-	}
-	return nil
-}
-
-func strLit(st *Lexer) (*ir.Node, *Error) {
-	for {
-		err := acceptUntil(st, insideStr)
-		if err != nil {
-			return nil, err
-		}
-		r, err := nextRune(st)
-		if err != nil {
-			return nil, err
-		}
-		if r == '"' {
-			return &ir.Node{
-				Text: Selected(st),
-				Lex:  T.STRING_LIT,
-				Line: st.Line,
-				Col:  st.Col,
-			}, nil
-		}
-		if r == '\\' {
-			_, err = nextRune(st) // escaped rune
-			if err != nil {
-				return nil, err
-			}
-		}
-		unread(st)
-	}
-}
-
-func charLit(st *Lexer) (*ir.Node, *Error) {
-	for {
-		acceptUntil(st, insideChar)
-		r, err := nextRune(st)
-		if err != nil {
-			return nil, err
-		}
-		if r == '\'' {
-			text := Selected(st)
-			return &ir.Node{
-				Text:  text,
-				Lex:   T.CHAR_LIT,
-				Line:  st.Line,
-				Value: parseCharLit(text[1 : len(text)-1]),
-				Col:   st.Col,
-			}, nil
-		}
-		if r == '\\' {
-			_, err = nextRune(st) // escaped
-			if err != nil {
-				return nil, err
-			}
-		}
-		unread(st)
-	}
-}
-
-func IsValidIdentifier(s string) bool {
-	st := NewLexer(s)
-	tks, err := ReadAll(st)
-	if err != nil {
-		return false
-	}
-	if len(tks) != 1 { // we want only ID
-		return false
-	}
-	return tks[0].Lex == T.IDENTIFIER
-}
-
-func parseNormal(text string) int64 {
-	var output int64 = 0
-	for i := range text {
-		output *= 10
-		char := text[i]
-		if char >= '0' || char <= '9' {
-			output += int64(char - '0')
-		} else {
-			panic(text)
-		}
-	}
-	return output
-}
-
-func parseHex(oldText string) int64 {
-	text := oldText[2:]
-	var output int64 = 0
-	for i := range text {
-		output *= 16
-		char := text[i]
-		if char >= '0' && char <= '9' {
-			output += int64(char - '0')
-		} else if char >= 'a' && char <= 'f' {
-			output += int64(char-'a') + 10
-		} else if char >= 'A' && char <= 'F' {
-			output += int64(char-'A') + 10
-		} else {
-			panic(text)
-		}
-	}
-	return output
-}
-
-func parseBin(oldText string) int64 {
-	text := oldText[2:]
-	var output int64 = 0
-	for i := range text {
-		output *= 2
-		char := text[i]
-		if char == '0' || char == '1' {
-			output += int64(char - '0')
-		} else {
-			panic(text)
-		}
-	}
-	return output
-}
-
-func parseCharLit(text string) int64 {
-	value := int64(text[0])
-	if len(text) > 1 {
-		switch text {
-		case "\\n":
-			value = '\n'
-		case "\\t":
-			value = '\t'
-		case "\\r":
-			value = '\r'
-		case "\\'":
-			value = '\''
-		case "\\\"":
-			value = '"'
-		case "\\\\":
-			value = '\\'
-		default:
-			fmt.Println(text)
-			panic("too many chars in char :C")
-		}
-	}
-	return value
-}
diff --git a/frontend/messages/messages.go b/frontend/messages/messages.go
deleted file mode 100644
index d745de1..0000000
--- a/frontend/messages/messages.go
+++ /dev/null
@@ -1,263 +0,0 @@
-package messages
-
-import (
-	. "mpc/core"
-	et "mpc/core/errorkind"
-	ir "mpc/core/module"
-	T "mpc/core/types"
-	. "mpc/core/util"
-	"strconv"
-	"strings"
-)
-
-func ErrorNameAlreadyDefined(M *ir.Module, newName *ir.Node, oldName *ir.Node) *Error {
-	exc1 := NewNodeInfo(newName, "name already exists")
-	exc2 := NewNodeInfo(oldName, "defined here")
-	err := NewSemanticError(M, et.NameAlreadyDefined, exc1, exc2)
-	return err
-}
-
-func ErrorDuplicatedExport(M *ir.Module, n *ir.Node, other *ir.Node) *Error {
-	ni1 := NewNodeInfo(n, "previously exported here")
-	ni2 := NewNodeInfo(n, "named already exported")
-	return NewSemanticError(M, et.DuplicatedExport, ni1, ni2)
-}
-
-func ErrorExportingUndefName(M *ir.Module, n *ir.Node) *Error {
-	ni := NewNodeInfo(n, "name not defined in this module")
-	return NewSemanticError(M, et.ExportingUndefName, ni)
-}
-
-func NameNotExported(M *ir.Module, n *ir.Node) *Error {
-	ni := NewNodeInfo(n, "name not defined in module")
-	return NewSemanticError(M, et.NameNotExported, ni)
-}
-
-func ErrorOperationBetweenUnequalTypes(M *ir.Module, op *ir.Node) *Error {
-	left := op.Leaves[0]
-	right := op.Leaves[1]
-
-	excOp := NewNodeInfo(op, "Operation between unequal types")
-	excLeft := NewNodeInfo(left, left.T.String())
-	excRight := NewNodeInfo(right, right.T.String())
-	return NewSemanticError(M, et.OperationBetweenUnequalTypes, excOp, excLeft, excRight)
-}
-
-func ErrorTypeCheckerExpectedName(M *ir.Module, n *ir.Node) *Error {
-	info := NewNodeInfo(n, "name is not declared")
-	return NewSemanticError(M, et.ExpectedName, info)
-}
-
-func ErrorNameResExpectedName(M *ir.Module, n *ir.Node) *Error {
-	info := NewNodeInfo(n, "name is not declared")
-	return NewSemanticError(M, et.ExpectedName, info)
-}
-
-func ErrorInvalidInitForMemType(M *ir.Module, sy *ir.Symbol, n *ir.Node) *Error {
-	info := NewNodeInfo(n, "expected to be of type: "+sy.Mem.Type.String())
-	return NewSemanticError(M, et.InvalidInitForMemType, info)
-}
-
-func ErrorNameNotDefined(M *ir.Module, n *ir.Node) *Error {
-	info := NewNodeInfo(n, "name is not defined")
-	return NewSemanticError(M, et.NameNotDefined, info)
-}
-
-func ErrorBadDeref(M *ir.Module, n *ir.Node, t *T.Type) *Error {
-	info := NewNodeInfo(n, "can only index pointers (type: "+t.String()+")")
-	return NewSemanticError(M, et.CanOnlyDerefPointers, info)
-}
-
-func ErrorCannotAssignGlobal(M *ir.Module, global *ir.Symbol, n *ir.Node) *Error {
-	info := NewNodeInfo(n, "cannot assign global")
-	source := NewNodeInfo(global.N, "defined here")
-	return NewSemanticError(M, et.CanOnlyAssignLocal, info, source)
-}
-
-func ErrorNotAssignable(M *ir.Module, assignee *ir.Node) *Error {
-	info := NewNodeInfo(assignee, "not assignable")
-	return NewSemanticError(M, et.NotAssignable, info)
-}
-
-func ErrorInvalidType(M *ir.Module, n *ir.Node) *Error {
-	info := NewNodeInfo(n, "invalid type in expression")
-	return NewSemanticError(M, et.InvalidType, info)
-}
-
-func ErrorCannotUseMultipleValuesInExpr(M *ir.Module, n *ir.Node) *Error {
-	info := NewNodeInfo(n, "cannot use multi returns in expressions")
-	return NewSemanticError(M, et.InvalidType, info)
-}
-
-func ErrorExpectedConst(M *ir.Module, global *ir.Symbol, n *ir.Node) *Error {
-	info := NewNodeInfo(n, "id is not a constant")
-	source := NewNodeInfo(global.N, "is a: "+global.T.String())
-	return NewSemanticError(M, et.ExpectedConst, info, source)
-}
-
-func ErrorMemResAllowsOnlyIntAndChar(M *ir.Module, n *ir.Node) *Error {
-	info := NewNodeInfo(n, "must be int or char")
-	return NewSemanticError(M, et.InvalidMemResTerm, info)
-}
-
-func ErrorMismatchedTypeForArgument(M *ir.Module, param *ir.Node, arg *T.Type) *Error {
-	info := NewNodeInfo(param, "mismatched type in Call, has type: "+param.T.String()+", expected: "+arg.String())
-	return NewSemanticError(M, et.MismatchedTypeForArgument, info)
-}
-
-func ErrorInvalidNumberOfArgs(M *ir.Module, callee *T.ProcType, n *ir.Node) *Error {
-	expected := strconv.Itoa(len(callee.Args))
-	info := NewNodeInfo(n, "invalid number of arguments, expected: "+expected)
-	return NewSemanticError(M, et.InvalidNumberOfArgs, info)
-}
-
-func ErrorExpectedProcedure(M *ir.Module, n *ir.Node) *Error {
-	info := NewNodeInfo(n, "is not a procedure (type: "+n.String()+")")
-	return NewSemanticError(M, et.ExpectedProcedure, info)
-}
-
-func ErrorExpectedBasicType(M *ir.Module, n *ir.Node) *Error {
-	info := NewNodeInfo(n, "is not of a basic type (type: "+n.String()+")")
-	return NewSemanticError(M, et.ExpectedBasicType, info)
-}
-
-func ErrorInvalidNumberOfReturns(M *ir.Module, proc *ir.Proc, n *ir.Node) *Error {
-	expected := strconv.Itoa(len(proc.Rets))
-	info := NewNodeInfo(n, "invalid number of returns")
-	source := NewNodeInfo(proc.N, "expected: "+expected)
-	return NewSemanticError(M, et.InvalidNumberOfReturns, info, source)
-}
-
-func ErrorUnmatchingReturns(M *ir.Module, proc *ir.Proc, retN *ir.Node, i int) *Error {
-	ret := proc.Rets[i]
-	info := NewNodeInfo(retN, "mismatched type in return, has type: "+retN.T.String())
-	source := NewNodeInfo(proc.N, "expected type: "+ret.String())
-	return NewSemanticError(M, et.MismatchedReturnType, info, source)
-}
-
-func ErrorExpectedMem(M *ir.Module, n *ir.Node) *Error {
-	info := NewNodeInfo(n, "is not a memory region")
-	return NewSemanticError(M, et.ExpectedMem, info)
-}
-
-func ErrorExpectedMemGotLocal(M *ir.Module, local *ir.Symbol, n *ir.Node) *Error {
-	info := NewNodeInfo(n, "is not a memory region")
-	source := NewNodeInfo(local.N, "defined here")
-	return NewSemanticError(M, et.ExpectedMem, info, source)
-}
-
-func ErrorCantUseStringInExpr(M *ir.Module, n *ir.Node) *Error {
-	info := NewNodeInfo(n, "cannot use string in expressions")
-	return NewSemanticError(M, et.InvalidUseOfString, info)
-}
-
-func ErrorMismatchedMultiRetAssignment(M *ir.Module, proc *ir.Symbol, n *ir.Node, left *ir.Node) *Error {
-	has := strconv.Itoa(len(left.Leaves))
-	expected := strconv.Itoa(len(proc.Proc.Rets))
-	info := NewNodeInfo(n, "invalid number of assignments: "+has)
-	source := NewNodeInfo(proc.N, "expected: "+expected)
-	return NewSemanticError(M, et.MismatchedMultiRetAssignment, info, source)
-}
-
-func ErrorMismatchedTypesInMultiAssignment(M *ir.Module, proc *ir.Symbol, assignee *ir.Node, i int) *Error {
-	ret := proc.Proc.Rets[i]
-	info := NewNodeInfo(assignee, "mismatched type in assignment, has type: "+assignee.T.String())
-	source := NewNodeInfo(proc.N, "expected type: "+ret.String())
-	return NewSemanticError(M, et.MismatchedTypeInMultiRetAssign, info, source)
-}
-
-func ErrorMismatchedTypesInAssignment(M *ir.Module, assignee *ir.Node, value *ir.Node) *Error {
-	info := NewNodeInfo(assignee, "mismatched type in assignment, has type: "+assignee.T.String())
-	source := NewNodeInfo(value, "expected type: "+value.T.String())
-	return NewSemanticError(M, et.MismatchedTypeInAssign, info, source)
-}
-
-func ErrorMismatchedAssignment(M *ir.Module, assignee *ir.Node) *Error {
-	info := NewNodeInfo(assignee, "mismatched number of expressions in assignment")
-	return NewSemanticError(M, et.MismatchedTypeInAssign, info)
-}
-
-func ErrorInvalidClassForExpr(M *ir.Module, n *ir.Node, descr string) *Error {
-	info := NewNodeInfo(n, "invalid type "+n.T.String()+", expected "+descr)
-	return NewSemanticError(M, et.InvalidClassforExpr, info)
-}
-
-func ErrorCannotUseVoid(M *ir.Module, n *ir.Node) *Error {
-	info := NewNodeInfo(n, "cannot use void as value")
-	return NewSemanticError(M, et.CannotUseVoid, info)
-}
-func ErrorCanOnlyUseNormalAssignment(M *ir.Module, n *ir.Node) *Error {
-	info := NewNodeInfo(n, "can only use normal assignment when assigning multiple values")
-	return NewSemanticError(M, et.CanOnlyUseNormalAssignment, info)
-}
-
-func ExpectedNumber(M *ir.Module, op *ir.Node, t *T.Type) *Error {
-	info := NewNodeInfo(op, "operation can only be done on numbers (type: "+t.String()+")")
-	return NewSemanticError(M, et.ExpectedNumber, info)
-}
-
-func ExitMustBeI8(M *ir.Module, exp *ir.Node) *Error {
-	info := NewNodeInfo(exp, "exit must be type i8 (type: "+exp.T.String()+")")
-	return NewSemanticError(M, et.ExitMustBeI8, info)
-}
-
-func ErrorPtrCantBeUsedAsMemSize(M *ir.Module, init *ir.Node) *Error {
-	info := NewNodeInfo(init, "can't use pointer type as size of memory")
-	return NewSemanticError(M, et.PtrCantBeUsedAsMemSize, info)
-}
-
-func ErrorInvalidProp(M *ir.Module, n *ir.Node) *Error {
-	info := NewNodeInfo(n, "is not a valid property (only 'size' allowed)")
-	return NewSemanticError(M, et.ExpectedMem, info)
-}
-
-func NotAllCodePathsReturnAValue(M *ir.Module, p *ir.Proc) *Error {
-	info := NewNodeInfo(p.N, "not all code paths return a value")
-	return NewSemanticError(M, et.NotAllCodePathsReturnAValue, info)
-}
-
-func InvalidMain(M *ir.Module, sy *ir.Symbol) *Error {
-	main := NewNodeInfo(sy.N, "invalid type for main function: must be proc[][]")
-	return NewSemanticError(M, et.InvalidMain, main)
-}
-
-func ProgramWithoutEntry(M *ir.Module) *Error {
-	start := NewNodeInfo(M.Root, "program has no entry point")
-	return NewSemanticError(M, et.NoEntryPoint, start)
-}
-
-func AmbiguousFilesInFolder(M *ir.Module, n *ir.Node, found []string, modID string) *Error {
-	msg := "Multiple modules possible for " + modID +
-		": " + strings.Join(found, ", ")
-	if M != nil && n != nil {
-		info := NewNodeInfo(n, msg)
-		return NewSemanticError(M, et.AmbiguousModuleName, info)
-	}
-	return &Error{
-		Type:  et.AmbiguousModuleName,
-		Debug: msg,
-	}
-}
-
-func ModuleNotFound(M *ir.Module, n *ir.Node, baseFolder string, modID string) *Error {
-	msg := "module " + modID + " not found in folder " + baseFolder
-	if M != nil && n != nil {
-		info := NewNodeInfo(n, msg)
-		return NewSemanticError(M, et.ModuleNotFound, info)
-	}
-	return &Error{
-		Type:  et.ModuleNotFound,
-		Debug: msg,
-	}
-}
-
-func ErrorInvalidDependencyCycle(M *ir.Module, prev []*ir.Dependency, dep *ir.Dependency) *Error {
-	ninfoList := []*NodeInfo{}
-	for _, item := range prev {
-		ni := NewNodeInfo(item.Source, "references")
-		ninfoList = append(ninfoList, ni)
-	}
-	ni := NewNodeInfo(dep.Source, "forms a invalid cycle")
-	ninfoList = append(ninfoList, ni)
-	return NewSemanticError(M, et.InvalidDependencyCycle, ninfoList...)
-}
diff --git a/frontend/nameresolution/nameresolution.go b/frontend/nameresolution/nameresolution.go
deleted file mode 100644
index f98d67e..0000000
--- a/frontend/nameresolution/nameresolution.go
+++ /dev/null
@@ -1,220 +0,0 @@
-package nameresolution
-
-import (
-	. "mpc/core"
-	ir "mpc/core/module"
-	lex "mpc/core/module/lexkind"
-	ST "mpc/core/module/symbolkind"
-	T "mpc/core/types"
-	msg "mpc/frontend/messages"
-)
-
-func ResolveNames(M *ir.Module) *Error {
-	err := resolve(M)
-	if err != nil {
-		return err
-	}
-	M.ResetVisited()
-	return nil
-}
-
-func resolve(M *ir.Module) *Error {
-	if M.Visited {
-		return nil
-	}
-	M.Visited = true
-	for _, dep := range M.Dependencies {
-		err := resolve(dep.M)
-		if err != nil {
-			return err
-		}
-	}
-
-	err := createImportedSymbols(M)
-	if err != nil {
-		return err
-	}
-
-	err = createGlobals(M)
-	if err != nil {
-		return err
-	}
-
-	err = checkExports(M)
-	if err != nil {
-		return err
-	}
-
-	return nil
-}
-
-func createGlobals(M *ir.Module) *Error {
-	symbols := M.Root.Leaves[1]
-	for _, symbol := range symbols.Leaves {
-		err := declareSymbol(M, symbol)
-		if err != nil {
-			return err
-		}
-	}
-	return nil
-}
-
-func importSymbols(M *ir.Module, n *ir.Node) *Error {
-	for _, m := range n.Leaves {
-		err := defineModSymbol(M, m)
-		if err != nil {
-			return err
-		}
-	}
-	return nil
-}
-
-func defineModSymbol(M *ir.Module, n *ir.Node) *Error {
-	name := n.Text
-	sy := &ir.Symbol{
-		Name:       name,
-		T:          ST.Module,
-		ModuleName: M.Name,
-		N:          n,
-	}
-	v, ok := M.Globals[name]
-	if ok {
-		return msg.ErrorNameAlreadyDefined(M, n, v.N)
-	}
-	M.Globals[name] = sy
-	return nil
-}
-
-func createImportedSymbols(M *ir.Module) *Error {
-	coupling := M.Root.Leaves[0]
-	for _, n := range coupling.Leaves {
-		switch n.Lex {
-		case lex.IMPORT:
-			err := importSymbols(M, n)
-			if err != nil {
-				return err
-			}
-		case lex.FROM:
-			err := fromImportSymbols(M, n)
-			if err != nil {
-				return err
-			}
-		}
-	}
-	return nil
-}
-
-func fromImportSymbols(M *ir.Module, n *ir.Node) *Error {
-	mod := n.Leaves[0].Text
-	dep, ok := M.Dependencies[mod]
-	if !ok {
-		panic("dependency should have been found")
-	}
-	ids := n.Leaves[1]
-	for _, id := range ids.Leaves {
-		sy, ok := dep.M.Exported[id.Text]
-		if !ok {
-			return msg.NameNotExported(M, id)
-		}
-		err := defineExternalSymbol(M, id, sy)
-		if err != nil {
-			return err
-		}
-	}
-	return nil
-}
-
-func defineExternalSymbol(M *ir.Module, n *ir.Node, sy *ir.Symbol) *Error {
-	newSy := &ir.Symbol{
-		Name:       sy.Name,
-		T:          sy.T,
-		N:          sy.N,
-		ModuleName: sy.ModuleName,
-		External:   true,
-	}
-	v, ok := M.Globals[sy.Name]
-	if ok {
-		return msg.ErrorNameAlreadyDefined(M, n, v.N)
-	}
-	M.Globals[sy.Name] = newSy
-	return nil
-}
-
-func checkExports(M *ir.Module) *Error {
-	// check if there are duplicated exports
-	// look at global symbols and check if they exist
-	// insert into the export list
-	coupling := M.Root.Leaves[0]
-	exported := map[string]*ir.Node{}
-	for _, exp := range coupling.Leaves {
-		if exp.Lex == lex.EXPORT {
-			for _, name := range exp.Leaves {
-				n, ok := exported[name.Text]
-				if ok {
-					return msg.ErrorDuplicatedExport(M, n, name)
-				}
-				exported[name.Text] = name
-			}
-		}
-	}
-	for name, n := range exported {
-		sy, ok := M.Globals[name]
-		if !ok {
-			return msg.ErrorExportingUndefName(M, n)
-		}
-		M.Exported[name] = sy
-	}
-	return nil
-}
-
-func declareSymbol(M *ir.Module, n *ir.Node) *Error {
-	sy := getSymbol(M, n)
-	v, ok := M.Globals[sy.Name]
-	if ok {
-		return msg.ErrorNameAlreadyDefined(M, n, v.N)
-	}
-	M.Globals[sy.Name] = sy
-	return nil
-}
-
-func getSymbol(M *ir.Module, n *ir.Node) *ir.Symbol {
-	name := getSymbolName(n)
-	switch n.Lex {
-	case lex.PROC:
-		return &ir.Symbol{
-			T:          ST.Proc,
-			Name:       name,
-			ModuleName: M.Name,
-			Proc: &ir.Proc{
-				Name:   name,
-				ArgMap: map[string]ir.PositionalSymbol{},
-				Vars:   map[string]ir.PositionalSymbol{},
-				N:      n,
-			},
-			N: n,
-		}
-	case lex.MEMORY:
-		return getMemSymbol(M, n)
-	}
-	panic("getSymbolType: what")
-}
-
-func getMemSymbol(M *ir.Module, n *ir.Node) *ir.Symbol {
-	name := getSymbolName(n)
-	mem := &ir.Mem{
-		Name: name,
-		Init: n.Leaves[1],
-	}
-	return &ir.Symbol{
-		T:          ST.Mem,
-		Type:       T.T_Ptr,
-		Name:       name,
-		ModuleName: M.Name,
-		Mem:        mem,
-		N:          n,
-	}
-}
-
-func getSymbolName(n *ir.Node) string {
-	return n.Leaves[0].Text
-}
diff --git a/frontend/parser/parser.go b/frontend/parser/parser.go
deleted file mode 100644
index b9f67e4..0000000
--- a/frontend/parser/parser.go
+++ /dev/null
@@ -1,886 +0,0 @@
-package parser
-
-import (
-	. "mpc/core"
-	et "mpc/core/errorkind"
-	ir "mpc/core/module"
-	T "mpc/core/module/lexkind"
-	. "mpc/core/module/util"
-	. "mpc/frontend/lexer"
-)
-
-func Parse(s string) (*ir.Node, *Error) {
-	st := NewLexer(s)
-	err := Next(st)
-	if err != nil {
-		return nil, err
-	}
-	n, err := module(st)
-	return n, err
-}
-
-// Module := {Coupling} {Symbol}.
-func module(s *Lexer) (*ir.Node, *Error) {
-	Track(s, "module")
-	coupl, err := Repeat(s, coupling)
-	if err != nil {
-		return nil, err
-	}
-	symb, err := Repeat(s, symbol)
-	if err != nil {
-		return nil, err
-	}
-	n := &ir.Node{
-		Leaves: []*ir.Node{
-			CreateNode(coupl, T.COUPLINGS),
-			CreateNode(symb, T.SYMBOLS),
-		},
-	}
-	if s.Word.Lex != T.EOF {
-		return nil, ExpectedEOF(s)
-	}
-	return n, nil
-}
-
-// Coupling := Import | FromImport | Export.
-func coupling(s *Lexer) (*ir.Node, *Error) {
-	switch s.Word.Lex {
-	case T.IMPORT:
-		return _import(s)
-	case T.FROM:
-		return _fromImport(s)
-	case T.EXPORT:
-		return _export(s)
-	}
-	return nil, nil
-}
-
-// Import := 'import' IdList.
-func _import(s *Lexer) (*ir.Node, *Error) {
-	kw, err := Expect(s, T.IMPORT)
-	if err != nil {
-		return nil, err
-	}
-	list, err := RepeatCommaList(s, expectIdent)
-	if err != nil {
-		return nil, err
-	}
-	kw.Leaves = list
-	return kw, nil
-}
-
-// FromImport := 'from' id 'import' IdList.
-func _fromImport(s *Lexer) (*ir.Node, *Error) {
-	kw, err := Expect(s, T.FROM)
-	if err != nil {
-		return nil, err
-	}
-	id, err := Expect(s, T.IDENTIFIER)
-	if err != nil {
-		return nil, err
-	}
-
-	_, err = Expect(s, T.IMPORT)
-	if err != nil {
-		return nil, err
-	}
-
-	list, err := RepeatCommaList(s, expectIdent)
-	if err != nil {
-		return nil, err
-	}
-	listNode := &ir.Node{Lex: T.IDLIST, Leaves: list}
-	kw.Leaves = []*ir.Node{id, listNode}
-	return kw, nil
-}
-
-// Export := 'export' IdList.
-func _export(s *Lexer) (*ir.Node, *Error) {
-	kw, err := Expect(s, T.EXPORT)
-	if err != nil {
-		return nil, err
-	}
-	list, err := RepeatCommaList(s, expectIdent)
-	if err != nil {
-		return nil, err
-	}
-	kw.Leaves = list
-	return kw, nil
-}
-
-// Symbol := Procedure | Memory.
-func symbol(s *Lexer) (*ir.Node, *Error) {
-	Track(s, "symbol")
-	var n *ir.Node
-	var err *Error
-	switch s.Word.Lex {
-	case T.PROC:
-		n, err = procDef(s)
-	case T.MEMORY:
-		n, err = memDef(s)
-	default:
-		return nil, nil
-	}
-	return n, err
-}
-
-// Memory := 'memory' id (number|string).
-func memDef(s *Lexer) (*ir.Node, *Error) {
-	kw, err := Expect(s, T.MEMORY)
-	if err != nil {
-		return nil, err
-	}
-	id, err := Expect(s, T.IDENTIFIER)
-	if err != nil {
-		return nil, err
-	}
-	definition, err := numberOrString(s)
-	if err != nil {
-		return nil, err
-	}
-	kw.Leaves = []*ir.Node{id, definition}
-	return kw, nil
-}
-
-// Procedure := 'proc' id [Args [Rets]] [Vars] Block 'proc'.
-func procDef(s *Lexer) (*ir.Node, *Error) {
-	Track(s, "Procedure")
-	kw, err := Expect(s, T.PROC)
-	if err != nil {
-		return nil, err
-	}
-	var id, args, rets, vars *ir.Node
-	id, err = Expect(s, T.IDENTIFIER)
-	if err != nil {
-		return nil, err
-	}
-	if s.Word.Lex == T.LEFTBRACKET {
-		args, err = procArgs(s)
-		if err != nil {
-			return nil, err
-		}
-		rets, err = typeList(s)
-		if err != nil {
-			return nil, err
-		}
-	}
-	if s.Word.Lex == T.VAR {
-		vars, err = procVars(s)
-		if err != nil {
-			return nil, err
-		}
-	}
-	body, err := block(s)
-	if err != nil {
-		return nil, err
-	}
-	_, err = Expect(s, T.PROC)
-	if err != nil {
-		return nil, err
-	}
-	kw.Leaves = []*ir.Node{id, args, rets, vars, body}
-	return kw, nil
-}
-
-// Args := '[' [DeclList] ']'.
-func procArgs(s *Lexer) (*ir.Node, *Error) {
-	Track(s, "Args")
-	_, err := Expect(s, T.LEFTBRACKET)
-	if err != nil {
-		return nil, err
-	}
-
-	if s.Word.Lex != T.RIGHTBRACKET {
-		n, err := declList(s)
-		if err != nil {
-			return nil, err
-		}
-		_, err = Expect(s, T.RIGHTBRACKET)
-		if err != nil {
-			return nil, err
-		}
-		return n, nil
-	}
-
-	_, err = Expect(s, T.RIGHTBRACKET)
-	if err != nil {
-		return nil, err
-	}
-	return nil, nil
-}
-
-// Rets := TypeList.
-// TypeList := type {',' type} [','].
-func typeList(s *Lexer) (*ir.Node, *Error) {
-	Track(s, "TypeList")
-	rets, err := RepeatCommaList(s, _type)
-	if err != nil {
-		return nil, err
-	}
-	if rets == nil {
-		return nil, nil
-	}
-	return &ir.Node{
-		Lex:    T.TYPELIST,
-		Leaves: rets,
-	}, nil
-}
-
-func obligatoryTypeList(s *Lexer) (*ir.Node, *Error) {
-	Track(s, "obligatoryTypeList")
-	rets, err := RepeatCommaList(s, _obligatoryType)
-	if err != nil {
-		return nil, err
-	}
-	if rets == nil {
-		return nil, nil
-	}
-	return &ir.Node{
-		Lex:    T.TYPELIST,
-		Leaves: rets,
-	}, nil
-}
-
-// _type := basic | ProcType.
-func _type(s *Lexer) (*ir.Node, *Error) {
-	Track(s, "type")
-	switch s.Word.Lex {
-	case T.I16, T.I8, T.I32, T.I64, T.BOOL, T.PTR:
-		return Consume(s)
-	case T.PROC:
-		return procType(s)
-	}
-	return nil, nil
-}
-
-// _type := basic | ProcType.
-func _obligatoryType(s *Lexer) (*ir.Node, *Error) {
-	return ExpectProd(s, _type, "type")
-}
-
-// ProcType := 'proc' '[' [TypeList] ']' ProcTypeRet.
-// ProcTypeRet := '[' [TypeList] ']' | [Type].
-func procType(s *Lexer) (*ir.Node, *Error) {
-	Track(s, "procType")
-	keyword, err := Expect(s, T.PROC)
-	if err != nil {
-		return nil, err
-	}
-	args, err := procTypeTypeList(s)
-	if err != nil {
-		return nil, err
-	}
-	var rets *ir.Node
-	if s.Word.Lex == T.LEFTBRACKET {
-		rets, err = procTypeTypeList(s)
-		if err != nil {
-			return nil, err
-		}
-	} else { // sorry
-		t, err := _type(s)
-		if err != nil {
-			return nil, err
-		}
-		if t == nil {
-			rets = nil
-		} else {
-			rets = &ir.Node{
-				Lex:    T.TYPELIST,
-				Leaves: []*ir.Node{t},
-			}
-		}
-	}
-	keyword.Leaves = []*ir.Node{args, rets}
-	Track(s, "help")
-	return keyword, err
-}
-
-func procTypeTypeList(s *Lexer) (*ir.Node, *Error) {
-	Track(s, "procTypeTypeList")
-	var tps *ir.Node
-	_, err := Expect(s, T.LEFTBRACKET)
-	if err != nil {
-		return nil, err
-	}
-	if s.Word.Lex != T.RIGHTBRACKET {
-		tps, err = obligatoryTypeList(s)
-		if err != nil {
-			return nil, err
-		}
-	}
-	_, err = Expect(s, T.RIGHTBRACKET)
-	if err != nil {
-		return nil, err
-	}
-	return tps, nil
-}
-
-// Vars := 'var' DeclList.
-func procVars(s *Lexer) (*ir.Node, *Error) {
-	Track(s, "Var")
-	_, err := Expect(s, T.VAR)
-	if err != nil {
-		return nil, err
-	}
-	return ExpectProd(s, declList, "declaration")
-}
-
-// DeclList := Decl {',' Decl} [','].
-func declList(s *Lexer) (*ir.Node, *Error) {
-	Track(s, "DeclList")
-	nodes, err := RepeatCommaList(s, decl)
-	if err != nil {
-		return nil, err
-	}
-	if len(nodes) == 0 {
-		return nil, nil
-	}
-	return &ir.Node{
-		Lex:    T.PROCDECLS,
-		Leaves: nodes,
-	}, nil
-}
-
-// Decl := id [Annot].
-func decl(s *Lexer) (*ir.Node, *Error) {
-	Track(s, "Decl")
-	if s.Word.Lex != T.IDENTIFIER {
-		return nil, nil
-	}
-	id, err := Consume(s)
-	if err != nil {
-		return nil, err
-	}
-	if s.Word.Lex == T.COLON {
-		colon, err := annot(s)
-		if err != nil {
-			return nil, err
-		}
-		colon.Leaves = []*ir.Node{id, colon.Leaves[0]}
-		return colon, nil
-	}
-	return id, nil
-}
-
-func ident(s *Lexer) (*ir.Node, *Error) {
-	if s.Word.Lex == T.IDENTIFIER {
-		return Consume(s)
-	}
-	return nil, nil
-}
-
-func expectIdent(s *Lexer) (*ir.Node, *Error) {
-	return Expect(s, T.IDENTIFIER)
-}
-
-/*
-Code := If
-      | While
-      | Return
-      | Set
-      | Exit
-      | Expr.
-*/
-func code(s *Lexer) (*ir.Node, *Error) {
-	Track(s, "code")
-	switch s.Word.Lex {
-	case T.EOF:
-		return nil, nil
-	case T.IF:
-		return _if(s)
-	case T.WHILE:
-		return _while(s)
-	case T.RETURN:
-		return _return(s)
-	case T.SET:
-		return _set(s)
-	case T.EXIT:
-		return _exit(s)
-	default:
-		return expr(s)
-	}
-}
-
-// Set := 'set' ExprList '=' Expr.
-func _set(s *Lexer) (*ir.Node, *Error) {
-	Track(s, "Set")
-	kw, err := Expect(s, T.SET)
-	if err != nil {
-		return nil, err
-	}
-	ass, err := exprList(s)
-	if err != nil {
-		return nil, err
-	}
-	op, err := Expect(s, T.ASSIGNMENT, T.PLUS_ASSIGN, T.MINUS_ASSIGN,
-		T.MULTIPLICATION_ASSIGN, T.DIVISION_ASSIGN, T.REMAINDER_ASSIGN)
-	if err != nil {
-		return nil, err
-	}
-	exp, err := ExpectProd(s, expr, "expression")
-	if err != nil {
-		return nil, err
-	}
-	kw.Leaves = []*ir.Node{ass, op, exp}
-	return kw, nil
-}
-
-// ExprList := Expr {',' Expr} [','].
-func exprList(s *Lexer) (*ir.Node, *Error) {
-	asses, err := RepeatCommaList(s, expr)
-	if err != nil {
-		return nil, err
-	}
-	return &ir.Node{
-		Lex:    T.EXPRLIST,
-		Leaves: asses,
-	}, nil
-}
-
-// Return := 'return' [ExprList].
-func _return(s *Lexer) (*ir.Node, *Error) {
-	Track(s, "return")
-	kw, err := Consume(s)
-	if err != nil {
-		return nil, err
-	}
-	exp, err := RepeatCommaList(s, expr) // optional
-	if err != nil {
-		return nil, err
-	}
-	if exp != nil {
-		kw.Leaves = exp
-	}
-	return kw, err
-}
-
-// Exit := 'exit' Expr.
-func _exit(s *Lexer) (*ir.Node, *Error) {
-	Track(s, "exit")
-	kw, err := Consume(s)
-	if err != nil {
-		return nil, err
-	}
-	exp, err := ExpectProd(s, expr, "expression")
-	if err != nil {
-		return nil, err
-	}
-	kw.Leaves = []*ir.Node{exp}
-	return kw, err
-}
-
-// Expr = And {"or" And}.
-func expr(s *Lexer) (*ir.Node, *Error) {
-	Track(s, "Expr")
-	return RepeatBinary(s, boolAnd, "expression", orOp)
-}
-
-// And = Comp {"and" Comp}.
-func boolAnd(s *Lexer) (*ir.Node, *Error) {
-	Track(s, "And")
-	return RepeatBinary(s, comparative, "expression", andOp)
-}
-
-// Comp = Sum {compOp Sum}.
-func comparative(s *Lexer) (*ir.Node, *Error) {
-	Track(s, "Comp")
-	return RepeatBinary(s, additive, "expression", compOp)
-}
-
-// Sum = Mult {sumOp Mult}.
-func additive(s *Lexer) (*ir.Node, *Error) {
-	Track(s, "Sum")
-	return RepeatBinary(s, multiplicative, "expression", sumOp)
-}
-
-// Mult = Unary {multOp Unary}.
-func multiplicative(s *Lexer) (*ir.Node, *Error) {
-	Track(s, "Mult")
-	return RepeatBinary(s, unaryPrefix, "expression", multOp)
-}
-
-// Prefix = "not" | "~".
-// UnaryPrefix := {Prefix} UnarySuffix.
-func unaryPrefix(s *Lexer) (*ir.Node, *Error) {
-	Track(s, "unary prefix")
-
-	preFirst, preLast, err := RepeatUnaryLeft(s, prefixOp)
-	if err != nil {
-		return nil, err
-	}
-
-	suff, err := unarySuffix(s)
-	if err != nil {
-		return nil, err
-	}
-	if preFirst != nil && suff == nil {
-		msg := "expected expression after prefix operator"
-		err := NewCompilerError(s, et.ExpectedProd, msg)
-		return nil, err
-	}
-	if suff == nil {
-		return nil, nil
-	}
-
-	if preFirst != nil {
-		AddLeaf(preLast, suff)
-		suff = preFirst
-	}
-
-	return suff, nil
-}
-
-// UnarySuffix := Factor {Suffix}.
-func unarySuffix(s *Lexer) (*ir.Node, *Error) {
-	Track(s, "unary suffix")
-	fact, err := factor(s)
-	if err != nil {
-		return nil, err
-	}
-	suFirst, suLast, err := RepeatUnaryRight(s, suffix)
-	if err != nil {
-		return nil, err
-	}
-	if suFirst != nil {
-		AddLeaf(suFirst, fact)
-		fact = suLast
-	}
-	return fact, nil
-}
-
-/*
-Suffix  := Conversion
-	| Deref
-	| Call.
-*/
-func suffix(s *Lexer) (*ir.Node, *Error) {
-	Track(s, "suffix")
-	switch s.Word.Lex {
-	case T.LEFTBRACKET:
-		return call(s)
-	case T.AT:
-		return deref(s)
-	case T.COLON:
-		return annot(s)
-	case T.DOT:
-		return propertyAccess(s)
-	}
-	return nil, nil
-}
-
-// PropertyAccess := '.' id.
-func propertyAccess(s *Lexer) (*ir.Node, *Error) {
-	dot, err := Expect(s, T.DOT)
-	if err != nil {
-		return nil, err
-	}
-	id, err := Expect(s, T.IDENTIFIER)
-	if err != nil {
-		return nil, err
-	}
-	dot.Leaves = []*ir.Node{id}
-	return dot, err
-}
-
-// Deref := '@' Type.
-func deref(s *Lexer) (*ir.Node, *Error) {
-	Track(s, "deref")
-	at, err := Expect(s, T.AT)
-	if err != nil {
-		return nil, err
-	}
-	t, err := ExpectProd(s, _type, "type")
-	if err != nil {
-		return nil, err
-	}
-	at.Leaves = []*ir.Node{t}
-	return at, nil
-}
-
-// Call = "[" [ExprList] "]".
-func call(s *Lexer) (*ir.Node, *Error) {
-	Track(s, "call")
-	_, err := Expect(s, T.LEFTBRACKET)
-	if err != nil {
-		return nil, err
-	}
-
-	explist, err := exprList(s)
-	if err != nil {
-		return nil, err
-	}
-	if explist == nil {
-		explist = &ir.Node{
-			Lex:    T.EXPRLIST,
-			Leaves: []*ir.Node{},
-		}
-	}
-
-	_, err = Expect(s, T.RIGHTBRACKET)
-	if err != nil {
-		return nil, err
-	}
-	return &ir.Node{
-		Lex:    T.CALL,
-		Leaves: []*ir.Node{explist},
-	}, nil
-}
-
-// Annot = ":" Type.
-// Conversion = Annot.
-func annot(s *Lexer) (*ir.Node, *Error) {
-	Track(s, "annot")
-	colon, err := Expect(s, T.COLON)
-	if err != nil {
-		return nil, err
-	}
-	tp, err := ExpectProd(s, _type, "type")
-	if err != nil {
-		return nil, err
-	}
-	colon.Leaves = []*ir.Node{tp}
-	return colon, nil
-}
-
-/*
-Factor := Name
-	| Terminal
-	| NestedExpr.
-*/
-func factor(s *Lexer) (*ir.Node, *Error) {
-	Track(s, "factor")
-	switch s.Word.Lex {
-	case T.IDENTIFIER:
-		return name(s)
-	case T.LEFTPAREN:
-		_, err := Consume(s)
-		if err != nil {
-			return nil, err
-		}
-		n, err := expr(s)
-		if err != nil {
-			return nil, err
-		}
-		_, err = Expect(s, T.RIGHTPAREN)
-		if err != nil {
-			return nil, err
-		}
-		return n, nil
-	case T.I64_LIT, T.I32_LIT, T.I16_LIT, T.I8_LIT, T.CHAR_LIT,
-		T.TRUE, T.FALSE, T.PTR_LIT:
-		return Consume(s)
-	}
-	return nil, nil
-}
-
-func name(s *Lexer) (*ir.Node, *Error) {
-	id, err := Consume(s)
-	if err != nil {
-		return nil, err
-	}
-	if s.Word.Lex == T.DOUBLECOLON {
-		dcolon, err := Consume(s)
-		if err != nil {
-			return nil, err
-		}
-		id2, err := Consume(s)
-		if err != nil {
-			return nil, err
-		}
-		dcolon.Leaves = []*ir.Node{id, id2}
-		return dcolon, nil
-	}
-	return id, nil
-}
-
-// Block := 'begin' {CodeSemicolon} 'end'.
-func block(s *Lexer) (*ir.Node, *Error) {
-	Track(s, "block")
-	_, err := Expect(s, T.BEGIN)
-	if err != nil {
-		return nil, err
-	}
-	n, err := Repeat(s, codeSemicolon)
-	if err != nil {
-		return nil, err
-	}
-	_, err = Expect(s, T.END)
-	if err != nil {
-		return nil, err
-	}
-	return &ir.Node{
-		Leaves: n,
-		Lex:    T.BLOCK,
-	}, nil
-}
-
-// CodeSemicolon := Code [';'].
-func codeSemicolon(s *Lexer) (*ir.Node, *Error) {
-	Track(s, "CodeSemicolon")
-	n, err := code(s)
-	if err != nil {
-		return nil, err
-	}
-	if s.Word.Lex == T.SEMICOLON {
-		_, err := Consume(s)
-		if err != nil {
-			return nil, err
-		}
-	}
-	return n, nil
-}
-
-// If := 'if' Expr Block [Else] 'if'.
-func _if(s *Lexer) (*ir.Node, *Error) {
-	Track(s, "if")
-	keyword, err := Expect(s, T.IF)
-	var exp, bl, else_, elseif_ *ir.Node
-
-	exp, err = ExpectProd(s, expr, "expression")
-	if err != nil {
-		return nil, err
-	}
-
-	bl, err = ExpectProd(s, block, "block")
-	if err != nil {
-		return nil, err
-	}
-
-	if s.Word.Lex == T.ELSEIF {
-		elseif_, err = elseifchain(s)
-		if err != nil {
-			return nil, err
-		}
-	}
-
-	if s.Word.Lex == T.ELSE {
-		else_, err = _else(s)
-		if err != nil {
-			return nil, err
-		}
-	}
-	keyword.Leaves = []*ir.Node{exp, bl, elseif_, else_}
-	_, err = Expect(s, T.IF)
-	if err != nil {
-		return nil, err
-	}
-	return keyword, nil
-}
-
-// Else := 'else' Block.
-func _else(s *Lexer) (*ir.Node, *Error) {
-	Track(s, "else")
-	kw, err := Consume(s)
-	if err != nil {
-		return nil, err
-	}
-	bl, err := block(s)
-	if err != nil {
-		return nil, err
-	}
-	kw.Leaves = []*ir.Node{bl}
-	return kw, nil
-}
-
-func elseifchain(s *Lexer) (*ir.Node, *Error) {
-	elses, err := Repeat(s, _elseif)
-	if err != nil {
-		return nil, err
-	}
-	return &ir.Node{
-		Lex:    T.ELSEIFCHAIN,
-		Leaves: elses,
-	}, nil
-}
-
-func _elseif(s *Lexer) (*ir.Node, *Error) {
-	if s.Word.Lex != T.ELSEIF {
-		return nil, nil
-	}
-	kw, err := Consume(s)
-	if err != nil {
-		return nil, err
-	}
-	exp, err := ExpectProd(s, expr, "expression")
-	if err != nil {
-		return nil, err
-	}
-	bl, err := block(s)
-	if err != nil {
-		return nil, err
-	}
-	kw.Leaves = []*ir.Node{exp, bl}
-	return kw, nil
-}
-
-// While = 'while' Expr Block 'while'.
-func _while(s *Lexer) (*ir.Node, *Error) {
-	Track(s, "while")
-	keyword, err := Expect(s, T.WHILE)
-	if err != nil {
-		return nil, err
-	}
-	exp, err := ExpectProd(s, expr, "expression")
-	if err != nil {
-		return nil, err
-	}
-	bl, err := block(s)
-	if err != nil {
-		return nil, err
-	}
-	keyword.Leaves = []*ir.Node{exp, bl}
-	_, err = Expect(s, T.WHILE)
-	if err != nil {
-		return nil, err
-	}
-	return keyword, nil
-}
-
-func numberOrString(s *Lexer) (*ir.Node, *Error) {
-	return Expect(s, T.I64_LIT, T.I32_LIT, T.I16_LIT, T.I8_LIT, T.PTR_LIT, T.STRING_LIT)
-}
-
-func sumOp(n *ir.Node) bool {
-	switch n.Lex {
-	case T.PLUS, T.MINUS:
-		return true
-	}
-	return false
-}
-
-func multOp(n *ir.Node) bool {
-	switch n.Lex {
-	case T.MULTIPLICATION, T.DIVISION, T.REMAINDER:
-		return true
-	}
-	return false
-}
-
-func compOp(n *ir.Node) bool {
-	switch n.Lex {
-	case T.LESS, T.LESSEQ, T.EQUALS,
-		T.MOREEQ, T.MORE, T.DIFFERENT:
-		return true
-	}
-	return false
-}
-
-func orOp(n *ir.Node) bool {
-	return n.Lex == T.OR
-}
-
-func andOp(n *ir.Node) bool {
-	return n.Lex == T.AND
-}
-
-func prefixOp(st *Lexer) (*ir.Node, *Error) {
-	switch st.Word.Lex {
-	case T.NOT, T.NEG:
-		return Consume(st)
-	}
-	return nil, nil
-}
-
-func isComma(n *ir.Node) bool {
-	return n.Lex == T.COMMA
-}
diff --git a/frontend/resolver/resolver.go b/frontend/resolver/resolver.go
deleted file mode 100644
index 9f743d3..0000000
--- a/frontend/resolver/resolver.go
+++ /dev/null
@@ -1,278 +0,0 @@
-package resolver
-
-import (
-	"io/ioutil"
-	. "mpc/core"
-	et "mpc/core/errorkind"
-	ir "mpc/core/module"
-	T "mpc/core/module/lexkind"
-	"mpc/frontend/lexer"
-	msg "mpc/frontend/messages"
-	"mpc/frontend/parser"
-	"strings"
-)
-
-func Resolve(filePath string) (*ir.Module, *Error) {
-	name, err := extractName(filePath)
-	if err != nil {
-		return nil, err
-	}
-
-	s, ioerr := newState(filePath)
-	if ioerr != nil {
-		return nil, processFileError(ioerr)
-	}
-
-	m, err := resolveModule(s, name)
-	if err != nil {
-		return nil, err
-	}
-	err = checkDependencyCycles(m)
-	if err != nil {
-		return nil, err
-	}
-	return m, nil
-}
-
-type state struct {
-	Modules       map[string]*ir.Module
-	BaseFolder    string
-	FilesInFolder []string
-
-	RefNode   *ir.Node // for errors
-	RefModule *ir.Module
-}
-
-func newState(fullPath string) (*state, error) {
-	folder := getFolder(fullPath)
-	files, err := ioutil.ReadDir(folder)
-	if err != nil {
-		return nil, err
-	}
-	filenames := make([]string, len(files))
-	for i, file := range files {
-		filenames[i] = file.Name()
-	}
-	return &state{
-		Modules:       map[string]*ir.Module{},
-		BaseFolder:    folder,
-		FilesInFolder: filenames,
-	}, nil
-}
-
-func resolveModule(s *state, modID string) (*ir.Module, *Error) {
-	mod, ok := s.Modules[modID]
-	if ok {
-		return mod, nil
-	}
-	fileName, err := findFile(s, modID)
-	if err != nil {
-		return nil, err
-	}
-	n, err := openAndParse(s, fileName)
-	if err != nil {
-		return nil, err
-	}
-	mod = newModule(s.BaseFolder, modID, fileName, n)
-	s.Modules[modID] = mod
-
-	err = resolveDependencies(s, n.Leaves[0], mod)
-	if err != nil {
-		return nil, err
-	}
-	return mod, nil
-}
-
-func resolveDependencies(s *state, coupling *ir.Node, mod *ir.Module) *Error {
-	if coupling.Lex != T.COUPLINGS {
-		panic("resolver: resolveDependencies: bad node")
-	}
-	s.RefModule = mod
-	for _, n := range coupling.Leaves {
-		switch n.Lex {
-		case T.IMPORT:
-			err := multiImport(s, n, mod)
-			if err != nil {
-				return err
-			}
-		case T.FROM:
-			err := fromImport(s, n, mod)
-			if err != nil {
-				return err
-			}
-		case T.EXPORT:
-			// must run after the symbol resolution
-		}
-	}
-	return nil
-}
-
-func fromImport(s *state, n *ir.Node, dependentMod *ir.Module) *Error {
-	modID := n.Leaves[0].Text
-	s.RefNode = n.Leaves[0]
-
-	mod, err := resolveModule(s, modID)
-	if err != nil {
-		exc := Excerpt{
-			Location: place(n, dependentMod),
-			Message:  err.Debug,
-		}
-		err.Info = append(err.Info, exc)
-		return err
-	}
-	addDependency(dependentMod, mod, n)
-	return nil
-}
-
-func multiImport(s *state, n *ir.Node, dependentMod *ir.Module) *Error {
-	if n.Lex != T.IMPORT {
-		panic("resolver: singleImport: bad node")
-	}
-
-	for _, n := range n.Leaves {
-		s.RefNode = n
-
-		mod, err := resolveModule(s, n.Text)
-		if err != nil {
-			exc := Excerpt{
-				Location: place(n, dependentMod),
-				Message:  err.Debug,
-			}
-			err.Info = append(err.Info, exc)
-			return err
-		}
-
-		addDependency(dependentMod, mod, n)
-
-		if err != nil {
-			return err
-		}
-	}
-	return nil
-}
-
-func addDependency(parent *ir.Module, dependency *ir.Module, source *ir.Node) {
-	_, ok := parent.Dependencies[dependency.Name]
-	if ok {
-		panic("resolver: addDependency: what the fuck man")
-	}
-	parent.Dependencies[dependency.Name] = &ir.Dependency{M: dependency, Source: source}
-}
-
-func getFolder(fullpath string) string {
-	path := strings.Split(fullpath, "/")
-	if len(path) == 1 {
-		return ""
-	}
-	folder := strings.Join(path[:len(path)-1], "/")
-	return folder
-}
-
-func place(n *ir.Node, mod *ir.Module) *SourceLocation {
-	return &SourceLocation{
-		Line: n.Line, Col: n.Col,
-		File: mod.FullPath,
-	}
-}
-
-func extractName(filePath string) (string, *Error) {
-	path := strings.Split(filePath, "/")
-	name := strings.Split(path[len(path)-1], ".")
-	if lexer.IsValidIdentifier(name[0]) {
-		return name[0], nil
-	}
-	return "", &Error{
-		Type:  et.InvalidFileName,
-		Debug: filePath + " : " + name[0],
-	}
-}
-
-func invalidModuleName(filePath string) *Error {
-	return &Error{
-		Type:  et.InvalidFileName,
-		Debug: filePath,
-	}
-}
-
-func newModule(basePath, modID, filename string, root *ir.Node) *ir.Module {
-	return &ir.Module{
-		BasePath:     basePath,
-		Name:         modID,
-		FullPath:     basePath + "/" + filename,
-		Root:         root,
-		Dependencies: map[string]*ir.Dependency{},
-		Exported:     map[string]*ir.Symbol{},
-		Globals:      map[string]*ir.Symbol{},
-	}
-}
-
-func openAndParse(s *state, filename string) (*ir.Node, *Error) {
-	text, e := ioutil.ReadFile(s.BaseFolder + "/" + filename)
-	if e != nil {
-		return nil, processFileError(e)
-	}
-
-	n, err := parser.Parse(string(text))
-	if err != nil {
-		return nil, err
-	}
-	return n, nil
-}
-
-func findFile(s *state, modID string) (string, *Error) {
-	found := []string{}
-	for _, filename := range s.FilesInFolder {
-		if strings.HasPrefix(filename, modID+".") {
-			found = append(found, filename)
-		}
-	}
-	if len(found) > 1 {
-		return "", msg.AmbiguousFilesInFolder(s.RefModule, s.RefNode, found, modID)
-	}
-	if len(found) == 0 {
-		return "", msg.ModuleNotFound(s.RefModule, s.RefNode, s.BaseFolder, modID)
-	}
-	return found[0], nil
-}
-
-func processFileError(e error) *Error {
-	return &Error{
-		Type:  et.FileError,
-		Debug: e.Error(),
-	}
-}
-
-func checkDependencyCycles(M *ir.Module) *Error {
-	for _, dep := range M.Dependencies {
-		prev := []*ir.Dependency{}
-		err := checkDepCycle(M, dep, prev)
-		if err != nil {
-			return err
-		}
-	}
-	return nil
-}
-
-func checkDepCycle(M *ir.Module, d *ir.Dependency, prev []*ir.Dependency) *Error {
-	if depHasVisited(prev, d) {
-		return msg.ErrorInvalidDependencyCycle(M, prev, d)
-	}
-	prev = append(prev, d)
-	top := len(prev)
-	for _, dep := range d.M.Dependencies {
-		err := checkDepCycle(M, dep, prev[0:top])
-		if err != nil {
-			return err
-		}
-	}
-	return nil
-}
-
-func depHasVisited(visited []*ir.Dependency, b *ir.Dependency) bool {
-	for _, v := range visited {
-		if b.M == v.M {
-			return true
-		}
-	}
-	return false
-}
diff --git a/frontend/typechecker/typechecker.go b/frontend/typechecker/typechecker.go
deleted file mode 100644
index 6c1df09..0000000
--- a/frontend/typechecker/typechecker.go
+++ /dev/null
@@ -1,828 +0,0 @@
-package typechecker
-
-import (
-	. "mpc/core"
-	ir "mpc/core/module"
-	lex "mpc/core/module/lexkind"
-	ST "mpc/core/module/symbolkind"
-	T "mpc/core/types"
-	msg "mpc/frontend/messages"
-)
-
-func Check(M *ir.Module) *Error {
-	err := checkModule(M)
-	if err != nil {
-		return err
-	}
-	M.ResetVisited()
-	return checkMain(M) // only for first module
-}
-
-func checkModule(M *ir.Module) *Error {
-	M.Visited = true
-	for _, dep := range M.Dependencies {
-		err := checkModule(dep.M)
-		if err != nil {
-			return err
-		}
-	}
-
-	addBuiltins(M)
-	for _, sy := range M.Globals {
-		if !sy.External {
-			err := checkSymbol(M, sy)
-			if err != nil {
-				return err
-			}
-		}
-	}
-	for _, sy := range M.Globals {
-		if sy.T == ST.Proc && !sy.External {
-			err := checkBlock(M, sy.Proc, sy.N.Leaves[4])
-			if err != nil {
-				return err
-			}
-		}
-	}
-	return nil
-}
-
-func checkMain(M *ir.Module) *Error {
-	p, ok := M.Globals["main"]
-	if !ok {
-		return msg.ProgramWithoutEntry(M)
-	}
-	if p.Proc == nil || !T.IsProc(p.Type) || !T.T_MainProc.Equals(p.Type) {
-		return msg.InvalidMain(M, p)
-	}
-	return nil
-}
-
-func addBuiltins(M *ir.Module) {
-	w := &T.Type{Proc: &T.ProcType{Args: []*T.Type{T.T_Ptr, T.T_I64}, Rets: []*T.Type{}}}
-	r := &T.Type{Proc: &T.ProcType{Args: []*T.Type{T.T_Ptr, T.T_I64}, Rets: []*T.Type{T.T_I64}}}
-	write := &ir.Symbol{Name: "write", T: ST.Builtin, Type: w, Proc: nil}
-	error := &ir.Symbol{Name: "error", T: ST.Builtin, Type: w, Proc: nil}
-	read := &ir.Symbol{Name: "read", T: ST.Builtin, Type: r, Proc: nil}
-	M.Globals["write"] = write
-	M.Globals["read"] = read
-	M.Globals["error"] = error
-}
-
-func checkSymbol(M *ir.Module, sy *ir.Symbol) *Error {
-	switch sy.T {
-	case ST.Proc:
-		err := checkProc(M, sy.Proc)
-		if err != nil {
-			return err
-		}
-		sy.Type = sy.Proc.T
-	case ST.Mem:
-		err := checkMem(M, sy.Mem)
-		if err != nil {
-			return err
-		}
-		sy.Type = T.T_Ptr
-	}
-	return nil
-}
-
-func checkMem(M *ir.Module, mem *ir.Mem) *Error {
-	switch mem.Init.Lex {
-	case lex.STRING_LIT:
-		size := stringSize(mem.Init.Text)
-		mem.Size = int64(size)
-		mem.Contents = mem.Init.Text
-	case lex.I64_LIT, lex.I32_LIT, lex.I16_LIT, lex.I8_LIT:
-		mem.Size = mem.Init.Value
-	case lex.PTR_LIT:
-		return msg.ErrorPtrCantBeUsedAsMemSize(M, mem.Init)
-	}
-	return nil
-}
-
-func stringSize(oldtext string) int {
-	text := oldtext[1 : len(oldtext)-1]
-	size := 0
-	for i := 0; i < len(text); i++ {
-		if text[i] == '\\' {
-			i++
-		}
-		size += 1
-	}
-	return size
-}
-
-func checkProc(M *ir.Module, proc *ir.Proc) *Error {
-	nArgs := proc.N.Leaves[1]
-	nRets := proc.N.Leaves[2]
-	nVars := proc.N.Leaves[3]
-	var err *Error
-	var args, rets []*T.Type
-
-	if nArgs != nil {
-		args, err = checkProcArgs(M, proc, nArgs)
-		if err != nil {
-			return err
-		}
-	}
-
-	if nRets != nil {
-		rets = getProcRets(M, nRets)
-		proc.Rets = rets
-	}
-
-	if nVars != nil {
-		err := checkProcVars(M, proc, nVars)
-		if err != nil {
-			return err
-		}
-	}
-	t := &T.Type{Proc: &T.ProcType{Args: args, Rets: rets}}
-	proc.T = t
-	proc.N.T = t
-	return nil
-}
-
-func getProcRets(M *ir.Module, n *ir.Node) []*T.Type {
-	types := []*T.Type{}
-	for _, tNode := range n.Leaves {
-		t := getType(tNode)
-		types = append(types, t)
-		tNode.T = t
-	}
-	return types
-}
-
-func checkProcArgs(M *ir.Module, proc *ir.Proc, n *ir.Node) ([]*T.Type, *Error) {
-	tps := []*T.Type{}
-	for i, decl := range n.Leaves {
-		var d *ir.Symbol
-		if len(decl.Leaves) == 0 {
-			d = &ir.Symbol{
-				Name: decl.Text,
-				N:    decl,
-				T:    ST.Arg,
-				Type: T.T_I64,
-			}
-		} else if len(decl.Leaves) == 2 {
-			d = &ir.Symbol{
-				Name: decl.Leaves[0].Text,
-				N:    decl,
-				T:    ST.Arg,
-				Type: getType(decl.Leaves[1]),
-			}
-		}
-		err := verifyIfDefined(M, proc, d)
-		if err != nil {
-			return nil, err
-		}
-		decl.T = d.Type
-		tps = append(tps, d.Type)
-		proc.ArgMap[d.Name] = ir.PositionalSymbol{Position: i, Symbol: d}
-		proc.Args = append(proc.Args, d)
-	}
-	return tps, nil
-}
-
-func checkProcVars(M *ir.Module, proc *ir.Proc, n *ir.Node) *Error {
-	for i, decl := range n.Leaves {
-		var d *ir.Symbol
-		if len(decl.Leaves) == 0 {
-			d = &ir.Symbol{
-				Name: decl.Text,
-				N:    decl,
-				T:    ST.Var,
-				Type: T.T_I64,
-			}
-		} else if len(decl.Leaves) == 2 {
-			d = &ir.Symbol{
-				Name: decl.Leaves[0].Text,
-				N:    decl,
-				T:    ST.Var,
-				Type: getType(decl.Leaves[1]),
-			}
-		}
-		err := verifyIfDefined(M, proc, d)
-		if err != nil {
-			return err
-		}
-		decl.T = d.Type
-		proc.Vars[d.Name] = ir.PositionalSymbol{Position: i, Symbol: d}
-	}
-	return nil
-}
-
-func verifyIfDefined(M *ir.Module, proc *ir.Proc, d *ir.Symbol) *Error {
-	l := getVarOrArg(proc, d.Name)
-	if l != nil {
-		return msg.ErrorNameAlreadyDefined(M, d.N, l.N)
-	}
-	return nil
-}
-
-func getType(n *ir.Node) *T.Type {
-	switch n.Lex {
-	case lex.I8:
-		return T.T_I8
-	case lex.I16:
-		return T.T_I16
-	case lex.I32:
-		return T.T_I32
-	case lex.I64:
-		return T.T_I64
-	case lex.PTR:
-		return T.T_Ptr
-	case lex.BOOL:
-		return T.T_Bool
-	case lex.PROC:
-		return getProcType(n)
-	}
-	panic("getType: what: " + ir.FmtNode(n))
-}
-
-func getProcType(n *ir.Node) *T.Type {
-	args := n.Leaves[0].Leaves
-	argTypes := make([]*T.Type, len(args))
-	for i, arg := range args {
-		argTypes[i] = getType(arg)
-	}
-
-	retTypes := make([]*T.Type, 0)
-	if len(n.Leaves) > 1 && n.Leaves[1] != nil {
-		rets := n.Leaves[1].Leaves
-		retTypes = make([]*T.Type, len(rets))
-		for i, ret := range rets {
-			retTypes[i] = getType(ret)
-		}
-	}
-
-	return &T.Type{
-		Proc: &T.ProcType{
-			Args: argTypes,
-			Rets: retTypes,
-		},
-	}
-}
-
-func checkBlock(M *ir.Module, proc *ir.Proc, n *ir.Node) *Error {
-	for _, code := range n.Leaves {
-		err := checkStatement(M, proc, code)
-		if err != nil {
-			return err
-		}
-	}
-	return nil
-}
-
-func checkStatement(M *ir.Module, proc *ir.Proc, n *ir.Node) *Error {
-	switch n.Lex {
-	case lex.EOF:
-		return nil
-	case lex.IF:
-		return checkIf(M, proc, n)
-	case lex.WHILE:
-		return checkWhile(M, proc, n)
-	case lex.RETURN:
-		return checkReturn(M, proc, n)
-	case lex.SET:
-		return checkAssignment(M, proc, n)
-	case lex.EXIT:
-		return checkExit(M, proc, n)
-	default:
-		return checkExpr(M, proc, n)
-	}
-}
-
-func checkIf(M *ir.Module, proc *ir.Proc, n *ir.Node) *Error {
-	exp := n.Leaves[0]
-	block := n.Leaves[1]
-	elseifchain := n.Leaves[2]
-	else_ := n.Leaves[3]
-
-	err := checkExpr(M, proc, exp)
-	if err != nil {
-		return err
-	}
-
-	err = checkExprType(M, exp)
-	if err != nil {
-		return err
-	}
-
-	err = checkBlock(M, proc, block)
-	if err != nil {
-		return err
-	}
-
-	if elseifchain != nil {
-		err = checkElseIfChain(M, proc, elseifchain)
-		if err != nil {
-			return err
-		}
-	}
-
-	if else_ != nil {
-		err = checkElse(M, proc, else_)
-		if err != nil {
-			return err
-		}
-	}
-
-	return nil
-}
-
-func checkElse(M *ir.Module, proc *ir.Proc, n *ir.Node) *Error {
-	err := checkBlock(M, proc, n.Leaves[0])
-	if err != nil {
-		return err
-	}
-	return nil
-}
-
-func checkElseIfChain(M *ir.Module, proc *ir.Proc, n *ir.Node) *Error {
-	for _, elseif := range n.Leaves {
-		err := checkElseIf(M, proc, elseif)
-		if err != nil {
-			return err
-		}
-	}
-	return nil
-}
-
-func checkElseIf(M *ir.Module, proc *ir.Proc, n *ir.Node) *Error {
-	err := checkExpr(M, proc, n.Leaves[0])
-	if err != nil {
-		return err
-	}
-
-	err = checkExprType(M, n.Leaves[0])
-	if err != nil {
-		return err
-	}
-
-	err = checkBlock(M, proc, n.Leaves[1])
-	if err != nil {
-		return err
-	}
-	return nil
-}
-
-func checkWhile(M *ir.Module, proc *ir.Proc, n *ir.Node) *Error {
-	err := checkExpr(M, proc, n.Leaves[0])
-	if err != nil {
-		return err
-	}
-
-	err = checkExprType(M, n.Leaves[0])
-	if err != nil {
-		return err
-	}
-
-	err = checkBlock(M, proc, n.Leaves[1])
-	if err != nil {
-		return err
-	}
-	return nil
-}
-
-func checkReturn(M *ir.Module, proc *ir.Proc, n *ir.Node) *Error {
-	for i, ret := range n.Leaves {
-		if i >= len(proc.Rets) {
-			return msg.ErrorInvalidNumberOfReturns(M, proc, ret)
-		}
-		err := checkExpr(M, proc, ret)
-		if err != nil {
-			return err
-		}
-		if !ret.T.Equals(proc.Rets[i]) {
-			return msg.ErrorUnmatchingReturns(M, proc, ret, i)
-		}
-	}
-	return nil
-}
-
-func checkExit(M *ir.Module, proc *ir.Proc, n *ir.Node) *Error {
-	exp := n.Leaves[0]
-	err := checkExpr(M, proc, exp)
-	if err != nil {
-		return err
-	}
-	if !exp.T.Equals(T.T_I8) {
-		return msg.ExitMustBeI8(M, exp)
-	}
-	n.T = T.T_Void
-	return nil
-}
-
-func checkAssignment(M *ir.Module, proc *ir.Proc, n *ir.Node) *Error {
-	left := n.Leaves[0]
-	op := n.Leaves[1]
-	right := n.Leaves[2]
-
-	err := checkAssignees(M, proc, left)
-	if err != nil {
-		return err
-	}
-
-	err = checkExpr(M, proc, right)
-	if err != nil {
-		return err
-	}
-
-	if (T.IsMultiRet(right.T) || len(left.Leaves) > 1) &&
-		op.Lex != lex.ASSIGNMENT {
-		return msg.ErrorCanOnlyUseNormalAssignment(M, op)
-	}
-
-	if !T.IsMultiRet(right.T) && len(left.Leaves) > 1 ||
-		T.IsMultiRet(right.T) && len(left.Leaves) == 1 {
-		return msg.ErrorMismatchedAssignment(M, n)
-	}
-
-	if T.IsVoid(right.T) {
-		return msg.ErrorCannotUseVoid(M, right)
-	}
-
-	if T.IsMultiRet(right.T) {
-		err := checkMultiAssignment(M, left, right)
-		if err != nil {
-			return err
-		}
-	} else {
-		if !left.Leaves[0].T.Equals(right.T) {
-			return msg.ErrorMismatchedTypesInAssignment(M, left.Leaves[0], right)
-		}
-		if op.Lex != lex.ASSIGNMENT && !T.IsNumber(left.Leaves[0].T) {
-			return msg.ExpectedNumber(M, op, left.T)
-		}
-	}
-
-	return nil
-}
-
-func checkExprList(M *ir.Module, proc *ir.Proc, n *ir.Node) *Error {
-	for _, exp := range n.Leaves {
-		err := checkExpr(M, proc, exp)
-		if err != nil {
-			return err
-		}
-		if T.IsVoid(exp.T) {
-			return msg.ErrorCannotUseVoid(M, exp.Leaves[1])
-		}
-	}
-	return nil
-}
-
-func checkAssignees(M *ir.Module, proc *ir.Proc, left *ir.Node) *Error {
-	for _, assignee := range left.Leaves {
-		switch assignee.Lex {
-		case lex.IDENTIFIER:
-			err := checkIdAssignee(M, proc, assignee)
-			if err != nil {
-				return err
-			}
-		case lex.AT:
-			err := checkDeref(M, proc, assignee)
-			if err != nil {
-				return err
-			}
-		default:
-			return msg.ErrorNotAssignable(M, assignee)
-		}
-	}
-	return nil
-}
-
-func checkIdAssignee(M *ir.Module, proc *ir.Proc, assignee *ir.Node) *Error {
-	d := getVarOrArg(proc, assignee.Text)
-	if d != nil {
-		assignee.T = d.Type
-		return nil
-	}
-	global, ok := M.Globals[assignee.Text]
-	if ok {
-		return msg.ErrorCannotAssignGlobal(M, global, assignee)
-	}
-	return msg.ErrorNameNotDefined(M, assignee)
-}
-
-func getVarOrArg(proc *ir.Proc, name string) *ir.Symbol {
-	posSy, ok := proc.ArgMap[name]
-	if ok {
-		return posSy.Symbol
-	}
-	def, ok := proc.Vars[name]
-	if ok {
-		return def.Symbol
-	}
-	return nil
-}
-
-func checkMultiAssignment(M *ir.Module, left *ir.Node, n *ir.Node) *Error {
-	procName := n.Leaves[1].Text
-	proc := M.GetSymbol(procName)
-	if len(proc.Proc.Rets) != len(left.Leaves) {
-		return msg.ErrorMismatchedMultiRetAssignment(M, proc, n.Leaves[1], left)
-	}
-	for i, assignee := range left.Leaves {
-		if !assignee.T.Equals(proc.Proc.Rets[i]) {
-			return msg.ErrorMismatchedTypesInMultiAssignment(M, proc, left, i)
-		}
-	}
-	return nil
-}
-
-func checkExpr(M *ir.Module, proc *ir.Proc, n *ir.Node) *Error {
-	switch n.Lex {
-	case lex.IDENTIFIER:
-		return checkID(M, proc, n)
-	case lex.DOUBLECOLON:
-		return checkExternalID(M, proc, n)
-	case lex.I64_LIT, lex.I32_LIT, lex.I16_LIT, lex.I8_LIT,
-		lex.FALSE, lex.TRUE, lex.PTR_LIT, lex.STRING_LIT,
-		lex.CHAR_LIT:
-		n.T = termToType(n.Lex)
-		return nil
-	case lex.NEG:
-		return unaryOp(M, proc, n, number, outSame)
-	case lex.PLUS, lex.MINUS, lex.MULTIPLICATION, lex.DIVISION, lex.REMAINDER:
-		return binaryOp(M, proc, n, number, outSame)
-	case lex.EQUALS, lex.DIFFERENT,
-		lex.MORE, lex.MOREEQ, lex.LESS, lex.LESSEQ:
-		return binaryOp(M, proc, n, basic, outBool)
-	case lex.AND, lex.OR:
-		return binaryOp(M, proc, n, _bool, outBool)
-	case lex.COLON:
-		return conversion(M, proc, n)
-	case lex.CALL:
-		return checkCall(M, proc, n)
-	case lex.AT:
-		return checkDeref(M, proc, n)
-	case lex.NOT:
-		return unaryOp(M, proc, n, _bool, outBool)
-	case lex.DOT:
-		return propertyAccess(M, proc, n)
-	}
-	return nil
-}
-
-func conversion(M *ir.Module, proc *ir.Proc, n *ir.Node) *Error {
-	err := checkExpr(M, proc, n.Leaves[1])
-	if err != nil {
-		return err
-	}
-	n.T = getType(n.Leaves[0])
-	if !T.IsBasic(n.T) {
-		return msg.ErrorExpectedBasicType(M, n)
-	}
-	n.Leaves[0].T = n.T
-	return nil
-}
-
-func checkCall(M *ir.Module, proc *ir.Proc, n *ir.Node) *Error {
-	callee := n.Leaves[1]
-	err := checkExpr(M, proc, callee)
-	if err != nil {
-		return err
-	}
-	if !T.IsProc(callee.T) {
-		return msg.ErrorExpectedProcedure(M, callee)
-	}
-	return checkCallProc(M, proc, n)
-}
-
-func checkCallProc(M *ir.Module, proc *ir.Proc, n *ir.Node) *Error {
-	callee := n.Leaves[1].T.Proc
-	exprs := n.Leaves[0]
-	if len(exprs.Leaves) != len(callee.Args) {
-		return msg.ErrorInvalidNumberOfArgs(M, callee, n)
-	}
-	for i, param := range exprs.Leaves {
-		err := checkExpr(M, proc, param)
-		if err != nil {
-			return err
-		}
-		if !param.T.Equals(callee.Args[i]) {
-			return msg.ErrorMismatchedTypeForArgument(M, param, callee.Args[i])
-		}
-	}
-	if len(callee.Rets) == 1 {
-		n.T = callee.Rets[0]
-	} else if len(callee.Rets) == 0 {
-		n.T = T.T_Void
-	} else {
-		n.T = T.T_MultiRet
-	}
-	return nil
-}
-
-func checkExternalID(M *ir.Module, proc *ir.Proc, dcolon *ir.Node) *Error {
-	mod := dcolon.Leaves[0].Text
-	id := dcolon.Leaves[1].Text
-
-	dep, ok := M.Dependencies[mod]
-	if !ok {
-		return msg.ErrorNameNotDefined(M, dcolon.Leaves[0])
-	}
-
-	sy, ok := dep.M.Exported[id]
-	if !ok {
-		return msg.NameNotExported(M, dcolon.Leaves[1])
-	}
-
-	dcolon.Leaves[1].T = sy.Type
-	dcolon.T = sy.Type
-	return nil
-}
-
-func checkID(M *ir.Module, proc *ir.Proc, id *ir.Node) *Error {
-	local := getVarOrArg(proc, id.Text)
-	if local != nil {
-		id.T = local.Type
-		return nil
-	}
-	global, ok := M.Globals[id.Text]
-	if ok {
-		id.T = global.Type
-		if global.External {
-			id.T = global.N.T
-		}
-		return nil
-	}
-	return msg.ErrorNameNotDefined(M, id)
-}
-
-func termToType(tp lex.LexKind) *T.Type {
-	switch tp {
-	case lex.I64_LIT:
-		return T.T_I64
-	case lex.I32_LIT:
-		return T.T_I32
-	case lex.I16_LIT:
-		return T.T_I16
-	case lex.I8_LIT:
-		return T.T_I8
-	case lex.CHAR_LIT:
-		return T.T_I8
-	case lex.STRING_LIT:
-		return T.T_Ptr
-	case lex.TRUE:
-		return T.T_Bool
-	case lex.FALSE:
-		return T.T_Bool
-	case lex.PTR_LIT:
-		return T.T_Ptr
-	}
-	panic("termToType: invalid type")
-}
-
-type deriver func(types ...*T.Type) *T.Type
-
-func outSame(a ...*T.Type) *T.Type {
-	// a homogeneous, all items must be of the same type
-	return a[0]
-}
-
-func outBool(a ...*T.Type) *T.Type {
-	return T.T_Bool
-}
-
-type class struct {
-	Description string
-	Checker     func(t *T.Type) bool
-}
-
-var basic = class{
-	Description: "i8, i16, i32, i64, bool or ptr",
-	Checker:     T.IsBasic,
-}
-
-var _bool = class{
-	Description: "bool",
-	Checker:     T.IsBool,
-}
-
-var number = class{
-	Description: "i8, i16, i32, i64 or ptr",
-	Checker:     T.IsNumber,
-}
-
-var ptr = class{
-	Description: "ptr",
-	Checker:     T.IsPtr,
-}
-
-// a op b where type(a) = type(b) and type(a op b) = deriver(type(a), type(b))
-// and both type(a), type(b) is of the class specified
-func binaryOp(M *ir.Module, proc *ir.Proc, op *ir.Node, c class, der deriver) *Error {
-	if len(op.Leaves) != 2 {
-		panic(M.Name + ": internal error, binary operator should have two leaves")
-	}
-	left := op.Leaves[0]
-	err := checkExpr(M, proc, left)
-	if err != nil {
-		return err
-	}
-	right := op.Leaves[1]
-	err = checkExpr(M, proc, right)
-	if err != nil {
-		return err
-	}
-
-	err = checkExprType(M, left)
-	if err != nil {
-		return err
-	}
-
-	err = checkExprType(M, right)
-	if err != nil {
-		return err
-	}
-
-	if !c.Checker(left.T) {
-		return msg.ErrorInvalidClassForExpr(M, left, c.Description)
-	}
-
-	if !c.Checker(right.T) {
-		return msg.ErrorInvalidClassForExpr(M, right, c.Description)
-	}
-
-	if !left.T.Equals(right.T) {
-		return msg.ErrorOperationBetweenUnequalTypes(M, op)
-	}
-
-	op.T = der(left.T, right.T)
-	return nil
-}
-
-func checkExprType(M *ir.Module, n *ir.Node) *Error {
-	if T.IsMultiRet(n.T) {
-		return msg.ErrorCannotUseMultipleValuesInExpr(M, n)
-	}
-	if T.IsVoid(n.T) {
-		return msg.ErrorCannotUseVoid(M, n)
-	}
-	if T.IsInvalid(n.T) {
-		return msg.ErrorInvalidType(M, n)
-	}
-	return nil
-}
-
-// op a where type(op a) = deriver(type(a))
-// and type(a) is of the class specified
-func unaryOp(M *ir.Module, proc *ir.Proc, op *ir.Node, c class, der deriver) *Error {
-	if len(op.Leaves) != 1 {
-		panic(M.Name + ": internal error, unary operator should have one leaf")
-	}
-	operand := op.Leaves[0]
-	err := checkExpr(M, proc, operand)
-	if err != nil {
-		return err
-	}
-	err = checkExprType(M, operand)
-	if err != nil {
-		return err
-	}
-
-	if !c.Checker(operand.T) {
-		return msg.ErrorInvalidClassForExpr(M, operand, c.Description)
-	}
-
-	op.T = der(operand.T)
-	return nil
-}
-
-func checkDeref(M *ir.Module, proc *ir.Proc, n *ir.Node) *Error {
-	exp := n.Leaves[1]
-	t := n.Leaves[0]
-	t.T = getType(t)
-	n.T = t.T
-
-	err := checkExpr(M, proc, exp)
-	if err != nil {
-		return err
-	}
-	if !T.IsPtr(exp.T) {
-		return msg.ErrorBadDeref(M, n, exp.T)
-	}
-	return nil
-}
-
-func propertyAccess(M *ir.Module, proc *ir.Proc, n *ir.Node) *Error {
-	mem := n.Leaves[1]
-	prop := n.Leaves[0]
-	sy := M.GetSymbol(mem.Text)
-	if mem.Lex != lex.IDENTIFIER || sy == nil || sy.Mem == nil {
-		return msg.ErrorExpectedMem(M, mem)
-	}
-	if prop.Lex != lex.IDENTIFIER || isInvalidProp(prop.Text) {
-		return msg.ErrorInvalidProp(M, mem)
-	}
-	n.T = T.T_I64
-	return nil
-}
-
-func isInvalidProp(text string) bool {
-	return text != "size"
-}
diff --git a/go.mod b/go.mod
deleted file mode 100644
index 74ed139..0000000
--- a/go.mod
+++ /dev/null
@@ -1,3 +0,0 @@
-module mpc
-
-go 1.18
diff --git a/main.go b/main.go
deleted file mode 100644
index c248d43..0000000
--- a/main.go
+++ /dev/null
@@ -1,169 +0,0 @@
-package main
-
-import (
-	"flag"
-	"mpc/backend"
-	mod "mpc/core/module"
-	"mpc/frontend"
-	"mpc/testing"
-	. "mpc/util"
-	"os"
-	"strconv"
-)
-
-var lexOnly = flag.Bool("lex", false, "runs the lexer and prints the tokens")
-var parseOnly = flag.Bool("parse", false, "runs the lexer and parser, prints AST output")
-var hirOnly = flag.Bool("hir", false, "runs the full frontend, prints hir")
-var mirOnly = flag.Bool("mir", false, "runs the full compiler, prints mir")
-var asmOnly = flag.Bool("asm", false, "runs the full compiler, prints asm")
-
-var test = flag.Bool("test", false, "runs tests for all files in a folder,"+
-	" you can specify the stage to test using the other flags\n"+
-	"\t ex: mpc -lex   -test folder/\n"+
-	"\t     mpc -parse -test folder/")
-
-var verbose = flag.Bool("v", false, "verbose tests")
-
-func main() {
-	flag.Parse()
-	args := flag.Args()
-	if len(args) != 1 {
-		Fatal("invalid number of arguments\n")
-	}
-	eval(args[0])
-}
-
-func eval(s string) {
-	checkValid()
-	if *test {
-		res := Test(s, testingMode())
-		printResults(res)
-		return
-	}
-	normalMode(s)
-}
-
-func testingMode() testing.Tester {
-	switch true {
-	case *lexOnly:
-		return testing.Lex
-	case *parseOnly:
-		return testing.Parse
-	case *hirOnly:
-		return testing.Hir
-	case *mirOnly:
-		return testing.Mir
-	case *asmOnly:
-		return testing.Mir
-	default:
-		return testing.All
-	}
-}
-
-func normalMode(s string) {
-	switch true {
-	case *lexOnly:
-		lexemes, err := frontend.Lex(s)
-		OkOrBurst(err)
-		for _, lexeme := range lexemes {
-			Stdout(lexeme.String())
-			Stdout("\n")
-		}
-	case *parseOnly:
-		n, err := frontend.Parse(s)
-		Stdout("\n-----AST\n")
-		Stdout(mod.FmtNode(n))
-		Stdout("\n")
-		OkOrBurst(err)
-	case *hirOnly:
-		hirP, err := frontend.All(s)
-		Stdout("\n-----HIR\n")
-		Stdout(hirP.String())
-		Stdout("\n")
-		OkOrBurst(err)
-
-	case *mirOnly:
-		hirP, err := frontend.All(s)
-		Stdout("\n-----HIR\n")
-		Stdout(hirP.String())
-		OkOrBurst(err)
-
-		mirP, err := backend.Mir(hirP)
-		Stdout("\n-----MIR\n")
-		Stdout(mirP.String())
-		OkOrBurst(err)
-	case *asmOnly:
-		m, err := frontend.All(s)
-		OkOrBurst(err)
-		s, err = backend.Generate(m)
-		OkOrBurst(err)
-		Stdout(s)
-	default:
-		m, err := frontend.All(s)
-		OkOrBurst(err)
-		s, err = backend.Generate(m)
-		OkOrBurst(err)
-		e := Fasm(s, m.Name)
-		if e != nil {
-			Fatal(e.Error())
-		}
-	}
-}
-
-func checkValid() {
-	var selected = []bool{*lexOnly, *parseOnly, *hirOnly, *mirOnly, *asmOnly}
-	var count = 0
-	for _, b := range selected {
-		if b {
-			count++
-		}
-	}
-	if count > 1 {
-		Fatal("only one of lex, parse, hir, mir or asm flags may be used at a time")
-	}
-}
-
-func printResults(results []*testing.TestResult) {
-	failed := 0
-	Stdout("\n")
-	for _, res := range results {
-		if !res.Ok && res.Message != "" {
-			Stdout(res.File + "\t" + res.Message + "\n")
-		}
-		if !res.Ok {
-			failed += 1
-		}
-	}
-	Stdout("\n")
-	Stdout("failed: " + strconv.Itoa(failed) + "\n")
-	Stdout("total: " + strconv.Itoa(len(results)) + "\n")
-}
-
-func Test(folder string, tester testing.Tester) []*testing.TestResult {
-	entries, err := os.ReadDir(folder)
-	if err != nil {
-		Fatal(err.Error() + "\n")
-	}
-	results := []*testing.TestResult{}
-	for _, v := range entries {
-		fullpath := folder + "/" + v.Name()
-		if v.IsDir() {
-			if *verbose {
-				Stdout("\u001b[35m entering: " + fullpath + "\u001b[0m\n")
-			}
-			res := Test(fullpath, tester)
-			results = append(results, res...)
-			if *verbose {
-				Stdout("\u001b[35m leaving: " + fullpath + "\u001b[0m\n")
-			}
-		} else {
-			res := tester(fullpath)
-			results = append(results, &res)
-			if *verbose {
-				Stdout("testing: " + fullpath + "\t")
-				Stdout(res.String() + "\n")
-			}
-		}
-	}
-	return results
-}
diff --git a/test b/test
deleted file mode 100755
index 888e13f..0000000
--- a/test
+++ /dev/null
@@ -1,6 +0,0 @@
-#!/bin/bash
-
-for i in {0..100}
-do
-  go run . -test test_suite
-done
diff --git a/testing/testing.go b/testing/testing.go
deleted file mode 100644
index d499569..0000000
--- a/testing/testing.go
+++ /dev/null
@@ -1,191 +0,0 @@
-package testing
-
-import (
-	"strings"
-
-	"mpc/backend"
-	. "mpc/core"
-	et "mpc/core/errorkind"
-	"mpc/frontend"
-	lexer "mpc/frontend/lexer"
-	parser "mpc/frontend/parser"
-	. "mpc/util"
-
-	"fmt"
-	"os"
-)
-
-// files are tested by running them and
-// seeing if they exit normally
-//
-// the test data is located directly in the name
-// of the file:
-// 	module_name.E001.mp
-// 	            ^ error code
-// 	module_name.mp
-// 	           ^ no error code (file must exit normally)
-
-type TestResult struct {
-	File    string
-	Message string
-	Ok      bool
-}
-
-func (res *TestResult) String() string {
-	if res.Ok {
-		return "\u001b[34mok\u001b[0m"
-	}
-	return "\u001b[31mfail\u001b[0m"
-}
-
-func Lex(file string) TestResult {
-	defer recoverIfFatal()
-	expectedErr := extractError(file)
-	s := ReadOrBurst(file)
-	st := lexer.NewLexer(s)
-	_, err := lexer.ReadAll(st)
-	return compareError(file, err, expectedErr)
-}
-
-func Parse(file string) TestResult {
-	defer recoverIfFatal()
-	expectedErr := extractError(file)
-	s := ReadOrBurst(file)
-	_, err := parser.Parse(s)
-	return compareError(file, err, expectedErr)
-}
-
-func Hir(file string) TestResult {
-	defer recoverIfFatal()
-	expectedErr := extractError(file)
-	_, err := frontend.All(file)
-	return compareError(file, err, expectedErr)
-}
-
-func Mir(file string) TestResult {
-	defer recoverIfFatal()
-	expectedErr := extractError(file)
-	M, err := frontend.All(file)
-	if err != nil {
-		if err.Type == et.InternalCompilerError {
-			return TestResult{
-				File:    file,
-				Ok:      false,
-				Message: err.Debug,
-			}
-		}
-		return compareError(file, err, expectedErr)
-	}
-	_, err = backend.Mir(M)
-	if err != nil {
-		return TestResult{
-			File:    file,
-			Ok:      false,
-			Message: err.Debug,
-		}
-	}
-	return Hir(file)
-}
-
-const testfilename = "./dont_use_this_name_EACDEFG1234"
-
-func All(file string) TestResult {
-	defer recoverIfFatal()
-	expectedErr := extractError(file)
-	M, err := frontend.All(file)
-	if err != nil {
-		if err.Type == et.InternalCompilerError {
-			return TestResult{
-				File:    file,
-				Ok:      false,
-				Message: err.Debug,
-			}
-		}
-		return compareError(file, err, expectedErr)
-	}
-
-	s, err := backend.Generate(M)
-	if err != nil {
-		return TestResult{
-			File:    file,
-			Ok:      false,
-			Message: err.Debug,
-		}
-	}
-	oserror := Fasm(s, testfilename)
-	if oserror != nil {
-		return newResult(file, oserror)
-	}
-	defer os.Remove(testfilename)
-
-	oserror = ExecWithTimeout(testfilename)
-	if oserror != nil {
-		return newResult(file, oserror)
-	}
-	return TestResult{
-		File: file,
-		Ok:   true,
-	}
-}
-
-func recoverIfFatal() {
-	if r := recover(); r != nil {
-		fmt.Printf("\u001b[31m fatal error: %v\t\u001b[0m", r)
-	}
-}
-
-type Tester func(file string) TestResult
-
-func extractError(file string) string {
-	pathlist := strings.Split(file, "/")
-	name := pathlist[len(pathlist)-1]
-	sections := strings.Split(name, ".")
-	if len(sections) < 3 {
-		return ""
-	}
-	err := sections[len(sections)-2]
-	return err
-}
-
-func compareError(file string, err *Error, expectedErr string) TestResult {
-	if err != nil && expectedErr == "" {
-		msg := "expected no errors, instead found: " +
-			err.ErrCode()
-		return TestResult{
-			File:    file,
-			Message: msg,
-			Ok:      false,
-		}
-	} else if err == nil && expectedErr != "" {
-		msg := "expected error " + expectedErr +
-			", instead found nothing"
-		return TestResult{
-			File:    file,
-			Message: msg,
-			Ok:      false,
-		}
-	} else if err != nil && expectedErr != "" {
-		actual := err.ErrCode()
-		if actual != expectedErr {
-			msg := "expected error " + expectedErr +
-				", instead found " + actual
-			return TestResult{
-				File:    file,
-				Message: msg,
-				Ok:      false,
-			}
-		}
-	}
-	return TestResult{
-		File: file,
-		Ok:   true,
-	}
-}
-
-func newResult(file string, e error) TestResult {
-	return TestResult{
-		File:    file,
-		Ok:      false,
-		Message: e.Error(),
-	}
-}
diff --git a/util/util.go b/util/util.go
deleted file mode 100644
index 5403793..0000000
--- a/util/util.go
+++ /dev/null
@@ -1,63 +0,0 @@
-package util
-
-import (
-	"io/ioutil"
-	. "mpc/core"
-	"os"
-	"os/exec"
-	"time"
-)
-
-func ReadOrBurst(file string) string {
-	text, e := ioutil.ReadFile(file)
-	if e != nil {
-		Fatal(e.Error())
-	}
-	return string(text)
-}
-
-func OkOrBurst(e *Error) {
-	if e != nil {
-		Fatal(e.String())
-	}
-}
-
-func Stdout(s string) {
-	os.Stdout.Write([]byte(s))
-}
-
-func Fatal(s string) {
-	os.Stderr.Write([]byte(s))
-	os.Exit(0)
-}
-
-func Fasm(s string, name string) error {
-	f, oserr := os.CreateTemp("", "mpc_*")
-	if oserr != nil {
-		return oserr
-	}
-	defer os.Remove(f.Name())
-	_, oserr = f.WriteString(s)
-	if oserr != nil {
-		return oserr
-	}
-	cmd := exec.Command("fasm", f.Name(), name)
-	_, oserr = cmd.Output()
-	if oserr != nil {
-		return oserr
-	}
-	return nil
-}
-
-func ExecWithTimeout(cmdstr string) error {
-	cmd := exec.Command(cmdstr)
-	if err := cmd.Start(); err != nil {
-		return err
-	}
-	timer := time.AfterFunc(1*time.Second, func() {
-		cmd.Process.Kill()
-	})
-	err := cmd.Wait()
-	timer.Stop()
-	return err
-}
