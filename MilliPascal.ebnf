-- Lexer:
type := i8|i16|i32|i64|bool|ptr.
id := [a-zA-Z_][a-zA-Z0-9_]*.
int := [0-9]+.

true := 'true'.
false := 'false'.

keywords := var|proc|begin|end
	  |while|if|else|elseif
          |or|and|not|memory
          |i8|i16|i32|i64|bool|ptr
          |true|false|syscall.
operators := , | : | \( | \) | \[ | \] | = | == | != | > | >= | < | <= | + | - | * | / | %.


-- Parser:
Module := {Symbol}.
Symbol := Procedure
	| Memory.

Memory := 'memory' id int.

Procedure := 'proc' id [Args [Rets]] [Vars] Block 'proc'.
Args := '(' [DeclList] ')'.
Vars := 'var' DeclList.
Rets := type {',' type} [','].

DeclList := Decl {',' Decl} [','].
Decl := id [':' type].

Code := If
      | While
      | Return
      | Set
      | Expr.

Block := 'begin' {CodeSemicolon} 'end'.

CodeSemicolon := Code [';'].

While := 'while' Expr Block 'while'.

If   := 'if' Expr Block {ElseIf} [Else] 'if'.
ElseIf := 'elseif' Expr Block.
Else := 'else' Block

Set := 'set' Assignees '=' ExprList.
Assignees := Assignee {',' Assignee} [','].
Assignee := id [Indexing].

Return := 'return' ExprList.

ExprList := Expr {',' Expr} [','].
Expr := And {'or' And}.
And := Comp {'and' Comp}.
Comp := Sum {compOp Sum}.
compOp := '==' | '!=' | '>' | '>=' | '<' | '<='.
Sum := Mult {sumOp Mult}.
sumOp := '+' | '-'.
Mult := UnaryPrefix {multOp UnaryPrefix}.
multOp := '*' | '/' | '%'.
UnaryPrefix := {Prefix} UnarySuffix.
UnarySuffix := Factor {Suffix}.

Prefix := 'not' | '+' | '-'.
Suffix  := Indexing
	| Conversion
	| Call.
Indexing := '[' Expr ']'.
Conversion := ':' type.
Call := '(' [ExprList] ')'.

Factor := Terminal
	| NestedExpr.
NestedExpr := '(' Expr ')'.
Terminal := id
          | true | false
          | int
          | 'syscall'.
