-- Lexer:
id := letter {letter | digit}.
letter = 'a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'i'|'j'|
         'k'|'l'|'m'|'n'|'o'|'p'|'q'|'r'|'s'|'t'|
         'u'|'v'|'w'|'x'|'y'|'z'|'A'|'B'|'C'|'D'|
         'E'|'F'|'G'|'H'|'I'|'J'|'K'|'L'|'M'|'N'|
         'O'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|
         'Y'|'Z'|'_'.
digits = '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'.
decDigits = digits | '_'.
hexDigits = digits | 'A'|'B'|'C'|'D'|'E'|'F'|'a'|'b'|'c'|'d'|'e'|'f'|'_'.
binDigits = '0'|'1'|'_'.
numEnding = 'p'|'s'|'ss'|'l'|'ll'|'us'|'uss'|'ul'|'ull'.
number := decimal | hexadecimal | binary.
decimal := digits {decDigits} [numEnding].
hexadecimal := '0x' hexDigits {hexDigits} [numEnding].
binary := '0b' binDigits {binDigits} [numEnding].

escapes := '\\"' | '\\'' | '\\n' | '\\t' | '\\r'.
string := '"'(ascii|escapes)*'"'.
char := "'"(ascii|escapes)"'".

keywords
    var    proc   begin  end
    while  if     else   elseif
    or     and    not    data
    i8     i16    i32    i64
    u8     u16    u32    u64
    bool   ptr    true   false
    exit   import from   export
    const  sizeof return set
    attr   struct.

ponctuation:
    ,   :   (   )   [   ]
    =   ==  !=  >   >=  < 
    <=  +   -   *   /   %
    -=  +=  *=  /=  %=  .
    @   ::  ~   &&  ||  !
    |^  >>  <<  ->  ^

basicType:
    i8  i16  i32  i64  ptr  bool
    u8  u16  u32  u64

-- Parser:
Module := {Coupling} {AttSymbol}.

Coupling := Import | FromImport | Export.

Import := 'import' IdList.
FromImport := 'from' id 'import' IdList.
Export := 'export' IdList.
IdList := id {',' id} [','].

AttSymbol := [Attributes] Symbol.
Attributes:= 'attr' IdList.

Symbol := Procedure
    | Data
    | Const
    | Struct.

Const := 'const' (SingleConst|MultipleConst).
SingleConst := id '=' Expr.
MultipleConst := 'begin' {SingleConst [';']} 'end'.

Data := 'data' (SingleData|MultipleData).
MultipleData := 'begin' {SingleData [';']} 'end'.
SingleData :=  id (DExpr|string|Blob).
Blob := '{' [Annot] ExprList '}'.
DExpr := '[' Expr ']'.

Struct := 'struct' id [Size] 'begin' Fields 'end'.
Size := '[' Expr ']'.
Field := id [Annot] [Offset].
Offset := '{' Expr '}'.

Procedure := 'proc' id [Args [Rets]] [Vars] Block.
Args := '[' [DeclList] ']'.
Vars := 'var' DeclList.
Rets := TypeList.
TypeList := Type {',' Type} [','].

DeclList := Decl {',' Decl} [','].
Decl := idList Annot.
Annot := ':' Type.

Type := basicType | ProcType | id.
ProcType := 'proc' '[' [TypeList] ']' ProcTypeRet.
ProcTypeRet := '[' [TypeList] ']'
             | [Type].

Block := 'begin' {CodeSemicolon} 'end'.

CodeSemicolon := Code [';'].

Code := If
      | While
      | Return
      | Set
      | Exit
      | Expr.

While := 'while' Expr Block.

If   := 'if' Expr Block {ElseIf} [Else].
ElseIf := 'elseif' Expr Block.
Else := 'else' Block.

Set := 'set' ExprList assignOp Expr.
assignOp := '=' | '-=' | '+=' | '/=' | '*=' | '%='.

Return := 'return' [ExprList].
Exit := 'exit' ['^'] Expr.

ExprList := Expr {',' Expr} [','].
Expr := And {'or' And}.
And := Comp {'and' Comp}.
Comp := Sum {compOp Sum}.
compOp := '==' | '!=' | '>' | '>=' | '<' | '<='.
Sum := Mult {sumOp Mult}.
sumOp := '+' | '-' | '||' | '|^'.
Mult := UnaryPrefix {multOp UnaryPrefix}.
multOp := '*' | '/' | '%' | '&&' | '<<' | '>>'.
UnaryPrefix := {Prefix} UnarySuffix.
UnarySuffix := Factor {Suffix}.

Prefix := 'not' | '~' | '!'.
Suffix := Conversion
    | Deref
    | Call
    | PropertyAccess
    | PropDeref.
Conversion := Annot.
Call := '[' [ExprList] ']'.
Deref := '@' Type.
PropertyAccess := '.' id.
PropDeref := '->' id.

Factor := Name
    | Literal
    | NestedExpr
    | "sizeof" Type.
NestedExpr := '(' Expr ')'.
Literal := true | false | number | char.
Name := id ["::" id].
